# Spring Cloud

*   [Features](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_features)
*   [Cloud Native Applications](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_cloud_native_applications)
    *   [Spring Cloud Context: Application Context Services](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_context_application_context_services)
        *   [The Bootstrap Application Context](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_the_bootstrap_application_context)
        *   [Application Context Hierarchies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_application_context_hierarchies)
        *   [Changing the Location of Bootstrap Properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#customizing-bootstrap-properties)
        *   [Overriding the Values of Remote Properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#overriding-bootstrap-properties)
        *   [Customizing the Bootstrap Configuration](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_customizing_the_bootstrap_configuration)
        *   [Customizing the Bootstrap Property Sources](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#customizing-bootstrap-property-sources)
        *   [Environment Changes](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_environment_changes)
        *   [Refresh Scope](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_refresh_scope)
        *   [Encryption and Decryption](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_encryption_and_decryption)
        *   [Endpoints](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_endpoints)
    *   [Spring Cloud Commons: Common Abstractions](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_commons_common_abstractions)
        *   [@EnableDiscoveryClient](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#__enablediscoveryclient)
        *   [ServiceRegistry](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_serviceregistry)
        *   [Spring RestTemplate as a Load Balancer Client](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_resttemplate_as_a_load_balancer_client)
        *   [Multiple RestTemplate objects](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_multiple_resttemplate_objects)
        *   [Ignore Network Interfaces](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#ignore-network-interfaces)
*   [Spring Cloud Config](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_config)
    *   [Quick Start](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_quick_start)
        *   [Client Side Usage](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_client_side_usage)
    *   [Spring Cloud Config Server](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_config_server)
        *   [Environment Repository](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_environment_repository)
        *   [Health Indicator](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_health_indicator)
        *   [Security](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_security)
        *   [Encryption and Decryption](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_encryption_and_decryption_2)
        *   [Key Management](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_key_management)
        *   [Creating a Key Store for Testing](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_creating_a_key_store_for_testing)
        *   [Using Multiple Keys and Key Rotation](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_multiple_keys_and_key_rotation)
        *   [Serving Encrypted Properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_serving_encrypted_properties)
    *   [Serving Alternative Formats](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_serving_alternative_formats)
    *   [Serving Plain Text](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_serving_plain_text)
    *   [Embedding the Config Server](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_embedding_the_config_server)
    *   [Push Notifications and Spring Cloud Bus](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_push_notifications_and_spring_cloud_bus)
    *   [Spring Cloud Config Client](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_config_client)
        *   [Config First Bootstrap](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#config-first-bootstrap)
        *   [Discovery First Bootstrap](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#discovery-first-bootstrap)
        *   [Config Client Fail Fast](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#config-client-fail-fast)
        *   [Config Client Retry](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#config-client-retry)
        *   [Locating Remote Configuration Resources](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_locating_remote_configuration_resources)
        *   [Security](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_security_2)
*   [Spring Cloud Netflix](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix)
    *   [Service Discovery: Eureka Clients](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_service_discovery_eureka_clients)
        *   [Registering with Eureka](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_registering_with_eureka)
        *   [Authenticating with the Eureka Server](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_authenticating_with_the_eureka_server)
        *   [Status Page and Health Indicator](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_status_page_and_health_indicator)
        *   [Registering a Secure Application](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_registering_a_secure_application)
        *   [Eurekaâ€™s Health Checks](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_eureka_s_health_checks)
        *   [Eureka Metadata for Instances and Clients](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_eureka_metadata_for_instances_and_clients)
        *   [Using the EurekaClient](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_the_eurekaclient)
        *   [Alternatives to the native Netflix EurekaClient](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_alternatives_to_the_native_netflix_eurekaclient)
        *   [Why is it so Slow to Register a Service?](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_why_is_it_so_slow_to_register_a_service)
    *   [Service Discovery: Eureka Server](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-eureka-server)
        *   [High Availability, Zones and Regions](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_high_availability_zones_and_regions)
        *   [Standalone Mode](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_standalone_mode)
        *   [Peer Awareness](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_peer_awareness)
        *   [Prefer IP Address](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_prefer_ip_address)
    *   [Circuit Breaker: Hystrix Clients](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_circuit_breaker_hystrix_clients)
        *   [Propagating the Security Context or using Spring Scopes](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_propagating_the_security_context_or_using_spring_scopes)
        *   [Health Indicator](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_health_indicator_2)
        *   [Hystrix Metrics Stream](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_hystrix_metrics_stream)
    *   [Circuit Breaker: Hystrix Dashboard](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_circuit_breaker_hystrix_dashboard)
        *   [Turbine](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_turbine)
        *   [Turbine Stream](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_turbine_stream)
    *   [Client Side Load Balancer: Ribbon](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon)
        *   [Customizing the Ribbon Client](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_customizing_the_ribbon_client)
        *   [Using Ribbon with Eureka](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_ribbon_with_eureka)
        *   [Example: How to Use Ribbon Without Eureka](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon-without-eureka)
        *   [Example: Disable Eureka use in Ribbon](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_example_disable_eureka_use_in_ribbon)
        *   [Using the Ribbon API Directly](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_the_ribbon_api_directly)
    *   [Declarative REST Client: Feign](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign)
        *   [Overriding Feign Defaults](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign-overriding-defaults)
        *   [Feign Hystrix Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign-hystrix)
        *   [Feign Hystrix Fallbacks](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign-hystrix-fallback)
        *   [Feign Inheritance Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign-inheritance)
        *   [Feign request/response compression](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_feign_request_response_compression)
        *   [Feign logging](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_feign_logging)
    *   [External Configuration: Archaius](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_external_configuration_archaius)
    *   [Router and Filter: Zuul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_router_and_filter_zuul)
        *   [Embedded Zuul Reverse Proxy](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#netflix-zuul-reverse-proxy)
        *   [Cookies and Sensitive Headers](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_cookies_and_sensitive_headers)
        *   [The Routes Endpoint](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_the_routes_endpoint)
        *   [Strangulation Patterns and Local Forwards](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_strangulation_patterns_and_local_forwards)
        *   [Uploading Files through Zuul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_uploading_files_through_zuul)
        *   [Plain Embedded Zuul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_plain_embedded_zuul)
        *   [Disable Zuul Filters](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_disable_zuul_filters)
        *   [Polyglot support with Sidecar](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_polyglot_support_with_sidecar)
    *   [RxJava with Spring MVC](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#netflix-rxjava-springmvc)
    *   [Metrics: Spectator, Servo, and Atlas](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#netflix-metrics)
        *   [Dimensional vs. Hierarchical Metrics](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_dimensional_vs_hierarchical_metrics)
        *   [Default Metrics Collection](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_default_metrics_collection)
        *   [Metrics Collection: Spectator](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#netflix-metrics-spectator)
        *   [Metrics Collection: Servo](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#netflix-metrics-servo)
        *   [Metrics Backend: Atlas](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#netflix-metrics-atlas)
*   [Spring Cloud Stream](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_stream)
    *   [Introducing Spring Cloud Stream](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_introducing_spring_cloud_stream)
    *   [Main Concepts](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_main_concepts)
        *   [Application Model](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_application_model)
        *   [The Binder Abstraction](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_the_binder_abstraction)
        *   [Persistent Publish-Subscribe Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_persistent_publish_subscribe_support)
        *   [Consumer Groups](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#consumer-groups)
        *   [Partitioning Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#partitioning)
    *   [Programming Model](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_programming_model)
        *   [Declaring and Binding Channels](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_declaring_and_binding_channels)
    *   [Binders](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_binders)
        *   [Producers and Consumers](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_producers_and_consumers)
        *   [Binder SPI](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_binder_spi)
        *   [Binder Detection](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_binder_detection)
        *   [Multiple Binders on the Classpath](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#multiple-binders)
        *   [Connecting to Multiple Systems](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#multiple-systems)
        *   [Binder configuration properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_binder_configuration_properties)
        *   [Implementation strategies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_implementation_strategies)
    *   [Configuration Options](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_configuration_options)
        *   [Spring Cloud Stream Properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_stream_properties)
        *   [Binding Properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#binding-properties)
    *   [Binder-Specific Configuration](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#binder-specific-configuration)
        *   [Rabbit-Specific Settings](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_rabbit_specific_settings)
        *   [Kafka-Specific Settings](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_kafka_specific_settings)
    *   [Content Type and Transformation](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#contenttypemanagement)
        *   [MIME types](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#mime-types)
        *   [MIME types and Java types](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#mime-types-and-java-types)
        *   [`@StreamListener` and Message Conversion](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#__code_streamlistener_code_and_message_conversion)
    *   [Inter-Application Communication](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_inter_application_communication)
        *   [Connecting Multiple Application Instances](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_connecting_multiple_application_instances)
        *   [Instance Index and Instance Count](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_instance_index_and_instance_count)
        *   [Partitioning](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_partitioning)
    *   [Testing](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_testing)
    *   [Health Indicator](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_health_indicator_3)
    *   [Samples](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_samples)
    *   [Getting Started](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_getting_started)
*   [Spring Cloud Bus](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_bus)
    *   [Quick Start](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_quick_start_2)
    *   [Addressing an Instance](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_addressing_an_instance)
    *   [Addressing all instances of a service](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_addressing_all_instances_of_a_service)
    *   [Application Context ID must be unique](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_application_context_id_must_be_unique)
    *   [Customizing the Message Broker](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_customizing_the_message_broker)
    *   [Tracing Bus Events](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_tracing_bus_events)
    *   [Broadcasting Your Own Events](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_broadcasting_your_own_events)
*   [Spring Cloud Sleuth](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_sleuth)
    *   [Terminology](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_terminology)
    *   [Purpose](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_purpose)
    *   [Adding to the project](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_adding_to_the_project)
    *   [Additional resources](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_additional_resources)
    *   [Features](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_features_2)
    *   [Sampling](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_sampling)
    *   [Instrumentation](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_instrumentation)
    *   [Span lifecycle](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_span_lifecycle)
        *   [Creating and closing spans](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#creating-and-closing-spans)
        *   [Continuing spans](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#continuing-spans)
        *   [Creating spans with an explicit parent](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#creating-spans-with-explicit-parent)
    *   [Naming spans](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_naming_spans)
        *   [@SpanName annotation](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#__spanname_annotation)
        *   [toString() method](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_tostring_method)
    *   [Customizations](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_customizations)
        *   [Spring Integration](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_integration)
        *   [HTTP](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_http)
        *   [Example](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_example)
        *   [Custom SA tag in Zipkin](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_custom_sa_tag_in_zipkin)
        *   [Custom service name](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_custom_service_name)
    *   [Span Data as Messages](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_span_data_as_messages)
        *   [Zipkin Consumer](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_zipkin_consumer)
        *   [Custom Consumer](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_custom_consumer)
    *   [Metrics](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_metrics)
    *   [Integrations](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_integrations)
        *   [Runnable and Callable](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_runnable_and_callable)
        *   [Hystrix](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_hystrix)
        *   [RxJava](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_rxjava)
        *   [HTTP integration](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_http_integration)
        *   [HTTP client integration](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_http_client_integration)
        *   [Feign](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_feign)
        *   [Asynchronous communication](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_asynchronous_communication)
        *   [Messaging](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_messaging)
        *   [Zuul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_zuul)
    *   [Running examples](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_running_examples)
*   [Spring Cloud Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_consul)
    *   [Install Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-install)
    *   [Consul Agent](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-agent)
    *   [Service Discovery with Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-discovery)
        *   [Registering with Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_registering_with_consul)
        *   [HTTP Health Check](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_http_health_check)
        *   [Using the DiscoveryClient](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_the_discoveryclient)
    *   [Distributed Configuration with Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-config)
        *   [How to activate](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_how_to_activate)
        *   [Customizing](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_customizing)
    *   [YAML or Properties with Config](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-config-format)
    *   [git2consul with Config](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-config-git2consul)
    *   [Fail Fast](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-failfast)
    *   [Consul Retry](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-retry)
    *   [Spring Cloud Bus with Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-bus)
    *   [Circuit Breaker with Hystrix](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-hystrix)
    *   [Hystrix metrics aggregation with Turbine and Consul](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-turbine)
*   [Spring Cloud Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_zookeeper)
    *   [Install Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-zookeeper-install)
    *   [Service Discovery with Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-zookeeper-discovery)
        *   [How to activate](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_how_to_activate_2)
        *   [Registering with Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_registering_with_zookeeper)
        *   [Using the DiscoveryClient](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_the_discoveryclient_2)
    *   [Zookeeper Dependencies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-zookeeper-dependencies)
        *   [Using the Zookeeper Dependencies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_using_the_zookeeper_dependencies)
        *   [How to activate Zookeeper Dependencies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_how_to_activate_zookeeper_dependencies)
        *   [Setting up Zookeeper Dependencies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_setting_up_zookeeper_dependencies)
        *   [Configuring Spring Cloud Zookeeper Dependencies](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_configuring_spring_cloud_zookeeper_dependencies)
    *   [Spring Cloud Zookeeper Dependency Watcher](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-zookeeper-dependency-watcher)
        *   [How to activate](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_how_to_activate_3)
        *   [Registering a listener](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_registering_a_listener)
        *   [Presence Checker](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_presence_checker)
    *   [Distributed Configuration with Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-zookeeper-config)
        *   [How to activate](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_how_to_activate_4)
        *   [Customizing](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_customizing_2)
*   [Spring Boot Cloud CLI](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_boot_cloud_cli)
    *   [Installation](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_installation)
    *   [Running Spring Cloud Services in Development](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_running_spring_cloud_services_in_development)
        *   [Adding Additional Applications](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_adding_additional_applications)
    *   [Writing Groovy Scripts and Running Applications](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_writing_groovy_scripts_and_running_applications)
    *   [Encryption and Decryption](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_encryption_and_decryption_3)
*   [Spring Cloud Security](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_security)
    *   [Quickstart](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_quickstart)
        *   [OAuth2 Single Sign On](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_oauth2_single_sign_on)
        *   [OAuth2 Protected Resource](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_oauth2_protected_resource)
    *   [More Detail](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_more_detail)
        *   [Single Sign On](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_single_sign_on)
        *   [Token Relay](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_token_relay)
    *   [Configuring Authentication Downstream of a Zuul Proxy](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_configuring_authentication_downstream_of_a_zuul_proxy)
*   [Spring Cloud for Cloud Foundry](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_for_cloud_foundry)
    *   [Discovery](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_discovery)
    *   [Single Sign On](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_single_sign_on_2)
*   [Spring Cloud Cluster](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_cluster)
    *   [Leader Election](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_leader_election)
        *   [Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-cluster-leaderelection-zookeeper)
        *   [Hazelcast](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-cluster-leaderelection-hazelcast)
        *   [Etcd](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-cluster-leaderelection-etcd)
*   [Appendix: Compendium of Configuration Properties](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_appendix_compendium_of_configuration_properties)













Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developerâ€™s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.





Version: Brixton.BUILD-SNAPSHOT









## Features





Spring Cloud focuses on providing good out of box experience for typical use cases and extensibility mechanism to cover others.





*   Distributed/versioned configuration

*   Service registration and discovery

*   Routing

*   Service-to-service calls

*   Load balancing

*   Circuit Breakers

*   Global locks

*   Leadership election and cluster state

*   Distributed messaging







# Cloud Native Applications







[Cloud Native](https://pivotal.io/platform-as-a-service/migrating-to-cloud-native-application-architectures-ebook) is a style of application development that encourages easy adoption of best practices in the areas of continuous delivery and value-driven development. A related discipline is that of building [12-factor Apps](http://12factor.net/) in which development practices are aligned with delivery and operations goals, for instance by using declarative programming and management and monitoring. Spring Cloud facilitates these styles of development in a number of specific ways and the starting point is a set of features that all components in a distributed system either need or need easy access to when required.





Many of those features are covered by [Spring Boot](http://projects.spring.io/spring-boot), which we build on in Spring Cloud. Some more are delivered by Spring Cloud as two libraries: Spring Cloud Context and Spring Cloud Commons. Spring Cloud Context provides utilities and special services for the `ApplicationContext` of a Spring Cloud application (bootstrap context, encryption, refresh scope and environment endpoints). Spring Cloud Commons is a set of abstractions and common classes used in different Spring Cloud implementations (eg. Spring Cloud Netflix vs. Spring Cloud Consul).





If you are getting an exception due to "Illegal key size" and you are using Sunâ€™s JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files. See the following links for more information:





*   [Java 6 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html)

*   [Java 7 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html)

*   [Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)





Extract files into JDK/jre/lib/security folder (whichever version of JRE/JDK x64/x86 you are using).

















<td class="content">Spring Cloud is released under the non-restrictive Apache 2.0 license. If you would like to contribute to this section of the documentation or if you find an error, please find the source code and issue trackers in the project at [github](https://github.com/spring-cloud/spring-cloud-commons/tree/master/docs/src/main/asciidoc).















## Spring Cloud Context: Application Context Services





Spring Boot has an opinionated view of how to build an application with Spring: for instance it has conventional locations for common configuration file, and endpoints for common management and monitoring tasks. Spring Cloud builds on top of that and adds a few features that probably all components in a system would use or occasionally need.





### The Bootstrap Application Context



A Spring Cloud application operates by creating a "bootstrap" context, which is a parent context for the main application. Out of the box it is responsible for loading configuration properties from the external sources, and also decrypting properties in the local external configuration files. The two contexts share an `Environment` which is the source of external properties for any Spring application. Bootstrap properties are added with high precedence, so they cannot be overridden by local configuration, by default.





The bootstrap context uses a different convention for locating external configuration than the main application context, so instead of `application.yml` (or `.properties`) you use `bootstrap.yml`, keeping the external configuration for bootstrap and main context nicely separate. Example:









<pre>spring:
  application:
    name: foo
  cloud:
    config:
      uri: ${SPRING_CONFIG_URI:http://localhost:8888}</pre>







It is a good idea to set the `spring.application.name` (in `bootstrap.yml` or `application.yml`) if your application needs any application-specific configuration from the server.





You can disable the bootstrap process completely by setting `spring.cloud.bootstrap.enabled=false` (e.g. in System properties).







### Application Context Hierarchies



If you build an application context from `SpringApplication` or `SpringApplicationBuilder`, then the Bootstrap context is added as a parent to that context. It is a feature of Spring that child contexts inherit property sources and profiles from their parent, so the "main" application context will contain additional property sources, compared to building the same context without Spring Cloud Config. The additional property sources are:





*   "bootstrap": an optional `CompositePropertySource` appears with high priority if any `PropertySourceLocators` are found in the Bootstrap context, and they have non-empty properties. An example would be properties from the Spring Cloud Config Server. See [below](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#customizing-bootstrap-property-sources) for instructions on how to customize the contents of this property source.

*   "applicationConfig: [classpath:bootstrap.yml]" (and friends if Spring profiles are active). If you have a `bootstrap.yml` (or properties) then those properties are used to configure the Bootstrap context, and then they get added to the child context when its parent is set. They have lower precedence than the `application.yml` (or properties) and any other property sources that are added to the child as a normal part of the process of creating a Spring Boot application. See [below](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#customizing-bootstrap-properties) for instructions on how to customize the contents of these property sources.





Because of the ordering rules of property sources the "bootstrap" entries take precedence, but note that these do not contain any data from `bootstrap.yml`, which has very low precedence, but can be used to set defaults.





You can extend the context hierarchy by simply setting the parent context of any `ApplicationContext` you create, e.g. using its own interface, or with the `SpringApplicationBuilder` convenience methods (`parent()`, `child()` and `sibling()`). The bootstrap context will be the parent of the most senior ancestor that you create yourself. Every context in the hierarchy will have its own "bootstrap" property source (possibly empty) to avoid promoting values inadvertently from parents down to their descendants. Every context in the hierarchy can also (in principle) have a different `spring.application.name` and hence a different remote property source if there is a Config Server. Normal Spring application context behaviour rules apply to property resolution: properties from a child context override those in the parent, by name and also by property source name (if the child has a property source with the same name as the parent, the one from the parent is not included in the child).





Note that the `SpringApplicationBuilder` allows you to share an `Environment` amongst the whole hierarchy, but that is not the default. Thus, sibling contexts in particular do not need to have the same profiles or property sources, even though they will share common things with their parent.







### Changing the Location of Bootstrap Properties



The `bootstrap.yml` (or `.properties`) location can be specified using `spring.cloud.bootstrap.name` (default "bootstrap") or `spring.cloud.bootstrap.location` (default empty), e.g. in System properties. Those properties behave like the `spring.config.*` variants with the same name, in fact they are used to set up the bootstrap `ApplicationContext` by setting those properties in its `Environment`. If there is an active profile (from `spring.profiles.active` or through the `Environment` API in the context you are building) then properties in that profile will be loaded as well, just like in a regular Spring Boot app, e.g. from `bootstrap-development.properties` for a "development" profile.







### Overriding the Values of Remote Properties



The property sources that are added to you application by the bootstrap context are often "remote" (e.g. from a Config Server), and by default they cannot be overridden locally, except on the command line. If you want to allow your applications to override the remote properties with their own System properties or config files, the remote property source has to grant it permission by setting `spring.cloud.config.allowOverride=true` (it doesnâ€™t work to set this locally). Once that flag is set there are some finer grained settings to control the location of the remote properties in relation to System properties and the applicationâ€™s local configuration: `spring.cloud.config.overrideNone=true` to override with any local property source, and `spring.cloud.config.overrideSystemProperties=false` if only System properties and env vars should override the remote settings, but not the local config files.







### Customizing the Bootstrap Configuration



The bootstrap context can be trained to do anything you like by adding entries to `/META-INF/spring.factories` under the key `org.springframework.cloud.bootstrap.BootstrapConfiguration`. This is a comma-separated list of Spring `@Configuration` classes which will be used to create the context. Any beans that you want to be available to the main application context for autowiring can be created here, and also there is a special contract for `@Beans` of type `ApplicationContextInitializer`. Classes can be marked with an `@Order` if you want to control the startup sequence (the default order is "last").

















<td class="content">Be careful when adding custom `BootstrapConfiguration` that the classes you add are not `@ComponentScanned` by mistake into your "main" application context, where they might not be needed. Use a separate package name for boot configuration classes that is not already covered by your `@ComponentScan` or `@SpringBootApplication` annotated configuration classes.











The bootstrap process ends by injecting initializers into the main `SpringApplication` instance (i.e. the normal Spring Boot startup sequence, whether it is running as a standalone app or deployed in an application server). First a bootstrap context is created from the classes found in `spring.factories` and then all `@Beans` of type `ApplicationContextInitializer` are added to the main `SpringApplication` before it is started.







### Customizing the Bootstrap Property Sources



The default property source for external configuration added by the bootstrap process is the Config Server, but you can add additional sources by adding beans of type `PropertySourceLocator` to the bootstrap context (via `spring.factories`). You could use this to insert additional properties from a different server, or from a database, for instance.





As an example, consider the following trivial custom locator:







    @Configuration
    public class CustomPropertySourceLocator implements PropertySourceLocator {

        @Override
        public PropertySource<?> locate(Environment environment) {
            return new MapPropertySource("customProperty",
                    Collections.<String, Object>singletonMap("property.from.sample.custom.source", "worked as intended"));
        }

    }







The `Environment` that is passed in is the one for the `ApplicationContext` about to be created, i.e. the one that we are supplying additional property sources for. It will already have its normal Spring Boot-provided property sources, so you can use those to locate a property source specific to this `Environment` (e.g. by keying it on the `spring.application.name`, as is done in the default Config Server property source locator).





If you create a jar with this class in it and then add a `META-INF/spring.factories` containing:







<pre>org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator</pre>







then the "customProperty" `PropertySource` will show up in any application that includes that jar on its classpath.







### Environment Changes



The application will listen for an `EnvironmentChangeEvent` and react to the change in a couple of standard ways (additional `ApplicationListeners` can be added as `@Beans` by the user in the normal way). When an `EnvironmentChangeEvent` is observed it will have a list of key values that have changed, and the application will use those to:





*   Re-bind any `@ConfigurationProperties` beans in the context

*   Set the logger levels for any properties in `logging.level.*`





Note that the Config Client does not by default poll for changes in the `Environment`, and generally we would not recommend that approach for detecting changes (although you could set it up with a `@Scheduled` annotation). If you have a scaled-out client application then it is better to broadcast the `EnvironmentChangeEvent` to all the instances instead of having them polling for changes (e.g. using the [Spring Cloud Bus](https://github.com/spring-cloud/spring-cloud-bus)).





The `EnvironmentChangeEvent` covers a large class of refresh use cases, as long as you can actually make a change to the `Environment` and publish the event (those APIs are public and part of core Spring). You can verify the changes are bound to `@ConfigurationProperties` beans by visiting the `/configprops` endpoint (normal Spring Boot Actuator feature). For instance a `DataSource` can have its `maxPoolSize` changed at runtime (the default `DataSource` created by Spring Boot is an `@ConfigurationProperties` bean) and grow capacity dynamically. Re-binding `@ConfigurationProperties` does not cover another large class of use cases, where you need more control over the refresh, and where you need a change to be atomic over the whole `ApplicationContext`. To address those concerns we have `@RefreshScope`.







### Refresh Scope



A Spring `@Bean` that is marked as `@RefreshScope` will get special treatment when there is a configuration change. This addresses the problem of stateful beans that only get their configuration injected when they are initialized. For instance if a `DataSource` has open connections when the database URL is changed via the `Environment`, we probably want the holders of those connections to be able to complete what they are doing. Then the next time someone borrows a connection from the pool he gets one with the new URL.





Refresh scope beans are lazy proxies that initialize when they are used (i.e. when a method is called), and the scope acts as a cache of initialized values. To force a bean to re-initialize on the next method call you just need to invalidate its cache entry.





The `RefreshScope` is a bean in the context and it has a public method `refreshAll()` to refresh all beans in the scope by clearing the target cache. There is also a `refresh(String)` method to refresh an individual bean by name. This functionality is exposed in the `/refresh` endpoint (over HTTP or JMX).

















<td class="content">`@RefreshScope` works (technically) on an `@Configuration` class, but it might lead to surprising behaviour: e.g. it does **not** mean that all the `@Beans` defined in that class are themselves `@RefreshScope`. Specifically, anything that depends on those beans cannot rely on them being updated when a refresh is initiated, unless it is itself in `@RefreshScope` (in which it will be rebuilt on a refresh and its dependencies re-injected, at which point they will be re-initialized from the refreshed `@Configuration`).













### Encryption and Decryption



Spring Cloud has an `Environment` pre-processor for decrypting property values locally. It follows the same rules as the Config Server, and has the same external configuration via `encrypt.*`. Thus you can use encrypted values in the form `{cipher}*` and as long as there is a valid key then they will be decrypted before the main application context gets the `Environment`. To use the encryption features in an application you need to include Spring Security RSA in your classpath (Maven co-ordinates "org.springframework.security:spring-security-rsa") and you also need the full strength JCE extensions in your JVM.





If you are getting an exception due to "Illegal key size" and you are using Sunâ€™s JDK, you need to install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files. See the following links for more information:





*   [Java 6 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html)

*   [Java 7 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html)

*   [Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)





Extract files into JDK/jre/lib/security folder (whichever version of JRE/JDK x64/x86 you are using).







### Endpoints



For a Spring Boot Actuator application there are some additional management endpoints:





*   POST to `/env` to update the `Environment` and rebind `@ConfigurationProperties` and log levels

*   `/refresh` for re-loading the boot strap context and refreshing the `@RefreshScope` beans

*   `/restart` for closing the `ApplicationContext` and restarting it (disabled by default)

*   `/pause` and `/resume` for calling the `Lifecycle` methods (`stop()` and `start()` on the `ApplicationContext`)











## Spring Cloud Commons: Common Abstractions





Patterns such as service discovery, load balancing and circuit breakers lend themselves to a common abstraction layer that can be consumed by all Spring Cloud clients, independent of the implementation (e.g. discovery via Eureka or Consul).





### @EnableDiscoveryClient



Commons provides the `@EnableDiscoveryClient` annotation. This looks for implementations of the `DiscoveryClient` interface via `META-INF/spring.factories`. Implementations of Discovery Client will add a configuration class to `spring.factories` under the `org.springframework.cloud.client.discovery.EnableDiscoveryClient` key. Examples of `DiscoveryClient` implementations: are [Spring Cloud Netflix Eureka](http://cloud.spring.io/spring-cloud-netflix/), [Spring Cloud Consul Discovery](http://cloud.spring.io/spring-cloud-consul/) and [Spring Cloud Zookeeper Discovery](http://cloud.spring.io/spring-cloud-zookeeper/).





By default, implementations of `DiscoveryClient` will auto-register the local Spring Boot server with the remote discovery server. This can be disabled by setting `autoRegister=false` in `@EnableDiscoveryClient`.







### ServiceRegistry



Commons now provides a `ServiceRegistry` interface which provides methods like `register(Registration)` and `deregister(Registration)` which allow you to provide custom registered services. `Registration` is a marker interface.





#### Service Registry Actuator Endpoint



A `/service-registry` actuator endpoint is provided by Commons. This endpoint relys on a `Registration` bean in the Spring Application Context. Calling `/service-registry/instance-status` via a GET will return the status of the `Registration`. A POST to the same endpoint with a `String` body will change the status of the current `Registration` to the new value. Please see the documentation of the `ServiceRegistry` implementation you are using for the allowed values for updating the status and the values retured for the status.









### Spring RestTemplate as a Load Balancer Client



`RestTemplate` can be automatically configured to use ribbon. To create a load balanced `RestTemplate` create a `RestTemplate` `@Bean` and use the `@LoadBalanced` qualifier.

















<td class="content">A `RestTemplate` bean is no longer created via auto configuration. It must be created by individual applications.













    @Configuration
    public class MyConfiguration {

        @LoadBalanced
        @Bean
        RestTemplate restTemplate() {
            return new RestTemplate();
        }
    }

    public class MyClass {
        @Autowired
        private RestTemplate restTemplate;

        public String doOtherStuff() {
            String results = restTemplate.getForObject("http://stores/stores", String.class);
            return results;
        }
    }







The URI needs to use a virtual host name (ie. service name, not a host name). The Ribbon client is used to create a full physical address. See [RibbonAutoConfiguration](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonAutoConfiguration.java) for details of how the `RestTemplate` is set up.





#### Retrying Failed Requests



A load balanced `RestTemplate` can be configured to retry failed requests. By default this logic is disabled, you can enable it by setting `spring.cloud.loadbalancer.retry.enabled=true`. The load balanced `RestTemplate` will honor some of the Ribbon configuration values related to retrying failed requests. The properties you can use are `client.ribbon.MaxAutoRetries`, `client.ribbon.MaxAutoRetriesNextServer`, and `client.ribbon.OkToRetryOnAllOperations`. See the [Ribbon documentation](https://github.com/Netflix/ribbon/wiki/Getting-Started#the-properties-file-sample-clientproperties) for a description of what there properties do.

















<td class="content">`client` in the above examples should be replaced with your Ribbon clientâ€™s name.















### Multiple RestTemplate objects



If you want a `RestTemplate` that is not load balanced, create a `RestTemplate` bean and inject it as normal. To access the load balanced `RestTemplate use the `@LoadBalanced` qualifier when you create your `@Bean`.

















<td class="content">Notice the `@Primary` annotation on the plain `RestTemplate` declaration in the example below, to disambiguate the unqualified `@Autowired` injection.













    @Configuration
    public class MyConfiguration {

        @LoadBalanced
        @Bean
        RestTemplate loadBalanced() {
            return new RestTemplate();
        }

        @Primary
        @Bean
        RestTemplate restTemplate() {
            return new RestTemplate();
        }
    }

    public class MyClass {
        @Autowired
        private RestTemplate restTemplate;

        @Autowired
        @LoadBalanced
        private RestTemplate loadBalanced;

        public String doOtherStuff() {
            return loadBalanced.getForObject("http://stores/stores", String.class);
        }

        public String doStuff() {
            return restTemplate.getForObject("http://example.com", String.class);
        }
    }



















<td class="content">If you see errors like `java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89` try injecting `RestOperations` instead or setting `spring.aop.proxyTargetClass=true`.













### Ignore Network Interfaces



Sometimes it is useful to ignore certain named network interfaces so they can be excluded from Service Discovery registration (eg. running in a Docker container). A list of regular expressions can be set that will cause the desired network interfaces to be ignored. The following configuration will ignore the "docker0" interface and all interfaces that start with "veth".









<pre>spring:
  cloud:
    inetutils:
      ignoredInterfaces:
        - docker0
        - veth.*</pre>







You can also force to use only specified network addresses using list of regular expressions:









<pre>spring:
  cloud:
    inetutils:
      preferredNetworks:
        - 192.168
        - 10.0</pre>







You can also force to use only site local addresses. See [Inet4Address.html.isSiteLocalAddress()](https://docs.oracle.com/javase/8/docs/api/java/net/Inet4Address.html#isSiteLocalAddress--) for more details what is site local address.









<pre>spring:
  cloud:
    inetutils:
      useOnlySiteLocalInterfaces: true</pre>











# Spring Cloud Config









## Quick Start





Start the server:







<pre>$ cd spring-cloud-config-server
$ ../mvnw spring-boot:run</pre>







The server is a Spring Boot application so you can run it from your IDE instead if you prefer (the main class is `ConfigServerApplication`). Then try out a client:







<pre>$ curl localhost:8888/foo/development
{"name":"development","label":"master","propertySources":[
  {"name":"https://github.com/scratches/config-repo/foo-development.properties","source":{"bar":"spam"}},
  {"name":"https://github.com/scratches/config-repo/foo.properties","source":{"foo":"bar"}}
]}</pre>







The default strategy for locating property sources is to clone a git repository (at `spring.cloud.config.server.git.uri`) and use it to initialize a mini `SpringApplication`. The mini-applicationâ€™s `Environment` is used to enumerate property sources and publish them via a JSON endpoint.





The HTTP service has resources in the form:







<pre>/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties</pre>







where the "application" is injected as the `spring.config.name` in the `SpringApplication` (i.e. what is normally "application" in a regular Spring Boot app), "profile" is an active profile (or comma-separated list of properties), and "label" is an optional git label (defaults to "master".)





Spring Cloud Config Server pulls configuration for remote clients from a git repository (which must be provided):







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/spring-cloud-samples/config-repo







### Client Side Usage



To use these features in an application, just build it as a Spring Boot application that depends on spring-cloud-config-client (e.g. see the test cases for the config-client, or the sample app). The most convenient way to add the dependency is via a Spring Boot starter `org.springframework.cloud:spring-cloud-starter-config`. There is also a parent pom and BOM (`spring-cloud-starter-parent`) for Maven users and a Spring IO version management properties file for Gradle and Spring CLI users. Example Maven configuration:









    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.3.5.RELEASE</version>
        <relativePath /> <!-- lookup parent from repository -->
    </parent>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Brixton.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

    <!-- repositories also needed for snapshots and milestones -->







Then you can create a standard Spring Boot application, like this simple HTTP server:







<pre>@SpringBootApplication
@RestController
public class Application {

    @RequestMapping("/")
    public String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</pre>







When it runs it will pick up the external configuration from the default local config server on port 8888 if it is running. To modify the startup behaviour you can change the location of the config server using `bootstrap.properties` (like `application.properties` but for the bootstrap phase of an application context), e.g.







<pre>spring.cloud.config.uri: http://myconfigserver.com</pre>







The bootstrap properties will show up in the `/env` endpoint as a high-priority property source, e.g.







<pre>$ curl localhost:8080/env
{
  "profiles":[],
  "configService:https://github.com/spring-cloud-samples/config-repo/bar.properties":{"foo":"bar"},
  "servletContextInitParams":{},
  "systemProperties":{...},
  ...
}</pre>







(a property source called "configService:<URL of remote repository>/<file name>" contains the property "foo" with value "bar" and is highest priority).

















<td class="content">the URL in the property source name is the git repository not the config server URL.

















## Spring Cloud Config Server





The Server provides an HTTP, resource-based API for external configuration (name-value pairs, or equivalent YAML content). The server is easily embeddable in a Spring Boot application using the `@EnableConfigServer` annotation. So this app is a config server:









    @SpringBootApplication
    @EnableConfigServer
    public class ConfigServer {
      public static void main(String[] args) {
        SpringApplication.run(ConfigServer.class, args);
      }
    }







Like all Spring Boot apps it runs on port 8080 by default, but you can switch it to the conventional port 8888 in various ways. The easiest, which also sets a default configuration repository, is by launching it with `spring.config.name=configserver` (there is a `configserver.yml` in the Config Server jar). Another is to use your own `application.properties`, e.g.









    server.port: 8888
    spring.cloud.config.server.git.uri: file://${user.home}/config-repo







where `${user.home}/config-repo` is a git repository containing YAML and properties files.

















<td class="content">in Windows you need an extra "/" in the file URL if it is absolute with a drive prefix, e.g. `[file:///${user.home}/config-repo](file:///$%7Buser.home%7D/config-repo)`.



























Hereâ€™s a recipe for creating the git repository in the example above:







<pre>$ cd $HOME
$ mkdir config-repo
$ cd config-repo
$ git init .
$ echo info.foo: bar > application.properties
$ git add -A .
$ git commit -m "Add application.properties"</pre>





























<td class="content">using the local filesystem for your git repository is intended for testing only. Use a server to host your configuration repositories in production.























<td class="content">the initial clone of your configuration repository will be quick and efficient if you only keep text files in it. If you start to store binary files, especially large ones, you may experience delays on the first request for configuration and/or out of memory errors in the server.











### Environment Repository



Where do you want to store the configuration data for the Config Server? The strategy that governs this behaviour is the `EnvironmentRepository`, serving `Environment` objects. This `Environment` is a shallow copy of the domain from the Spring `Environment` (including `propertySources` as the main feature). The `Environment` resources are parametrized by three variables:





*   `{application}` maps to "spring.application.name" on the client side;

*   `{profile}` maps to "spring.profiles.active" on the client (comma separated list); and

*   `{label}` which is a server side feature labelling a "versioned" set of config files.





Repository implementations generally behave just like a Spring Boot application loading configuration files from a "spring.config.name" equal to the `{application}` parameter, and "spring.profiles.active" equal to the `{profiles}` parameter. Precedence rules for profiles are also the same as in a regular Boot application: active profiles take precedence over defaults, and if there are multiple profiles the last one wins (like adding entries to a `Map`).





Example: a client application has this bootstrap configuration:









    spring:
      application:
        name: foo
      profiles:
        active: dev,mysql







(as usual with a Spring Boot application, these properties could also be set as environment variables or command line arguments).





If the repository is file-based, the server will create an `Environment` from `application.yml` (shared between all clients), and `foo.yml` (with `foo.yml` taking precedence). If the YAML files have documents inside them that point to Spring profiles, those are applied with higher precedence (in order of the profiles listed), and if there are profile-specific YAML (or properties) files these are also applied with higher precedence than the defaults. Higher precedence translates to a `PropertySource` listed earlier in the `Environment`. (These are the same rules as apply in a standalone Spring Boot application.)





#### Git Backend



The default implementation of `EnvironmentRepository` uses a Git backend, which is very convenient for managing upgrades and physical environments, and also for auditing changes. To change the location of the repository you can set the "spring.cloud.config.server.git.uri" configuration property in the Config Server (e.g. in `application.yml`). If you set it with a `file:` prefix it should work from a local repository so you can get started quickly and easily without a server, but in that case the server operates directly on the local repository without cloning it (it doesnâ€™t matter if itâ€™s not bare because the Config Server never makes changes to the "remote" repository). To scale the Config Server up and make it highly available, you would need to have all instances of the server pointing to the same repository, so only a shared file system would work. Even in that case it is better to use the `ssh:` protocol for a shared filesystem repository, so that the server can clone it and use a local working copy as a cache.





This repository implementation maps the `{label}` parameter of the HTTP resource to a git label (commit id, branch name or tag). If the git branch or tag name contains a slash ("/") then the label in the HTTP URL should be specified with the special string "(_)" instead (to avoid ambiguity with other URL paths). Be careful with the brackets in the URL if you are using a command line client like curl (e.g. escape them from the shell with quotes '').





##### Placeholders in Git URI



Spring Cloud Config Server supports a git repository URL with placeholders for the `{application}` and `{profile}` (and `{label}` if you need it, but remember that the label is applied as a git label anyway). So you can easily support a "one repo per application" policy using (for example):







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/myorg/{application}







or a "one repo per profile" policy using a similar pattern but with `{profile}`.







##### Pattern Matching and Multiple Repositories



There is also support for more complex requirements with pattern matching on the application and profile name. The pattern format is a comma-separated list of `{application}/{profile}` names with wildcards (where a pattern beginning with a wildcard may need to be quoted). Example:







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/spring-cloud-samples/config-repo
              repos:
                simple: https://github.com/simple/config-repo
                special:
                  pattern: special*/dev*,*special*/dev*
                  uri: https://github.com/special/config-repo
                local:
                  pattern: local*
                  uri: file:/home/configsvc/config-repo







If `{application}/{profile}` does not match any of the patterns, it will use the default uri defined under "spring.cloud.config.server.git.uri". In the above example, for the "simple" repository, the pattern is `simple/*` (i.e. it only matches one application named "simple" in all profiles). The "local" repository matches all application names beginning with "local" in all profiles (the `/*` suffix is added automatically to any pattern that doesnâ€™t have a profile matcher).

















<td class="content">the "one-liner" short cut used in the "simple" example above can only be used if the only property to be set is the URI. If you need to set anything else (credentials, pattern, etc.) you need to use the full form.











The `pattern` property in the repo is actually an array, so you can use a YAML array (or `[0]`, `[1]`, etc. suffixes in properties files) to bind to multiple patterns. You may need to do this if you are going to run apps with multiple profiles. Example:







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/spring-cloud-samples/config-repo
              repos:
                development:
                  pattern:
                    - */development
                    - */staging
                  uri: https://github.com/development/config-repo
                staging:
                  pattern:
                    - */qa
                    - */production
                  uri: https://github.com/staging/config-repo



















<td class="content">Spring Cloud will guess that a pattern containing a profile that doesnâ€™t end in `*` implies that you actually want to match a list of profiles starting with this pattern (so `*/staging` is a shortcut for `["*/staging", "*/staging,*"]`). This is common where you need to run apps in the "development" profile locally but also the "cloud" profile remotely, for instance.











Every repository can also optionally store config files in sub-directories, and patterns to search for those directories can be specified as `searchPaths`. For example at the top level:







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/spring-cloud-samples/config-repo
              searchPaths: foo,bar*







In this example the server searches for config files in the top level and in the "foo/" sub-directory and also any sub-directory whose name begins with "bar".





By default the server clones remote repositories when configuration is first requested. The server can be configured to clone the repositories at startup. For example at the top level:







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://git/common/config-repo.git
              repos:
                team-a:
                    pattern: team-a-*
                    cloneOnStart: true
                    uri: http://git/team-a/config-repo.git
                team-b:
                    pattern: team-b-*
                    cloneOnStart: false
                    uri: http://git/team-b/config-repo.git
                team-c:
                    pattern: team-c-*
                    uri: http://git/team-a/config-repo.git







In this example the server clones team-aâ€™s config-repo on startup before it accepts any requests. All other repositories will not be cloned until configuration from the repository is requested.





To use HTTP basic authentication on the remote repository add the "username" and "password" properties separately (not in the URL), e.g.







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/spring-cloud-samples/config-repo
              username: trolley
              password: strongpassword







If you donâ€™t use HTTPS and user credentials, SSH should also work out of the box when you store keys in the default directories (`~/.ssh`) and the uri points to an SSH location, e.g. "[git@github.com](mailto:git@github.com):configuration/cloud-configuration". The repository is accessed using JGit, so any documentation you find on that should be applicable. HTTPS proxy settings can be set in `~/.git/config` or in the same way as for any other JVM process via system properties (`-Dhttps.proxyHost` and `-Dhttps.proxyPort`).

















<td class="content">If you donâ€™t know where your `~/.git` directory is us `git config --global` to manipulate the settings (e.g. `git config --global http.sslVerify false`).













##### Placeholders in Git Search Paths



Spring Cloud Config Server also supports a search path with placeholders for the `{application}` and `{profile}` (and `{label}` if you need it). Example:







    spring:
      cloud:
        config:
          server:
            git:
              uri: https://github.com/spring-cloud-samples/config-repo
              searchPaths: '{application}'







searches the repository for files in the same name as the directory (as well as the top level). Wildcards are also valid in a search path with placeholders (any matching directory is included in the search).









#### Version Control Backend Filesystem Use















<td class="content">With VCS based backends (git, svn) files are checked out or cloned to the local filesystem. By default they are put in the system temporary directory with a prefix of `config-repo-`. On linux, for example it could be `/tmp/config-repo-<randomid>`. Some operating systems [routinely clean out](https://serverfault.com/questions/377348/when-does-tmp-get-cleared/377349#377349) temporary directories. This can lead to unexpected behaviour such as missing properties. To avoid this problem, change the directory Config Server uses, by setting `spring.cloud.config.server.git.basedir` or `spring.cloud.config.server.svn.basedir` to a directory that does not reside in the system temp structure.













#### File System Backend



There is also a "native" profile in the Config Server that doesnâ€™t use Git, but just loads the config files from the local classpath or file system (any static URL you want to point to with "spring.cloud.config.server.native.searchLocations"). To use the native profile just launch the Config Server with "spring.profiles.active=native".

















<td class="content">Remember to use the `file:` prefix for file resources (the default without a prefix is usually the classpath). Just as with any Spring Boot configuration you can embed `${}`-style environment placeholders, but remember that absolute paths in Windows require an extra "/", e.g. `[file:///${user.home}/config-repo](file:///$%7Buser.home%7D/config-repo)`























<td class="content">The default value of the `searchLocations` is identical to a local Spring Boot application (so `[classpath:/, classpath:/config, file:./, file:./config]`). This does not expose the `application.properties` from the server to all clients because any property sources present in the server are removed before being sent to the client.























<td class="content">A filesystem backend is great for getting started quickly and for testing. To use it in production you need to be sure that the file system is reliable, and shared across all instances of the Config Server.











The search locations can contain placeholders for `{application}`, `{profile}` and `{label}`. In this way you can segregate the directories in the path, and choose a strategy that makes sense for you (e.g. sub-directory per application, or sub-directory per profile).





If you donâ€™t use placeholders in the search locations, this repository also appends the `{label}` parameter of the HTTP resource to a suffix on the search path, so properties files are loaded from each search location **and** a subdirectory with the same name as the label (the labelled properties take precedence in the Spring Environment). Thus the default behaviour with no placeholders is the same as adding a search location ending with `/{label}/. For example `file:/tmp/config` is the same as `file:/tmp/config,file:/tmp/config/{label}`







#### Sharing Configuration With All Applications



With file-based (i.e. git, svn and native) repositories, resources with file names in `application*` are shared between all client applications (so `application.properties`, `application.yml`, `application-*.properties` etc.). You can use resources with these file names to configure global defaults and have them overridden by application-specific files as necessary.





The #_property_overrides[property overrides] feature can also be used for setting global defaults, and with placeholders applications are allowed to override them locally.

















<td class="content">With the "native" profile (local file system backend) it is recommended that you use an explicit search location that isnâ€™t part of the serverâ€™s own configuration. Otherwise the `application*` resources in the default search locations are removed because they are part of the server.













#### Property Overrides



The Config Server has an "overrides" feature that allows the operator to provide configuration properties to all applications that cannot be accidentally changed by the application using the normal Spring Boot hooks. To declare overrides just add a map of name-value pairs to `spring.cloud.config.server.overrides`. For example







    spring:
      cloud:
        config:
          server:
            overrides:
              foo: bar







will cause all applications that are config clients to read `foo=bar` independent of their own configuration. (Of course an application can use the data in the Config Server in any way it likes, so overrides are not enforceable, but they do provide useful default behaviour if they are Spring Cloud Config clients.)

















<td class="content">Normal, Spring environment placeholders with "${}" can be escaped (and resolved on the client) by using backslash ("\") to escape the "$" or the "{", e.g. `\${app.foo:bar}` resolves to "bar" unless the app provides its own "app.foo". Note that in YAML you donâ€™t need to escape the backslash itself, but in properties files you do, when you configure the overrides on the server.











You can change the priority of all overrides in the client to be more like default values, allowing applications to supply their own values in environment variables or System properties, by setting the flag `spring.cloud.config.overrideNone=true` (default is false) in the remote repository.









### Health Indicator



Config Server comes with a Health Indicator that checks if the configured `EnvironmentRepository` is working. By default it asks the `EnvironmentRepository` for an application named `app`, the `default` profile and the default label provided by the `EnvironmentRepository` implementation.





You can configure the Health Indicator to check more applications along with custom profiles and custom labels, e.g.







    spring:
      cloud:
        config:
          server:
            health:
              repositories:
                myservice:
                  label: mylabel
                myservice-dev:
                  name: myservice
                  profiles: development







You can disable the Health Indicator by setting `spring.cloud.config.server.health.enabled=false`.







### Security



You are free to secure your Config Server in any way that makes sense to you (from physical network security to OAuth2 bearer tokens), and Spring Security and Spring Boot make it easy to do pretty much anything.





To use the default Spring Boot configured HTTP Basic security, just include Spring Security on the classpath (e.g. through `spring-boot-starter-security`). The default is a username of "user" and a randomly generated password, which isnâ€™t going to be very useful in practice, so we recommend you configure the password (via `security.user.password`) and encrypt it (see below for instructions on how to do that).







### Encryption and Decryption















<td class="content">**Prerequisites:** to use the encryption and decryption features you need the full-strength JCE installed in your JVM (itâ€™s not there by default). You can download the "Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files" from Oracle, and follow instructions for installation (essentially replace the 2 policy files in the JRE lib/security directory with the ones that you downloaded).











If the remote property sources contain encrypted content (values starting with `{cipher}`) they will be decrypted before sending to clients over HTTP. The main advantage of this set up is that the property values donâ€™t have to be in plain text when they are "at rest" (e.g. in a git repository). If a value cannot be decrypted it is removed from the property source and an additional property is added with the same key, but prefixed with "invalid." and a value that means "not applicable" (usually "<n/a>"). This is largely to prevent cipher text being used as a password and accidentally leaking.





If you are setting up a remote config repository for config client applications it might contain an `application.yml` like this, for instance:









    spring:
      datasource:
        username: dbuser
        password: '{cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ'







Encrypted values in a .properties file must not be wrapped in quotes, otherwise the value will not be decrypted:









<pre>spring.datasource.username: dbuser
spring.datasource.password: {cipher}FKSAJDFGYOS8F7GLHAKERGFHLSAJ</pre>







You can safely push this plain text to a shared git repository and the secret password is protected.





The server also exposes `/encrypt` and `/decrypt` endpoints (on the assumption that these will be secured and only accessed by authorized agents). If you are editing a remote config file you can use the Config Server to encrypt values by POSTing to the `/encrypt` endpoint, e.g.







<pre>$ curl localhost:8888/encrypt -d mysecret
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda</pre>







The inverse operation is also available via `/decrypt` (provided the server is configured with a symmetric key or a full key pair):







<pre>$ curl localhost:8888/decrypt -d 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>



















<td class="content">If you are testing like this with curl, then use `--data-urlencode` (instead of `-d`) or set an explicit `Content-Type: text/plain` to make sure curl encodes the data correctly when there are special characters ('+' is particularly tricky).











Take the encrypted value and add the `{cipher}` prefix before you put it in the YAML or properties file, and before you commit and push it to a remote, potentially insecure store.





The `/encrypt` and `/decrypt` endpoints also both accept paths of the form `/*/{name}/{profiles}` which can be used to control cryptography per application (name) and profile when clients call into the main Environment resource.

















<td class="content">to control the cryptography in this granular way you must also provide a `@Bean` of type `TextEncryptorLocator` that creates a different encryptor per name and profiles. The one that is provided by default does not do this (so all encryptions use the same key).











The `spring` command line client (with Spring Cloud CLI extensions installed) can also be used to encrypt and decrypt, e.g.







<pre>$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>







To use a key in a file (e.g. an RSA public key for encryption) prepend the key value with "@" and provide the file path, e.g.







<pre>$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</pre>







The key argument is mandatory (despite having a `--` prefix).







### Key Management



The Config Server can use a symmetric (shared) key or an asymmetric one (RSA key pair). The asymmetric choice is superior in terms of security, but it is often more convenient to use a symmetric key since it is just a single property value to configure.





To configure a symmetric key you just need to set `encrypt.key` to a secret String (or use an enviroment variable `ENCRYPT_KEY` to keep it out of plain text configuration files).





To configure an asymmetric key you can either set the key as a PEM-encoded text value (in `encrypt.key`), or via a keystore (e.g. as created by the `keytool` utility that comes with the JDK). The keystore properties are `encrypt.keyStore.*` with `*` equal to





*   `location` (a `Resource` location),

*   `password` (to unlock the keystore) and

*   `alias` (to identify which key in the store is to be used).





The encryption is done with the public key, and a private key is needed for decryption. Thus in principle you can configure only the public key in the server if you only want to do encryption (and are prepared to decrypt the values yourself locally with the private key). In practice you might not want to do that because it spreads the key management process around all the clients, instead of concentrating it in the server. On the other hand itâ€™s a useful option if your config server really is relatively insecure and only a handful of clients need the encrypted properties.







### Creating a Key Store for Testing



To create a keystore for testing you can do something like this:







<pre>$ keytool -genkeypair -alias mytestkey -keyalg RSA \
  -dname "CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US" \
  -keypass changeme -keystore server.jks -storepass letmein</pre>







Put the `server.jks` file in the classpath (for instance) and then in your `application.yml` for the Config Server:







    encrypt:
      keyStore:
        location: classpath:/server.jks
        password: letmein
        alias: mytestkey
        secret: changeme









### Using Multiple Keys and Key Rotation



In addition to the `{cipher}` prefix in encrypted property values, the Config Server looks for `{name:value}` prefixes (zero or many) before the start of the (Base64 encoded) cipher text. The keys are passed to a `TextEncryptorLocator` which can do whatever logic it needs to locate a `TextEncryptor` for the cipher. If you have configured a keystore (`encrypt.keystore.location`) the default locator will look for keys in the store with aliases as supplied by the "key" prefix, i.e. with a cipher text like this:







    foo:
      bar: `{cipher}{key:testkey}...`







the locator will look for a key named "testkey". A secret can also be supplied via a `{secret:â€¦â€‹}` value in the prefix, but if it is not the default is to use the keystore password (which is what you get when you build a keytore and donâ€™t specify a secret). If you **do** supply a secret it is recommended that you also encrypt the secrets using a custom `SecretLocator`.





Key rotation is hardly ever necessary on cryptographic grounds if the keys are only being used to encrypt a few bytes of configuration data (i.e. they are not being used elsewhere), but occasionally you might need to change the keys if there is a security breach for instance. In that case all the clients would need to change their source config files (e.g. in git) and use a new `{key:â€¦â€‹}` prefix in all the ciphers, checking beforehand of course that the key alias is available in the Config Server keystore.

















<td class="content">the `{name:value}` prefixes can also be added to plaintext posted to the `/encrypt` endpoint, if you want to let the Config Server handle all encryption as well as decryption.













### Serving Encrypted Properties



Sometimes you want the clients to decrypt the configuration locally, instead of doing it in the server. In that case you can still have /encrypt and /decrypt endpoints (if you provide the `encrypt.*` configuration to locate a key), but you need to explicitly switch off the decryption of outgoing properties using `spring.cloud.config.server.encrypt.enabled=false`. If you donâ€™t care about the endpoints, then it should work if you configure neither the key nor the enabled flag.











## Serving Alternative Formats





The default JSON format from the environment endpoints is perfect for consumption by Spring applications because it maps directly onto the `Environment` abstraction. If you prefer you can consume the same data as YAML or Java properties by adding a suffix to the resource path (".yml", ".yaml" or ".properties"). This can be useful for consumption by applications that do not care about the structure of the JSON endpoints, or the extra metadata they provide, for example an application that is not using Spring might benefit from the simplicity of this approach.





The YAML and properties representations have an additional flag (provided as a boolean query parameter `resolvePlaceholders`) to signal that placeholders in the source documents, in the standard Spring `${â€¦â€‹}` form, should be resolved in the output where possible before rendering. This is a useful feature for consumers that donâ€™t know about the Spring placeholder conventions.

















<td class="content">there are limitations in using the YAML or properties formats, mainly in relation to the loss of metadata. The JSON is structured as an ordered list of property sources, for example, with names that correlate with the source. The YAML and properties forms are coalesced into a single map, even if the origin of the values has multiple sources, and the names of the original source files are lost. The YAML representation is not necessarily a faithful representation of the YAML source in a backing repository either: it is constructed from a list of flat property sources, and assumptions have to be made about the form of the keys.















## Serving Plain Text





Instead of using the `Environment` abstraction (or one of the alternative representations of it in YAML or properties format) your applications might need generic plain text configuration files, tailored to their environment. The Config Server provides these through an additional endpoint at `/{name}/{profile}/{label}/{path}` where "name", "profile" and "label" have the same meaning as the regular environment endpoint, but "path" is a file name (e.g. `log.xml`). The source files for this endpoint are located in the same way as for the environment endpoints: the same search path is used as for properties or YAML files, but instead of aggregating all matching resources, only the first one to match is returned.





After a resource is located, placeholders in the normal format (`${â€¦â€‹}`) are resolved using the effective `Environment` for the application name, profile and label supplied. In this way the resource endpoint is tightly integrated with the environment endpoints. Example, if you have this layout for a GIT (or SVN) repository:







<pre>application.yml
nginx.conf</pre>







where `nginx.conf` looks like this:







<pre>server {
    listen              80;
    server_name         ${nginx.server.name};
}</pre>







and `application.yml` like this:







    nginx:
      server:
        name: example.com
    ---
    spring:
      profiles: development
    nginx:
      server:
        name: develop.com







then the `/foo/default/master/nginx.conf` resource looks like this:







<pre>server {
    listen              80;
    server_name         example.com;
}</pre>







and `/foo/development/master/nginx.conf` like this:







<pre>server {
    listen              80;
    server_name         develop.com;
}</pre>



















<td class="content">just like the source files for environment configuration, the "profile" is used to resolve the file name, so if you want a profile-specific file then `/*/development/*/logback.xml` will be resolved by a file called `logback-development.xml` (in preference to `logback.xml`).















## Embedding the Config Server





The Config Server runs best as a standalone application, but if you need to you can embed it in another application. Just use the `@EnableConfigServer` annotation. An optional property that can be useful in this case is `spring.cloud.config.server.bootstrap` which is a flag to indicate that the server should configure itself from its own remote repository. The flag is off by default because it can delay startup, but when embedded in another application it makes sense to initialize the same way as any other application.

















<td class="content">It should be obvious, but remember that if you use the bootstrap flag the config server will need to have its name and repository URI configured in `bootstrap.yml`.











To change the location of the server endpoints you can (optionally) set `spring.cloud.config.server.prefix`, e.g. "/config", to serve the resources under a prefix. The prefix should start but not end with a "/". It is applied to the `@RequestMappings` in the Config Server (i.e. underneath the Spring Boot prefixes `server.servletPath` and `server.contextPath`).





If you want to read the configuration for an application directly from the backend repository (instead of from the config server) thatâ€™s basically an embedded config server with no endpoints. You can switch off the endpoints entirely if you donâ€™t use the `@EnableConfigServer` annotation (just set `spring.cloud.config.server.bootstrap=true`).









## Push Notifications and Spring Cloud Bus





Many source code repository providers (like Github, Gitlab or Bitbucket for instance) will notify you of changes in a repository through a webhook. You can configure the webhook via the providerâ€™s user interface as a URL and a set of events in which you are interested. For instance [Github](https://developer.github.com/v3/activity/events/types/#pushevent) will POST to the webhook with a JSON body containing a list of commits, and a header "X-Github-Event" equal to "push". If you add a dependency on the `spring-cloud-config-monitor` library and activate the Spring Cloud Bus in your Config Server, then a "/monitor" endpoint is enabled.





When the webhook is activated the Config Server will send a `RefreshRemoteApplicationEvent` targeted at the applications it thinks might have changed. The change detection can be strategized, but by default it just looks for changes in files that match the application name (e.g. "foo.properties" is targeted at the "foo" application, and "application.properties" is targeted at all applications). The strategy if you want to override the behaviour is `PropertyPathNotificationExtractor` which accepts the request headers and body as parameters and returns a list of file paths that changed.





The default configuration works out of the box with Github, Gitlab or Bitbucket. In addition to the JSON notifications from Github, Gitlab or Bitbucket you can trigger a change notification by POSTing to "/monitor" with a form-encoded body parameters `path={name}`. This will broadcast to applications matching the "{name}" pattern (can contain wildcards).

















<td class="content">the `RefreshRemoteApplicationEvent` will only be transmitted if the `spring-cloud-bus` is activated in the Config Server and in the client application.























<td class="content">the default configuration also detects filesystem changes in local git repositories (the webhook is not used in that case but as soon as you edit a config file a refresh will be broadcast).















## Spring Cloud Config Client





A Spring Boot application can take immediate advantage of the Spring Config Server (or other external property sources provided by the application developer), and it will also pick up some additional useful features related to `Environment` change events.





### Config First Bootstrap



This is the default behaviour for any application which has the Spring Cloud Config Client on the classpath. When a config client starts up it binds to the Config Server (via the bootstrap configuration property `spring.cloud.config.uri`) and initializes Spring `Environment` with remote property sources.





The net result of this is that all client apps that want to consume the Config Server need a `bootstrap.yml` (or an environment variable) with the server address in `spring.cloud.config.uri` (defaults to "http://localhost:8888").







### Discovery First Bootstrap



If you are using a `DiscoveryClient implementation, such as Spring Cloud Netflix and Eureka Service Discovery or Spring Cloud Consul (Spring Cloud Zookeeper does not support this yet), then you can have the Config Server register with the Discovery Service if you want to, but in the default "Config First" mode, clients wonâ€™t be able to take advantage of the registration.





If you prefer to use `DiscoveryClient` to locate the Config Server, you can do that by setting `spring.cloud.config.discovery.enabled=true` (default "false"). The net result of that is that client apps all need a `bootstrap.yml` (or an environment variable) with the appropriate discovery configuration. For example, with Spring Cloud Netflix, you need to define the Eureka server address, e.g. in `eureka.client.serviceUrl.defaultZone`. The price for using this option is an extra network round trip on start up to locate the service registration. The benefit is that the Config Server can change its co-ordinates, as long as the Discovery Service is a fixed point. The default service id is "configserver" but you can change that on the client with `spring.cloud.config.discovery.serviceId` (and on the server in the usual way for a service, e.g. by setting `spring.application.name`).





The discovery client implementations all support some kind of metadata map (e.g. for Eureka we have `eureka.instance.metadataMap`). Some additional properties of the Config Server may need to be configured in its service registration metadata so that clients can connect correctly. If the Config Server is secured with HTTP Basic you can configure the credentials as "username" and "password". And if the Config Server has a context path you can set "configPath". Example, for a Config Server that is a Eureka client:









    eureka:
      instance:
        ...
        metadataMap:
          user: osufhalskjrtl
          password: lviuhlszvaorhvlo5847
          configPath: /config









### Config Client Fail Fast



In some cases, it may be desirable to fail startup of a service if it cannot connect to the Config Server. If this is the desired behavior, set the bootstrap configuration property `spring.cloud.config.failFast=true` and the client will halt with an Exception.







### Config Client Retry



If you expect that the config server may occasionally be unavailable when your app starts, you can ask it to keep trying after a failure. First you need to set `spring.cloud.config.failFast=true`, and then you need to add `spring-retry` and `spring-boot-starter-aop` to your classpath. The default behaviour is to retry 6 times with an initial backoff interval of 1000ms and an exponential multiplier of 1.1 for subsequent backoffs. You can configure these properties (and others) using `spring.cloud.config.retry.*` configuration properties.

















<td class="content">To take full control of the retry add a `@Bean` of type `RetryOperationsInterceptor` with id "configServerRetryInterceptor". Spring Retry has a `RetryInterceptorBuilder` that makes it easy to create one.













### Locating Remote Configuration Resources



The Config Service serves property sources from `/{name}/{profile}/{label}`, where the default bindings in the client app are





*   "name" = `${spring.application.name}`

*   "profile" = `${spring.profiles.active}` (actually `Environment.getActiveProfiles()`)

*   "label" = "master"





All of them can be overridden by setting `spring.cloud.config.*` (where `*` is "name", "profile" or "label"). The "label" is useful for rolling back to previous versions of configuration; with the default Config Server implementation it can be a git label, branch name or commit id. Label can also be provided as a comma-separated list, in which case the items in the list are tried on-by-one until one succeeds. This can be useful when working on a feature branch, for instance, when you might want to align the config label with your branch, but make it optional (e.g. `spring.cloud.config.label=myfeature,develop`).







### Security



If you use HTTP Basic security on the server then clients just need to know the password (and username if it isnâ€™t the default). You can do that via the config server URI, or via separate username and password properties, e.g.









    spring:
      cloud:
        config:
         uri: https://user:secret@myconfig.mycompany.com







or









    spring:
      cloud:
        config:
         uri: https://myconfig.mycompany.com
         username: user
         password: secret







The `spring.cloud.config.password` and `spring.cloud.config.username` values override anything that is provided in the URI.





If you deploy your apps on Cloud Foundry then the best way to provide the password is through service credentials, e.g. in the URI, since then it doesnâ€™t even need to be in a config file. An example which works locally and for a user-provided service on Cloud Foundry named "configserver":









    spring:
      cloud:
        config:
         uri: ${vcap.services.configserver.credentials.uri:http://user:password@localhost:8888}







If you use another form of security you might need to provide a `RestTemplate` to the `ConfigServicePropertySourceLocator` (e.g. by grabbing it in the bootstrap context and injecting one).









# Spring Cloud Netflix









## Service Discovery: Eureka Clients





Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle. Eureka is the Netflix Service Discovery Server and Client. The server can be configured and deployed to be highly available, with each server replicating state about the registered services to the others.





### Registering with Eureka



When a client registers with Eureka, it provides meta-data about itself such as host and port, health indicator URL, home page etc. Eureka receives heartbeat messages from each instance belonging to a service. If the heartbeat fails over a configurable timetable, the instance is normally removed from the registry.





Example eureka client:







    @Configuration
    @ComponentScan
    @EnableAutoConfiguration
    @EnableEurekaClient
    @RestController
    public class Application {

        @RequestMapping("/")
        public String home() {
            return "Hello world";
        }

        public static void main(String[] args) {
            new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

    }







(i.e. utterly normal Spring Boot app). In this example we use `@EnableEurekaClient` explicitly, but with only Eureka available you could also use `@EnableDiscoveryClient`. Configuration is required to locate the Eureka server. Example:









<pre>eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre>







where "defaultZone" is a magic string fallback value that provides the service URL for any client that doesnâ€™t express a preference (i.e. itâ€™s a useful default).





The default application name (service ID), virtual host and non-secure port, taken from the `Environment`, are `${spring.application.name}`, `${spring.application.name}` and `${server.port}` respectively.





`@EnableEurekaClient` makes the app into both a Eureka "instance" (i.e. it registers itself) and a "client" (i.e. it can query the registry to locate other services). The instance behaviour is driven by `eureka.instance.*` configuration keys, but the defaults will be fine if you ensure that your application has a `spring.application.name` (this is the default for the Eureka service ID, or VIP).





See [EurekaInstanceConfigBean](https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java) and [EurekaClientConfigBean](https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java) for more details of the configurable options.







### Authenticating with the Eureka Server



HTTP basic authentication will be automatically added to your eureka client if one of the `eureka.client.serviceUrl.defaultZone` URLs has credentials embedded in it (curl style, like `[http://user:password@localhost:8761/eureka](http://user:password@localhost:8761/eureka)`). For more complex needs you can create a `@Bean` of type `DiscoveryClientOptionalArgs` and inject `ClientFilter` instances into it, all of which will be applied to the calls from the client to the server.

















<td class="content">Because of a limitation in Eureka it isnâ€™t possible to support per-server basic auth credentials, so only the first set that are found will be used.













### Status Page and Health Indicator



The status page and health indicators for a Eureka instance default to "/info" and "/health" respectively, which are the default locations of useful endpoints in a Spring Boot Actuator application. You need to change these, even for an Actuator application if you use a non-default context path or servlet path (e.g. `server.servletPath=/foo`) or management endpoint path (e.g. `management.contextPath=/admin`). Example:









<pre>eureka:
  instance:
    statusPageUrlPath: ${management.context-path}/info
    healthCheckUrlPath: ${management.context-path}/health</pre>







These links show up in the metadata that is consumed by clients, and used in some scenarios to decide whether to send requests to your application, so itâ€™s helpful if they are accurate.







### Registering a Secure Application



If your app wants to be contacted over HTTPS you can set two flags in the `EurekaInstanceConfig`, _viz_ `eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]` respectively. This will make Eureka publish instance information showing an explicit preference for secure communication. The Spring Cloud `DiscoveryClient` will always return an `[https://â€¦â€‹](https://%E2%80%A6%E2%80%8B/);` URI for a service configured this way, and the Eureka (native) instance information will have a secure health check URL.





Because of the way Eureka works internally, it will still publish a non-secure URL for status and home page unless you also override those explicitly. You can use placeholders to configure the eureka instance urls, e.g.









<pre>eureka:
  instance:
    statusPageUrl: https://${eureka.hostname}/info
    healthCheckUrl: https://${eureka.hostname}/health
    homePageUrl: https://${eureka.hostname}/</pre>







(Note that `${eureka.hostname}` is a native placeholder only available in later versions of Eureka. You could achieve the same thing with Spring placeholders as well, e.g. using `${eureka.instance.hostName}`.)

















<td class="content">If your app is running behind a proxy, and the SSL termination is in the proxy (e.g. if you run in Cloud Foundry or other platforms as a service) then you will need to ensure that the proxy "forwarded" headers are intercepted and handled by the application. An embedded Tomcat container in a Spring Boot app does this automatically if it has explicit configuration for the 'X-Forwarded-\*` headers. A sign that you got this wrong will be that the links rendered by your app to itself will be wrong (the wrong host, port or protocol).













### Eurekaâ€™s Health Checks



By default, Eureka uses the client heartbeat to determine if a client is up. Unless specified otherwise the Discovery Client will not propagate the current health check status of the application per the Spring Boot Actuator. Which means that after successful registration Eureka will always announce that the application is in 'UP' state. This behaviour can be altered by enabling Eureka health checks, which results in propagating application status to Eureka. As a consequence every other application wonâ€™t be sending traffic to application in state other then 'UP'.









<pre>eureka:
  client:
    healthcheck:
      enabled: true</pre>







If you require more control over the health checks, you may consider implementing your own `com.netflix.appinfo.HealthCheckHandler`.







### Eureka Metadata for Instances and Clients



Itâ€™s worth spending a bit of time understanding how the Eureka metadata works, so you can use it in a way that makes sense in your platform. There is standard metadata for things like hostname, IP address, port numbers, status page and health check. These are published in the service registry and used by clients to contact the services in a straightforward way. Additional metadata can be added to the instance registration in the `eureka.instance.metadataMap`, and this will be accessible in the remote clients, but in general will not change the behaviour of the client, unless it is made aware of the meaning of the metadata. There are a couple of special cases described below where Spring Cloud already assigns meaning to the metadata map.





#### Using Eureka on Cloudfoundry



Cloudfoundry has a global router so that all instances of the same app have the same hostname (itâ€™s the same in other PaaS solutions with a similar architecture). This isnâ€™t necessarily a barrier to using Eureka, but if you use the router (recommended, or even mandatory depending on the way your platform was set up), you need to explicitly set the hostname and port numbers (secure or non-secure) so that they use the router. You might also want to use instance metadata so you can distinguish between the instances on the client (e.g. in a custom load balancer). By default, the `eureka.instance.instanceId` is `vcap.application.instance_id`. For example:









<pre>eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80</pre>







Depending on the way the security rules are set up in your Cloudfoundry instance, you might be able to register and use the IP address of the host VM for direct service-to-service calls. This feature is not (yet) available on Pivotal Web Services ([PWS](https://run.pivotal.io/)).







#### Using Eureka on AWS



If the application is planned to be deployed to an AWS cloud, then the Eureka instance will have to be configured to be Amazon aware and this can be done by customizing the [EurekaInstanceConfigBean](https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java) the following way:







    @Bean
    @Profile("!default")
    public EurekaInstanceConfigBean eurekaInstanceConfig() {
      EurekaInstanceConfigBean b = new EurekaInstanceConfigBean();
      AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
      b.setDataCenterInfo(info);
      return b;
    }









#### Changing the Eureka Instance ID



A vanilla Netflix Eureka instance is registered with an ID that is equal to its host name (i.e. only one service per host). Spring Cloud Eureka provides a sensible default that looks like this: `${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}`. For example `myhost:myappname:8080`.





Using Spring Cloud you can override this by providing a unique identifier in `eureka.instance.instanceId`. For example:









<pre>eureka:
  instance:
    instanceId: ${spring.application.name}:${spring.application.instance_id:${random.value}}</pre>







With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique. In Cloudfoundry the `spring.application.instance_id` will be populated automatically in a Spring Boot Actuator application, so the random value will not be needed.









### Using the EurekaClient



Once you have an app that is `@EnableDiscoveryClient` (or `@EnableEurekaClient`) you can use it to discover service instances from the [Eureka Server](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-eureka-server). One way to do that is to use the native `com.netflix.discovery.EurekaClient` (as opposed to the Spring Cloud `DiscoveryClient`), e.g.







<pre>@Autowired
private EurekaClient discoveryClient;

public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
}</pre>























Donâ€™t use the `EurekaClient` in `@PostConstruct` method or in a `@Scheduled` method (or anywhere where the `ApplicationContext` might not be started yet). It is initialized in a `SmartLifecycle` (with `phase=0`) so the earliest you can rely on it being available is in another `SmartLifecycle` with higher phase.

















### Alternatives to the native Netflix EurekaClient



You donâ€™t have to use the raw Netflix `EurekaClient` and usually it is more convenient to use it behind a wrapper of some sort. Spring Cloud has support for [Feign](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign) (a REST client builder) and also [Spring `RestTemplate`](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon) using the logical Eureka service identifiers (VIPs) instead of physical URLs. To configure Ribbon with a fixed list of physical servers you can simply set `<client>.ribbon.listOfServers` to a comma-separated list of physical addresses (or hostnames), where `<client>` is the ID of the client.





You can also use the `org.springframework.cloud.client.discovery.DiscoveryClient` which provides a simple API for discovery clients that is not specific to Netflix, e.g.







<pre>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List<ServiceInstance> list = discoveryClient.getInstances("STORES");
    if (list != null && list.size() > 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre>









### Why is it so Slow to Register a Service?



Being an instance also involves a periodic heartbeat to the registry (via the clientâ€™s `serviceUrl`) with default duration 30 seconds. A service is not available for discovery by clients until the instance, the server and the client all have the same metadata in their local cache (so it could take 3 heartbeats). You can change the period using `eureka.instance.leaseRenewalIntervalInSeconds` and this will speed up the process of getting clients connected to other services. In production itâ€™s probably better to stick with the default because there are some computations internally in the server that make assumptions about the lease renewal period.











## Service Discovery: Eureka Server





Example eureka server (e.g. using spring-cloud-starter-eureka-server to set up the classpath):







    @SpringBootApplication
    @EnableEurekaServer
    public class Application {

        public static void main(String[] args) {
            new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

    }







The server has a home page with a UI, and HTTP API endpoints per the normal Eureka functionality under `/eureka/*`.





Eureka background reading: see [flux capacitor](https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer) and [google group discussion](https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0).





















Due to Gradleâ€™s dependency resolution rules and the lack of a parent bom feature, simply depending on spring-cloud-starter-eureka-server can cause failures on application startup. To remedy this the Spring Boot Gradle plugin must be added and the Spring cloud starter parent bom must be imported like so:









    buildscript {
      dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.3.5.RELEASE")
      }
    }

    apply plugin: "spring-boot"

    dependencyManagement {
      imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
      }
    }

















### High Availability, Zones and Regions



The Eureka server does not have a backend store, but the service instances in the registry all have to send heartbeats to keep their registrations up to date (so this can be done in memory). Clients also have an in-memory cache of eureka registrations (so they donâ€™t have to go to the registry for every single request to a service).





By default every Eureka server is also a Eureka client and requires (at least one) service URL to locate a peer. If you donâ€™t provide it the service will run and work, but it will shower your logs with a lot of noise about not being able to register with the peer.





See also [below for details of Ribbon support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon) on the client side for Zones and Regions.







### Standalone Mode



The combination of the two caches (client and server) and the heartbeats make a standalone Eureka server fairly resilient to failure, as long as there is some sort of monitor or elastic runtime keeping it alive (e.g. Cloud Foundry). In standalone mode, you might prefer to switch off the client side behaviour, so it doesnâ€™t keep trying and failing to reach its peers. Example:









<pre>server:
  port: 8761

eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/</pre>







Notice that the `serviceUrl` is pointing to the same host as the local instance.







### Peer Awareness



Eureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behaviour, so all you need to do to make it work is add a valid `serviceUrl` to a peer, e.g.









<pre>---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: http://peer2/eureka/

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/</pre>







In this example we have a YAML file that can be used to run the same server on 2 hosts (peer1 and peer2), by running it in different Spring profiles. You could use this configuration to test the peer awareness on a single host (thereâ€™s not much value in doing that in production) by manipulating `/etc/hosts` to resolve the host names. In fact, the `eureka.instance.hostname` is not needed if you are running on a machine that knows its own hostname (it is looked up using `java.net.InetAddress` by default).





You can add multiple peers to a system, and as long as they are all directly connected to each other, they will synchronize the registrations amongst themselves.









<pre>eureka:
  client:
    serviceUrl:
      defaultZone: http://peer1/eureka/,http://peer2/eureka/,http://peer3/eureka/

---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2

---
spring:
  profiles: peer3
eureka:
  instance:
    hostname: peer3</pre>









### Prefer IP Address



In some cases, it is preferable for Eureka to advertise the IP Adresses of services rather than the hostname. Set `eureka.instance.preferIpAddress` to `true` and when the application registers with eureka, it will use its IP Address rather than its hostname.











## Circuit Breaker: Hystrix Clients





Netflix has created a library called [Hystrix](https://github.com/Netflix/Hystrix) that implements the [circuit breaker pattern](http://martinfowler.com/bliki/CircuitBreaker.html). In a microservice architecture it is common to have multiple layers of service calls.













A service failure in the lower level of services can cause cascading failure all the way up to the user. When calls to a particular service reach a certain threshold (20 failures in 5 seconds is the default in Hystrix), the circuit opens and the call is not made. In cases of error and an open circuit a fallback can be provided by the developer.













Having an open circuit stops cascading failures and allows overwhelmed or failing services time to heal. The fallback can be another Hystrix protected call, static data or a sane empty value. Fallbacks may be chained so the first fallback makes some other business call which in turn falls back to static data.





Example boot app:







<pre>@SpringBootApplication
@EnableCircuitBreaker
public class Application {

    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }

}

@Component
public class StoreIntegration {

    @HystrixCommand(fallbackMethod = "defaultStores")
    public Object getStores(Map<String, Object> parameters) {
        //do stuff that might fail
    }

    public Object defaultStores(Map<String, Object> parameters) {
        return /* something useful */;
    }
}</pre>







The `@HystrixCommand` is provided by a Netflix contrib library called ["javanica"](https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica). Spring Cloud automatically wraps Spring beans with that annotation in a proxy that is connected to the Hystrix circuit breaker. The circuit breaker calculates when to open and close the circuit, and what to do in case of a failure.





To configure the `@HystrixCommand` you can use the `commandProperties` attribute with a list of `@HystrixProperty` annotations. See [here](https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration) for more details. See the [Hystrix wiki](https://github.com/Netflix/Hystrix/wiki/Configuration) for details on the properties available.





### Propagating the Security Context or using Spring Scopes



If you want some thread local context to propagate into a `@HystrixCommand` the default declaration will not work because it executes the command in a thread pool (in case of timeouts). You can switch Hystrix to use the same thread as the caller using some configuration, or directly in the annotation, by asking it to use a different "Isolation Strategy". For example:







    @HystrixCommand(fallbackMethod = "stubMyService",
        commandProperties = {
          @HystrixProperty(name="execution.isolation.strategy", value="SEMAPHORE")
        }
    )
    ...







The same thing applies if you are using `@SessionScope` or `@RequestScope`. You will know when you need to do this because of a runtime exception that says it canâ€™t find the scoped context.







### Health Indicator



The state of the connected circuit breakers are also exposed in the `/health` endpoint of the calling application.







    {
        "hystrix": {
            "openCircuitBreakers": [
                "StoreIntegration::getStoresByLocationLink"
            ],
            "status": "CIRCUIT_OPEN"
        },
        "status": "UP"
    }









### Hystrix Metrics Stream



To enable the Hystrix metrics stream include a dependency on `spring-boot-starter-actuator`. This will expose the `/hystrix.stream` as a management endpoint.







        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>













## Circuit Breaker: Hystrix Dashboard





One of the main benefits of Hystrix is the set of metrics it gathers about each HystrixCommand. The Hystrix Dashboard displays the health of each circuit breaker in an efficient manner.













To run the Hystrix Dashboard annotate your Spring Boot main class with `@EnableHystrixDashboard`. You then visit `/hystrix` and point the dashboard to an individual instances `/hystrix.stream` endpoint in a Hystrix client application.





### Turbine



Looking at an individual instances Hystrix data is not very useful in terms of the overall health of the system. [Turbine](https://github.com/Netflix/Turbine) is an application that aggregates all of the relevant `/hystrix.stream` endpoints into a combined `/turbine.stream` for use in the Hystrix Dashboard. Individual instances are located via Eureka. Running Turbine is as simple as annotating your main class with the `@EnableTurbine` annotation (e.g. using spring-cloud-starter-turbine to set up the classpath). All of the documented configuration properties from [the Turbine 1 wiki](https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)) apply. The only difference is that the `turbine.instanceUrlSuffix` does not need the port prepended as this is handled automatically unless `turbine.instanceInsertPort=false`.





The configuration key `turbine.appConfig` is a list of eureka serviceIds that turbine will use to lookup instances. The turbine stream is then used in the Hystrix dashboard using a url that looks like: `[http://my.turbine.sever:8080/turbine.stream?cluster=<CLUSTERNAME>](http://my.turbine.sever:8080/turbine.stream?cluster=%3CCLUSTERNAME%3E);` (the cluster parameter can be omitted if the name is "default"). The `cluster` parameter must match an entry in `turbine.aggregator.clusterConfig`. Values returned from eureka are uppercase, thus we expect this example to work if there is an app registered with Eureka called "customers":







<pre>turbine:
  aggregator:
    clusterConfig: CUSTOMERS
  appConfig: customers</pre>







The `clusterName` can be customized by a SPEL expression in `turbine.clusterNameExpression` with root an instance of `InstanceInfo`. The default value is `appName`, which means that the Eureka serviceId ends up as the cluster key (i.e. the `InstanceInfo` for customers has an `appName` of "CUSTOMERS"). A different example would be `turbine.clusterNameExpression=aSGName`, which would get the cluster name from the AWS ASG name. Another example:







<pre>turbine:
  aggregator:
    clusterConfig: SYSTEM,USER
  appConfig: customers,stores,ui,admin
  clusterNameExpression: metadata['cluster']</pre>







In this case, the cluster name from 4 services is pulled from their metadata map, and is expected to have values that include "SYSTEM" and "USER".





To use the "default" cluster for all apps you need a string literal expression (with single quotes, and escaped with double quotes if it is in YAML as well):







<pre>turbine:
  appConfig: customers,stores
  clusterNameExpression: "'default'"</pre>







Spring Cloud provides a `spring-cloud-starter-turbine` that has all the dependencies you need to get a Turbine server running. Just create a Spring Boot application and annotate it with `@EnableTurbine`.

















<td class="content">by default the native Netflix behaviour built into Turbine does _not_ allow multiple processes per host, per cluster (the key to the instance id is the hostname). Spring Cloud generalizes this a bit, allowing the host and port to be used as the key, but only if you set the property `turbine.combineHostPort=true`













### Turbine Stream



In some environments (e.g. in a PaaS setting), the classic Turbine model of pulling metrics from all the distributed Hystrix commands doesnâ€™t work. In that case you might want to have your Hystrix commands push metrics to Turbine, and Spring Cloud enables that with messaging. All you need to do on the client is add a dependency to `spring-cloud-netflix-hystrix-stream` and the `spring-cloud-starter-stream-*` of your choice (see Spring Cloud Stream documentation for details on the brokers, and how to configure the client credentials, but it should work out of the box for a local broker).





On the server side Just create a Spring Boot application and annotate it with `@EnableTurbineStream` and by default it will come up on port 8989 (point your Hystrix dashboard to that port, any path). You can customize the port using either `server.port` or `turbine.stream.port`. If you have `spring-boot-starter-web` and `spring-boot-starter-actuator` on the classpath as well, then you can open up the Actuator endpoints on a separate port (with Tomcat by default) by providing a `management.port` which is different.





You can then point the Hystrix Dashboard to the Turbine Stream Server instead of individual Hystrix streams. If Turbine Stream is running on port 8989 on myhost, then put `[http://myhost:8989](http://myhost:8989/)` in the stream input field in the Hystrix Dashboard. Circuits will be prefixed by their respective serviceId, followed by a dot, then the circuit name.





Spring Cloud provides a `spring-cloud-starter-turbine-stream` that has all the dependencies you need to get a Turbine Stream server running - just add the Stream binder of your choice, e.g. `spring-cloud-starter-stream-rabbit`. You need Java 8 to run the app because it is Netty-based.











## Client Side Load Balancer: Ribbon





Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using `@FeignClient` then this section also applies.





A central concept in Ribbon is that of the named client. Each load balancer is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer (e.g. using the `@FeignClient` annotation). Spring Cloud creates a new ensemble as an `ApplicationContext` on demand for each named client using `RibbonClientConfiguration`. This contains (amongst other things) an `ILoadBalancer`, a `RestClient`, and a `ServerListFilter`.





### Customizing the Ribbon Client



You can configure some bits of a Ribbon client using external properties in `<client>.ribbon.*`, which is no different than using the Netflix APIs natively, except that you can use Spring Boot configuration files. The native options can be inspected as static fields in `CommonClientConfigKey` (part of ribbon-core).





Spring Cloud also lets you take full control of the client by declaring additional configuration (on top of the `RibbonClientConfiguration`) using `@RibbonClient`. Example:







    @Configuration
    @RibbonClient(name = "foo", configuration = FooConfiguration.class)
    public class TestConfiguration {
    }







In this case the client is composed from the components already in `RibbonClientConfiguration` together with any in `FooConfiguration` (where the latter generally will override the former).

















<td class="content">The `FooConfiguration` has to be `@Configuration` but take care that it is not in a `@ComponentScan` for the main application context, otherwise it will be shared by all the `@RibbonClients`. If you use `@ComponentScan` (or `@SpringBootApplication`) you need to take steps to avoid it being included (for instance put it in a separate, non-overlapping package, or specify the packages to scan explicitly in the `@ComponentScan`).











Spring Cloud Netflix provides the following beans by default for ribbon (`BeanType` beanName: `ClassName`):





*   `IClientConfig` ribbonClientConfig: `DefaultClientConfigImpl`

*   `IRule` ribbonRule: `ZoneAvoidanceRule`

*   `IPing` ribbonPing: `NoOpPing`

*   `ServerList<Server>` ribbonServerList: `ConfigurationBasedServerList`

*   `ServerListFilter<Server>` ribbonServerListFilter: `ZonePreferenceServerListFilter`

*   `ILoadBalancer` ribbonLoadBalancer: `ZoneAwareLoadBalancer`





Creating a bean of one of those type and placing it in a `@RibbonClient` configuration (such as `FooConfiguration` above) allows you to override each one of the beans described. Example:







    @Configuration
    public class FooConfiguration {
        @Bean
        public IPing ribbonPing(IClientConfig config) {
            return new PingUrl();
        }
    }







This replaces the `NoOpPing` with `PingUrl`.







### Using Ribbon with Eureka



When Eureka is used in conjunction with Ribbon the `ribbonServerList` is overridden with an extension of `DiscoveryEnabledNIWSServerList` which populates the list of servers from Eureka. It also replaces the `IPing` interface with `NIWSDiscoveryPing` which delegates to Eureka to determine if a server is up. The `ServerList` that is installed by default is a `DomainExtractingServerList` and the purpose of this is to make physical metadata available to the load balancer without using AWS AMI metadata (which is what Netflix relies on). By default the server list will be constructed with "zone" information as provided in the instance metadata (so on the remote clients set `eureka.instance.metadataMap.zone`), and if that is missing it can use the domain name from the server hostname as a proxy for zone (if the flag `approximateZoneFromHostname` is set). Once the zone information is available it can be used in a `ServerListFilter`. By default it will be used to locate a server in the same zone as the client because the default is a `ZonePreferenceServerListFilter`. The zone of the client is determined the same way as the remote instances by default, i.e. via `eureka.instance.metadataMap.zone`.

















<td class="content">The orthodox "archaius" way to set the client zone is via a configuration property called "@zone", and Spring Cloud will use that in preference to all other settings if it is available (note that the key will have to be quoted in YAML configuration).























<td class="content">If there is no other source of zone data then a guess is made based on the client configuration (as opposed to the instance configuration). We take `eureka.client.availabilityZones`, which is a map from region name to a list of zones, and pull out the first zone for the instanceâ€™s own region (i.e. the `eureka.client.region`, which defaults to "us-east-1" for comatibility with native Netflix).













### Example: How to Use Ribbon Without Eureka



Eureka is a convenient way to abstract the discovery of remote servers so you donâ€™t have to hard code their URLs in clients, but if you prefer not to use it, Ribbon and Feign are still quite amenable. Suppose you have declared a `@RibbonClient` for "stores", and Eureka is not in use (and not even on the classpath). The Ribbon client defaults to a configured server list, and you can supply the configuration like this









<pre>stores:
  ribbon:
    listOfServers: example.com,google.com</pre>









### Example: Disable Eureka use in Ribbon



Setting the property `ribbon.eureka.enabled = false` will explicitly disable the use of Eureka in Ribbon.









<pre>ribbon:
  eureka:
   enabled: false</pre>









### Using the Ribbon API Directly



You can also use the `LoadBalancerClient` directly. Example:







    public class MyClass {
        @Autowired
        private LoadBalancerClient loadBalancer;

        public void doStuff() {
            ServiceInstance instance = loadBalancer.choose("stores");
            URI storesUri = URI.create(String.format("http://%s:%s", instance.getHost(), instance.getPort()));
            // ... do something with the URI
        }
    }













## Declarative REST Client: Feign





[Feign](https://github.com/Netflix/feign) is a declarative web service client. It makes writing web service clients easier. To use Feign create an interface and annotate it. It has pluggable annotation support including Feign annotations and JAX-RS annotations. Feign also supports pluggable encoders and decoders. Spring Cloud adds support for Spring MVC annotations and for using the same `HttpMessageConverters` used by default in Spring Web. Spring Cloud integrates Ribbon and Eureka to provide a load balanced http client when using Feign.





Example spring boot app







    @Configuration
    @ComponentScan
    @EnableAutoConfiguration
    @EnableEurekaClient
    @EnableFeignClients
    public class Application {

        public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
        }

    }











    @FeignClient("stores")
    public interface StoreClient {
        @RequestMapping(method = RequestMethod.GET, value = "/stores")
        List<Store> getStores();

        @RequestMapping(method = RequestMethod.POST, value = "/stores/{storeId}", consumes = "application/json")
        Store update(@PathVariable("storeId") Long storeId, Store store);
    }







In the `@FeignClient` annotation the String value ("stores" above) is an arbitrary client name, which is used to create a Ribbon load balancer (see [below for details of Ribbon support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon)). You can also specify a URL using the `url` attribute (absolute value or just a hostname). The name of the bean in the application context is the fully qualified name of the interface. An alias is also created which is the 'name' attribute plus 'FeignClient'. For the example above, `@Qualifier("storesFeignClient")` could be used to reference the bean.





The Ribbon client above will want to discover the physical addresses for the "stores" service. If your application is a Eureka client then it will resolve the service in the Eureka service registry. If you donâ€™t want to use Eureka, you can simply configure a list of servers in your external configuration (see [above for example](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon-without-eureka)).





### Overriding Feign Defaults



A central concept in Spring Cloudâ€™s Feign support is that of the named client. Each feign client is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer using the `@FeignClient` annotation. Spring Cloud creates a new ensemble as an `ApplicationContext` on demand for each named client using `FeignClientsConfiguration`. This contains (amongst other things) an `feign.Decoder`, a `feign.Encoder`, and a `feign.Contract`.





Spring Cloud lets you take full control of the feign client by declaring additional configuration (on top of the `FeignClientsConfiguration`) using `@FeignClient`. Example:







    @FeignClient(name = "stores", configuration = FooConfiguration.class)
    public interface StoreClient {
        //..
    }







In this case the client is composed from the components already in `FeignClientsConfiguration` together with any in `FooConfiguration` (where the latter will override the former).

















<td class="content">The `FooConfiguration` has to be `@Configuration` but take care that it is not in a `@ComponentScan` for the main application context, otherwise it will be used for every `@FeignClient`. If you use `@ComponentScan` (or `@SpringBootApplication`) you need to take steps to avoid it being included (for instance put it in a separate, non-overlapping package, or specify the packages to scan explicitly in the `@ComponentScan`).























<td class="content">The `serviceId` attribute is now deprecated in favor of the `name` attribute.























<td class="content">Previously, using the `url` attribute, did not require the `name` attribute. Using `name` is now required.











Placeholders are supported in the `name` and `url` attributes.







    @FeignClient(name = "${feign.name}", url = "${feign.url}")
    public interface StoreClient {
        //..
    }







Spring Cloud Netflix provides the following beans by default for feign (`BeanType` beanName: `ClassName`):





*   `Decoder` feignDecoder: `ResponseEntityDecoder` (which wraps a `SpringDecoder`)

*   `Encoder` feignEncoder: `SpringEncoder`

*   `Logger` feignLogger: `Slf4jLogger`

*   `Contract` feignContract: `SpringMvcContract`

*   `Feign.Builder` feignBuilder: `HystrixFeign.Builder`





Spring Cloud Netflix _does not_ provide the following beans by default for feign, but still looks up beans of these types from the application context to create the feign client:





*   `Logger.Level`

*   `Retryer`

*   `ErrorDecoder`

*   `Request.Options`

*   `Collection<RequestInterceptor>`





Creating a bean of one of those type and placing it in a `@FeignClient` configuration (such as `FooConfiguration` above) allows you to override each one of the beans described. Example:







    @Configuration
    public class FooConfiguration {
        @Bean
        public Contract feignContract() {
            return new feign.Contract.Default();
        }

        @Bean
        public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
            return new BasicAuthRequestInterceptor("user", "password");
        }
    }







This replaces the `SpringMvcContract` with `feign.Contract.Default` and adds a `RequestInterceptor` to the collection of `RequestInterceptor`.





Default configurations can be specified in the `@EnableFeignClients` attribute `defaultConfiguration` in a similar manner as described above. The difference is that this configuration will apply to _all_ feign clients.







### Feign Hystrix Support



If Hystrix is on the classpath, by default Feign will wrap all methods with a circuit breaker. Returning a `com.netflix.hystrix.HystrixCommand` is also available. This lets you use reactive patterns (with a call to `.toObservable()` or `.observe()` or asynchronous use (with a call to `.queue()`).





To disable Hystrix support for Feign, set `feign.hystrix.enabled=false`.





To disable Hystrix support on a per-client basis create a vanilla `Feign.Builder` with the "prototype" scope, e.g.:







    @Configuration
    public class FooConfiguration {
        @Bean
    	@Scope("prototype")
    	public Feign.Builder feignBuilder() {
    		return Feign.builder();
    	}
    }









### Feign Hystrix Fallbacks



Hystrix supports the notion of a fallback: a default code path that is executed when they circuit is open or there is an error. To enable fallbacks for a given `@FeignClient` set the `fallback` attribute to the class name that implements the fallback.







    @FeignClient(name = "hello", fallback = HystrixClientFallback.class)
    protected interface HystrixClient {
        @RequestMapping(method = RequestMethod.GET, value = "/hello")
        Hello iFailSometimes();
    }

    static class HystrixClientFallback implements HystrixClient {
        @Override
        public Hello iFailSometimes() {
            return new Hello("fallback");
        }
    }



















<td class="content">There is a limitation with the implementation of fallbacks in Feign and how Hystrix fallbacks work. Fallbacks are currently not supported for methods that return `com.netflix.hystrix.HystrixCommand` and `rx.Observable`.













### Feign Inheritance Support



Feign supports boilerplate apis via single-inheritance interfaces. This allows grouping common operations into convenient base interfaces.









    public interface UserService {

        @RequestMapping(method = RequestMethod.GET, value ="/users/{id}")
        User getUser(@PathVariable("id") long id);
    }











    @RestController
    public class UserResource implements UserService {

    }











    package project.user;

    @FeignClient("users")
    public interface UserClient extends UserService {

    }



















<td class="content">It is generally not advisable to share an interface between a server and a client. It introduces tight coupling, and also actually doesnâ€™t work with Spring MVC in its current form (method parameter mapping is not inherited).













### Feign request/response compression



You may consider enabling the request or response GZIP compression for your Feign requests. You can do this by enabling one of the properties:







    feign.compression.request.enabled=true
    feign.compression.response.enabled=true







Feign request compression gives you settings similar to what you may set for your web server:







    feign.compression.request.enabled=true
    feign.compression.request.mime-types=text/xml,application/xml,application/json
    feign.compression.request.min-request-size=2048







These properties allow you to be selective about the compressed media types and minimum request threshold length.







### Feign logging



A logger is created for each Feign client created. By default the name of the logger is the full class name of the interface used to create the Feign client. Feign logging only responds to the `DEBUG` level.









    logging.level.project.user.UserClient: DEBUG







The `Logger.Level` object that you may configure per client, tells Feign how much to log. Choices are:





*   `NONE`, No logging (**DEFAULT**).

*   `BASIC`, Log only the request method and URL and the response status code and execution time.

*   `HEADERS`, Log the basic information along with request and response headers.

*   `FULL`, Log the headers, body, and metadata for both requests and responses.





For example, the following would set the `Logger.Level` to `FULL`:







    @Configuration
    public class FooConfiguration {
        @Bean
        Logger.Level feignLoggerLevel() {
            return Logger.Level.FULL;
        }
    }













## External Configuration: Archaius





[Archaius](https://github.com/Netflix/archaius) is the Netflix client side configuration library. It is the library used by all of the Netflix OSS components for configuration. Archaius is an extension of the [Apache Commons Configuration](https://commons.apache.org/proper/commons-configuration) project. It allows updates to configuration by either polling a source for changes or for a source to push changes to the client. Archaius uses Dynamic<Type>Property classes as handles to properties.









    class ArchaiusTest {
        DynamicStringProperty myprop = DynamicPropertyFactory
                .getInstance()
                .getStringProperty("my.prop");

        void doSomething() {
            OtherClass.someMethod(myprop.get());
        }
    }







Archaius has its own set of configuration files and loading priorities. Spring applications should generally not use Archaius directly, but the need to configure the Netflix tools natively remains. Spring Cloud has a Spring Environment Bridge so Archaius can read properties from the Spring Environment. This allows Spring Boot projects to use the normal configuration toolchain, while allowing them to configure the Netflix tools, for the most part, as documented.









## Router and Filter: Zuul





Routing in an integral part of a microservice architecture. For example, `/` may be mapped to your web application, `/api/users` is mapped to the user service and `/api/shop` is mapped to the shop service. [Zuul](https://github.com/Netflix/zuul) is a JVM based router and server side load balancer by Netflix.





[Netflix uses Zuul](http://www.slideshare.net/MikeyCohen1/edge-architecture-ieee-international-conference-on-cloud-engineering-32240146/27) for the following:





*   Authentication

*   Insights

*   Stress Testing

*   Canary Testing

*   Dynamic Routing

*   Service Migration

*   Load Shedding

*   Security

*   Static Response handling

*   Active/Active traffic management





Zuulâ€™s rule engine allows rules and filters to be written in essentially any JVM language, with built in support for Java and Groovy.

















<td class="content">The configuration property `zuul.max.host.connections` has been replaced by two new properties, `zuul.host.maxTotalConnections` and `zuul.host.maxPerRouteConnections` which default to 200 and 20 respectively.











### Embedded Zuul Reverse Proxy



Spring Cloud has created an embedded Zuul proxy to ease the development of a very common use case where a UI application wants to proxy calls to one or more back end services. This feature is useful for a user interface to proxy to the backend services it requires, avoiding the need to manage CORS and authentication concerns independently for all the backends.





To enable it, annotate a Spring Boot main class with `@EnableZuulProxy`, and this forwards local calls to the appropriate service. By convention, a service with the ID "users", will receive requests from the proxy located at `/users` (with the prefix stripped). The proxy uses Ribbon to locate an instance to forward to via discovery, and all requests are executed in a hystrix command, so failures will show up in Hystrix metrics, and once the circuit is open the proxy will not try to contact the service.

















<td class="content">the Zuul starter does not include a discovery client, so for routes based on service IDs you need to provide one of those on the classpath as well (e.g. Eureka is one choice).











To skip having a service automatically added, set `zuul.ignored-services` to a list of service id patterns. If a service matches a pattern that is ignored, but also included in the explicitly configured routes map, then it will be unignored. Example:









     zuul:
      ignoredServices: '*'
      routes:
        users: /myusers/**







In this example, all services are ignored **except** "users".





To augment or change the proxy routes, you can add external configuration like the following:









     zuul:
      routes:
        users: /myusers/**







This means that http calls to "/myusers" get forwarded to the "users" service (for example "/myusers/101" is forwarded to "/101").





To get more fine-grained control over a route you can specify the path and the serviceId independently:









     zuul:
      routes:
        users:
          path: /myusers/**
          serviceId: users_service







This means that http calls to "/myusers" get forwarded to the "users_service" service. The route has to have a "path" which can be specified as an ant-style pattern, so "/myusers/*" only matches one level, but "/myusers/**" matches hierarchically.





The location of the backend can be specified as either a "serviceId" (for a service from discovery) or a "url" (for a physical location), e.g.









     zuul:
      routes:
        users:
          path: /myusers/**
          url: http://example.com/users_service







These simple url-routes donâ€™t get executed as a `HystrixCommand` nor can you loadbalance multiple URLs with Ribbon. To achieve this, specify a service-route and configure a Ribbon client for the serviceId (this currently requires disabling Eureka support in Ribbon: see [above for more information](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-ribbon-without-eureka)), e.g.









    zuul:
      routes:
        users:
          path: /myusers/**
          serviceId: users

    ribbon:
      eureka:
        enabled: false

    users:
      ribbon:
        listOfServers: example.com,google.com







You can provide convention between serviceId and routes using regexmapper. It uses regular expression named groups to extract variables from serviceId and inject them into a route pattern.









    @Bean
    public PatternServiceRouteMapper serviceRouteMapper() {
        return new PatternServiceRouteMapper(
            "(?<name>^.+)-(?<version>v.+$)",
            "${version}/${name}");
    }







This means that a serviceId "myusers-v1" will be mapped to route "/v1/myusers/**". Any regular expression is accepted but all named groups must be present in both servicePattern and routePattern. If servicePattern does not match a serviceId, the default behavior is used. In the example above, a serviceId "myusers" will be mapped to route "/myusers/**" (no version detected) This feature is disable by default and only applies to discovered services.





To add a prefix to all mappings, set `zuul.prefix` to a value, such as `/api`. The proxy prefix is stripped from the request before the request is forwarded by default (switch this behaviour off with `zuul.stripPrefix=false`). You can also switch off the stripping of the service-specific prefix from individual routes, e.g.









     zuul:
      routes:
        users:
          path: /myusers/**
          stripPrefix: false







In this example, requests to "/myusers/101" will be forwarded to "/myusers/101" on the "users" service.





The `zuul.routes` entries actually bind to an object of type `ZuulProperties`. If you look at the properties of that object you will see that it also has a "retryable" flag. Set that flag to "true" to have the Ribbon client automatically retry failed requests (and if you need to you can modify the parameters of the retry operations using the Ribbon client configuration).





The `X-Forwarded-Host` header is added to the forwarded requests by default. To turn it off set `zuul.addProxyHeaders = false`. The prefix path is stripped by default, and the request to the backend picks up a header "X-Forwarded-Prefix" ("/myusers" in the examples above).





An application with `@EnableZuulProxy` could act as a standalone server if you set a default route ("/"), for example `zuul.route.home: /` would route all traffic (i.e. "/**") to the "home" service.





If more fine-grained ignoring is needed, you can specify specific patterns to ignore. These patterns are evaluated at the start of the route location process, which means prefixes should be included in the pattern to warrant a match. Ignored patterns span all services and supersede any other route specification.









     zuul:
      ignoredPatterns: /**/admin/**
      routes:
        users: /myusers/**







This means that all calls such as "/myusers/101" will be forwarded to "/101" on the "users" service. But calls including "/admin/" will not resolve.







### Cookies and Sensitive Headers



Itâ€™s OK to share headers between services in the same system, but you probably donâ€™t want sensitive headers leaking downstream into external servers. You can specify a list of ignored headers as part of the route configuration. Cookies play a special role because they have well-defined semantics in browsers, and they are always to be treated as sensitive. If the consumer of your proxy is a browser, then cookies for downstream services also cause problems for the user because they all get jumbled up (all downstream services look like they come from the same place).





If you are careful with the design of your services, for example if only one of the downstream services sets cookies, then you might be able to let them flow from the backend all the way up to the caller. Also, if your proxy sets cookies and all your back end services are part of the same system, it can be natural to simply share them (and for instance use Spring Session to link them up to some shared state). Other than that, any cookies that get set by downstream services are likely to be not very useful to the caller, so it is recommended that you make (at least) "Set-Cookie" and "Cookie" into sensitive headers for routes that are not part of your domain. Even for routes that **are** part of your domain, try to think carefully about what it means before allowing cookies to flow between them and the proxy.





The sensitive headers can be configured as a comma-separated list per route, e.g.









     zuul:
      routes:
        users:
          path: /myusers/**
          sensitiveHeaders: Cookie,Set-Cookie,Authorization
          url: https://downstream







Sensitive headers can also be set globally by setting `zuul.sensitiveHeaders`. If `sensitiveHeaders` is set on a route, this will override the global `sensitiveHeaders` setting.

















<td class="content">this is the default value for `sensitiveHeaders`, so you donâ€™t need to set it unless you want it to be different. N.B. this is new in Spring Cloud Netflix 1.1 (in 1.0 the user had no control over headers and all cookies flow in both directions).











In addition to the per-route sensitive headers, you can set a global value for `zuul.ignoredHeaders` for values that should be discarded (both request and response) during interactions with downstream services. By default these are empty, if Spring Security is not on the classpath, and otherwise they are initialized to a set of well-known "security" headers (e.g. involving caching) as specified by Spring Security. The assumption in this case is that the downstream services might add these headers too, and we want the values from the proxy.







### The Routes Endpoint



If you are using `@EnableZuulProxy` with tha Spring Boot Actuator you will enable (by default) an additional endpoint, available via HTTP as `/routes`. A GET to this endpoint will return a list of the mapped routes. A POST will force a refresh of the existing routes (e.g. in case there have been changes in the service catalog).

















<td class="content">the routes should respond automatically to changes in the service catalog, but the POST to /routes is a way to force the change to happen immediately.













### Strangulation Patterns and Local Forwards



A common pattern when migrating an existing application or API is to "strangle" old endpoints, slowly replacing them with different implementations. The Zuul proxy is a useful tool for this because you can use it to handle all traffic from clients of the old endpoints, but redirect some of the requests to new ones.





Example configuration:









     zuul:
      routes:
        first:
          path: /first/**
          url: http://first.example.com
        second:
          path: /second/**
          url: forward:/second
        third:
          path: /third/**
          url: forward:/3rd
        legacy:
          path: /**
          url: http://legacy.example.com







In this example we are strangling the "legacy" app which is mapped to all requests that do not match one of the other patterns. Paths in `/first/**` have been extracted into a new service with an external URL. And paths in `/second/**` are forwared so they can be handled locally, e.g. with a normal Spring `@RequestMapping`. Paths in `/third/**` are also forwarded, but with a different prefix (i.e. `/third/foo` is forwarded to `/3rd/foo`).

















<td class="content">The ignored patterns arenâ€™t completely ignored, they just arenâ€™t handled by the proxy (so they are also effectively forwarded locally).













### Uploading Files through Zuul



If you `@EnableZuulProxy` you can use the proxy paths to upload files and it should just work as long as the files are small. For large files there is an alternative path which bypasses the Spring `DispatcherServlet` (to avoid multipart processing) in "/zuul/*". I.e. if `zuul.routes.customers=/customers/**` then you can POST large files to "/zuul/customers/*". The servlet path is externalized via `zuul.servletPath`. Extremely large files will also require elevated timeout settings if the proxy route takes you through a Ribbon load balancer, e.g.









    hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 60000
    ribbon:
      ConnectTimeout: 3000
      ReadTimeout: 60000







Note that for streaming to work with large files, you need to use chunked encoding in the request (which some browsers do not do by default). E.g. on the command line:







<pre>$ curl -v -H "Transfer-Encoding: chunked" \
    -F "file=@mylarge.iso" localhost:9999/zuul/simple/file</pre>









### Plain Embedded Zuul



You can also run a Zuul server without the proxying, or switch on parts of the proxying platform selectively, if you use `@EnableZuulServer` (instead of `@EnableZuulProxy`). Any beans that you add to the application of type `ZuulFilter` will be installed automatically, as they are with `@EnableZuulProxy`, but without any of the proxy filters being added automatically.





In this case the routes into the Zuul server are still specified by configuring "zuul.routes.*", but there is no service discovery and no proxying, so the "serviceId" and "url" settings are ignored. For example:









     zuul:
      routes:
        api: /api/**







maps all paths in "/api/**" to the Zuul filter chain.







### Disable Zuul Filters



Zuul for Spring Cloud comes with a number of `ZuulFilter` beans enabled by default in both proxy and server mode. See [the zuul filters package](https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters) for the possible filters that are enabled. If you want to disable one, simply set `zuul.<SimpleClassName>.<filterType>.disable=true`. By convention, the package after `filters` is the Zuul filter type. For example to disable `org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter` set `zuul.SendResponseFilter.post.disable=true`.







### Polyglot support with Sidecar



Do you have non-jvm languages you want to take advantage of Eureka, Ribbon and Config Server? The Spring Cloud Netflix Sidecar was inspired by [Netflix Prana](https://github.com/Netflix/Prana). It includes a simple http api to get all of the instances (ie host and port) for a given service. You can also proxy service calls through an embedded Zuul proxy which gets its route entries from Eureka. The Spring Cloud Config Server can be accessed directly via host lookup or through the Zuul Proxy. The non-jvm app should implement a health check so the Sidecar can report to eureka if the app is up or down.





To enable the Sidecar, create a Spring Boot application with `@EnableSidecar`. This annotation includes `@EnableCircuitBreaker`, `@EnableDiscoveryClient`, and `@EnableZuulProxy`. Run the resulting application on the same host as the non-jvm application.





To configure the side car add `sidecar.port` and `sidecar.health-uri` to `application.yml`. The `sidecar.port` property is the port the non-jvm app is listening on. This is so the Sidecar can properly register the app with Eureka. The `sidecar.health-uri` is a uri accessible on the non-jvm app that mimicks a Spring Boot health indicator. It should return a json document like the following:









    {
      "status":"UP"
    }







Here is an example application.yml for a Sidecar application:









    server:
      port: 5678
    spring:
      application:
        name: sidecar

    sidecar:
      port: 8000
      health-uri: http://localhost:8000/health.json







The api for the `DiscoveryClient.getInstances()` method is `/hosts/{serviceId}`. Here is an example response for `/hosts/customers` that returns two instances on different hosts. This api is accessible to the non-jvm app (if the sidecar is on port 5678) at `[http://localhost:5678/hosts/{serviceId}](http://localhost:5678/hosts/%7BserviceId%7D)`.









    [
        {
            "host": "myhost",
            "port": 9000,
            "uri": "http://myhost:9000",
            "serviceId": "CUSTOMERS",
            "secure": false
        },
        {
            "host": "myhost2",
            "port": 9000,
            "uri": "http://myhost2:9000",
            "serviceId": "CUSTOMERS",
            "secure": false
        }
    ]







The Zuul proxy automatically adds routes for each service known in eureka to `/<serviceId>`, so the customers service is available at `/customers`. The Non-jvm app can access the customer service via `[http://localhost:5678/customers](http://localhost:5678/customers)` (assuming the sidecar is listening on port 5678).





If the Config Server is registered with Eureka, non-jvm application can access it via the Zuul proxy. If the serviceId of the ConfigServer is `configserver` and the Sidecar is on port 5678, then it can be accessed at [http://localhost:5678/configserver](http://localhost:5678/configserver)





Non-jvm app can take advantage of the Config Serverâ€™s ability to return YAML documents. For example, a call to [http://sidecar.local.spring.io:5678/configserver/default-master.yml](http://sidecar.local.spring.io:5678/configserver/default-master.yml) might result in a YAML document like the following







    eureka:
      client:
        serviceUrl:
          defaultZone: http://localhost:8761/eureka/
      password: password
    info:
      description: Spring Cloud Samples
      url: https://github.com/spring-cloud-samples













## RxJava with Spring MVC





Spring Cloud Netflix includes the [RxJava](https://github.com/ReactiveX/RxJava).





> <div class="paragraph">
>
> RxJava is a Java VM implementation of [Reactive Extensions](http://reactivex.io/): a library for composing asynchronous and event-based programs by using observable sequences.
>
>





Spring Cloud Netflix provides support for returning `rx.Single` objects from Spring MVC Controllers. It also supports using `rx.Observable` objects for [Server-sent events (SSE)](https://en.wikipedia.org/wiki/Server-sent_events). This can be very convenient if your internal APIs are already built using RxJava (see [Feign Hystrix Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-feign-hystrix) for examples).





Here are some examples of using `rx.Single`:







    @RequestMapping(method = RequestMethod.GET, value = "/single")
    public Single<String> single() {
        return Single.just("single value");
    }

    @RequestMapping(method = RequestMethod.GET, value = "/singleWithResponse")
    public ResponseEntity<Single<String>> singleWithResponse() {
        return new ResponseEntity<>(Single.just("single value"),
                HttpStatus.NOT_FOUND);
    }

    @RequestMapping(method = RequestMethod.GET, value = "/singleCreatedWithResponse")
    public Single<ResponseEntity<String>> singleOuterWithResponse() {
        return Single.just(new ResponseEntity<>("single value", HttpStatus.CREATED));
    }

    @RequestMapping(method = RequestMethod.GET, value = "/throw")
    public Single<Object> error() {
        return Single.error(new RuntimeException("Unexpected"));
    }







If you have an `Observable`, rather than a single, you can use `.toSingle()` or `.toList().toSingle()`. Here are some examples:







    @RequestMapping(method = RequestMethod.GET, value = "/single")
    public Single<String> single() {
        return Observable.just("single value").toSingle();
    }

    @RequestMapping(method = RequestMethod.GET, value = "/multiple")
    public Single<List<String>> multiple() {
        return Observable.just("multiple", "values").toList().toSingle();
    }

    @RequestMapping(method = RequestMethod.GET, value = "/responseWithObservable")
    public ResponseEntity<Single<String>> responseWithObservable() {

        Observable<String> observable = Observable.just("single value");
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(APPLICATION_JSON_UTF8);
        return new ResponseEntity<>(observable.toSingle(), headers, HttpStatus.CREATED);
    }

    @RequestMapping(method = RequestMethod.GET, value = "/timeout")
    public Observable<String> timeout() {
        return Observable.timer(1, TimeUnit.MINUTES).map(new Func1<Long, String>() {
            @Override
            public String call(Long aLong) {
                return "single value";
            }
        });
    }







If you have a streaming endpoint and client, SSE could be an option. To convert `rx.Observable` to a Spring `SseEmitter` use `RxResponse.sse()`. Here are some examples:







    @RequestMapping(method = RequestMethod.GET, value = "/sse")
    public SseEmitter single() {
        return RxResponse.sse(Observable.just("single value"));
    }

    @RequestMapping(method = RequestMethod.GET, value = "/messages")
    public SseEmitter messages() {
        return RxResponse.sse(Observable.just("message 1", "message 2", "message 3"));
    }

    @RequestMapping(method = RequestMethod.GET, value = "/events")
    public SseEmitter event() {
        return RxResponse.sse(APPLICATION_JSON_UTF8, Observable.just(
                new EventDto("Spring io", getDate(2016, 5, 19)),
                new EventDto("SpringOnePlatform", getDate(2016, 8, 1))
        ));
    }











## Metrics: Spectator, Servo, and Atlas





When used together, Spectator/Servo and Atlas provide a near real-time operational insight platform.





Spectator and Servo are Netflixâ€™s metrics collection libraries. Atlas is a Netflix metrics backend to manage dimensional time series data.





Servo served Netflix for several years and is still usable, but is gradually being phased out in favor of Spectator, which is only designed to work with Java 8\. Spring Cloud Netflix provides support for both, but Java 8 based applications are encouraged to use Spectator.





### Dimensional vs. Hierarchical Metrics



Spring Boot Actuator metrics are hierarchical and metrics are separated only by name. These names often follow a naming convention that embeds key/value attribute pairs (dimensions) into the name separated by periods. Consider the following metrics for two endpoints, root and star-star:







    {
        "counter.status.200.root": 20,
        "counter.status.400.root": 3,
        "counter.status.200.star-star": 5,
    }







The first metric gives us a normalized count of successful requests against the root endpoint per unit of time. But what if the system had 20 endpoints and you want to get a count of successful requests against all the endpoints? Some hierarchical metrics backends would allow you to specify a wild card such as `counter.status.200.` **that would read all 20 metrics and aggregate the results. Alternatively, you could provide a `HandlerInterceptorAdapter` that intercepts and records a metric like `counter.status.200.all` for all successful requests irrespective of the endpoint, but now you must write 20+1 different metrics. Similarly if you want to know the total number of successful requests for all endpoints in the service, you could specify a wild card such as `counter.status.2`**`.*`.





Even in the presence of wildcarding support on a hierarchical metrics backend, naming consistency can be difficult. Specifically the position of these tags in the name string can slip with time, breaking queries. For example, suppose we add an additional dimension to the hierarchical metrics above for HTTP method. Then `counter.status.200.root` becomes `counter.status.200.method.get.root`, etc. Our `counter.status.200.*` suddenly no longer has the same semantic meaning. Furthermore, if the new dimension is not applied uniformly across the codebase, certain queries may become impossible. This can quickly get out of hand.





Netflix metrics are tagged (a.k.a. dimensional). Each metric has a name, but this single named metric can contain multiple statistics and 'tag' key/value pairs that allows more querying flexibility. In fact, the statistics themselves are recorded in a special tag.





Recorded with Netflix Servo or Spectator, a timer for the root endpoint described above contains 4 statistics per status code, where the count statistic is identical to Spring Boot Actuatorâ€™s counter. In the event that we have encountered an HTTP 200 and 400 thus far, there will be 8 available data points:







    {
        "root(status=200,stastic=count)": 20,
        "root(status=200,stastic=max)": 0.7265630630000001,
        "root(status=200,stastic=totalOfSquares)": 0.04759702862580789,
        "root(status=200,stastic=totalTime)": 0.2093076914666667,
        "root(status=400,stastic=count)": 1,
        "root(status=400,stastic=max)": 0,
        "root(status=400,stastic=totalOfSquares)": 0,
        "root(status=400,stastic=totalTime)": 0,
    }









### Default Metrics Collection



Without any additional dependencies or configuration, a Spring Cloud based service will autoconfigure a Servo `MonitorRegistry` and begin collecting metrics on every Spring MVC request. By default, a Servo timer with the name `rest` will be recorded for each MVC request which is tagged with:





1.  HTTP method

2.  HTTP status (e.g. 200, 400, 500)

3.  URI (or "root" if the URI is empty), sanitized for Atlas

4.  The exception class name, if the request handler threw an exception

5.  The caller, if a request header with a key matching `netflix.metrics.rest.callerHeader` is set on the request. There is no default key for `netflix.metrics.rest.callerHeader`. You must add it to your application properties if you wish to collect caller information.





Set the `netflix.metrics.rest.metricName` property to change the name of the metric from `rest` to a name you provide.





If Spring AOP is enabled and `org.aspectj:aspectjweaver` is present on your runtime classpath, Spring Cloud will also collect metrics on every client call made with `RestTemplate`. A Servo timer with the name of `restclient` will be recorded for each MVC request which is tagged with:





1.  HTTP method

2.  HTTP status (e.g. 200, 400, 500), "CLIENT_ERROR" if the response returned null, or "IO_ERROR" if an `IOException` occurred during the execution of the `RestTemplate` method

3.  URI, sanitized for Atlas

4.  Client name







### Metrics Collection: Spectator



To enable Spectator metrics, include a dependency on `spring-boot-starter-spectator`:







        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-spectator</artifactId>
        </dependency>







In Spectator parlance, a meter is a named, typed, and tagged configuration and a metric represents the value of a given meter at a point in time. Spectator meters are created and controlled by a registry, which currently has several different implementations. Spectator provides 4 meter types: counter, timer, gauge, and distribution summary.





Spring Cloud Spectator integration configures an injectable `com.netflix.spectator.api.Registry` instance for you. Specifically, it configures a `ServoRegistry` instance in order to unify the collection of REST metrics and the exporting of metrics to the Atlas backend under a single Servo API. Practically, this means that your code may use a mixture of Servo monitors and Spectator meters and both will be scooped up by Spring Boot Actuator `MetricReader` instances and both will be shipped to the Atlas backend.





#### Spectator Counter



A counter is used to measure the rate at which some event is occurring.







    // create a counter with a name and a set of tags
    Counter counter = registry.counter("counterName", "tagKey1", "tagValue1", ...);
    counter.increment(); // increment when an event occurs
    counter.increment(10); // increment by a discrete amount







The counter records a single time-normalized statistic.







#### Spectator Timer



A timer is used to measure how long some event is taking. Spring Cloud automatically records timers for Spring MVC requests and conditionally `RestTemplate` requests, which can later be used to create dashboards for request related metrics like latency:







image::RequestLatency.png []







    // create a timer with a name and a set of tags
    Timer timer = registry.timer("timerName", "tagKey1", "tagValue1", ...);

    // execute an operation and time it at the same time
    T result = timer.record(() -> fooReturnsT());

    // alternatively, if you must manually record the time
    Long start = System.nanoTime();
    T result = fooReturnsT();
    timer.record(System.nanoTime() - start, TimeUnit.NANOSECONDS);







The timer simultaneously records 4 statistics: count, max, totalOfSquares, and totalTime. The count statistic will always match the single normalized value provided by a counter if you had called `increment()` once on the counter for each time you recorded a timing, so it is rarely necessary to count and time separately for a single operation.





For [long running operations](https://github.com/Netflix/spectator/wiki/Timer-Usage#longtasktimer), Spectator provides a special `LongTaskTimer`.







#### Spectator Gauge



Gauges are used to determine some current value like the size of a queue or number of threads in a running state. Since gauges are sampled, they provide no information about how these values fluctuate between samples.





The normal use of a gauge involves registering the gauge once in initialization with an id, a reference to the object to be sampled, and a function to get or compute a numeric value based on the object. The reference to the object is passed in separately and the Spectator registry will keep a weak reference to the object. If the object is garbage collected, then Spectator will automatically drop the registration. See [the note](https://github.com/Netflix/spectator/wiki/Gauge-Usage#using-lambda) in Spectatorâ€™s documentation about potential memory leaks if this API is misused.







    // the registry will automatically sample this gauge periodically
    registry.gauge("gaugeName", pool, Pool::numberOfRunningThreads);

    // manually sample a value in code at periodic intervals -- last resort!
    registry.gauge("gaugeName", Arrays.asList("tagKey1", "tagValue1", ...), 1000);









#### Spectator Distribution Summaries



A distribution summary is used to track the distribution of events. It is similar to a timer, but more general in that the size does not have to be a period of time. For example, a distribution summary could be used to measure the payload sizes of requests hitting a server.







    // the registry will automatically sample this gauge periodically
    DistributionSummary ds = registry.distributionSummary("dsName", "tagKey1", "tagValue1", ...);
    ds.record(request.sizeInBytes());











### Metrics Collection: Servo















<td class="content">If your code is compiled on Java 8, please use Spectator instead of Servo as Spectator is destined to replace Servo entirely in the long term.











In Servo parlance, a monitor is a named, typed, and tagged configuration and a metric represents the value of a given monitor at a point in time. Servo monitors are logically equivalent to Spectator meters. Servo monitors are created and controlled by a `MonitorRegistry`. In spite of the above warning, Servo does have a [wider array](https://github.com/Netflix/servo/wiki/Getting-Started) of monitor options than Spectator has meters.





Spring Cloud integration configures an injectable `com.netflix.servo.MonitorRegistry` instance for you. Once you have created the appropriate `Monitor` type in Servo, the process of recording data is wholly similar to Spectator.





#### Creating Servo Monitors



If you are using the Servo `MonitorRegistry` instance provided by Spring Cloud (specifically, an instance of `DefaultMonitorRegistry`), Servo provides convenience classes for retrieving [counters](https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamiccounter) and [timers](https://github.com/Netflix/spectator/wiki/Servo-Comparison#dynamictimer). These convenience classes ensure that only one `Monitor` is registered for each unique combination of name and tags.





To manually create a Monitor type in Servo, especially for the more exotic monitor types for which convenience methods are not provided, instantiate the appropriate type by providing a `MonitorConfig` instance:







    MonitorConfig config = MonitorConfig.builder("timerName").withTag("tagKey1", "tagValue1").build();

    // somewhere we should cache this Monitor by MonitorConfig
    Timer timer = new BasicTimer(config);
    monitorRegistry.register(timer);











### Metrics Backend: Atlas



Atlas was developed by Netflix to manage dimensional time series data for near real-time operational insight. Atlas features in-memory data storage, allowing it to gather and report very large numbers of metrics, very quickly.





Atlas captures operational intelligence. Whereas business intelligence is data gathered for analyzing trends over time, operational intelligence provides a picture of what is currently happening within a system.





Spring Cloud provides a `spring-cloud-starter-atlas` that has all the dependencies you need. Then just annotate your Spring Boot application with `@EnableAtlas` and provide a location for your running Atlas server with the `netflix.atlas.uri` property.





#### Global tags



Spring Cloud enables you to add tags to every metric sent to the Atlas backend. Global tags can be used to separate metrics by application name, environment, region, etc.





Each bean implementing `AtlasTagProvider` will contribute to the global tag list:







    @Bean
    AtlasTagProvider atlasCommonTags(
        @Value("${spring.application.name}") String appName) {
      return () -> Collections.singletonMap("app", appName);
    }









#### Using Atlas



To bootstrap a in-memory standalone Atlas instance:







    $ curl -LO https://github.com/Netflix/atlas/releases/download/v1.4.2/atlas-1.4.2-standalone.jar
    $ java -jar atlas-1.4.2-standalone.jar



















<td class="content">An Atlas standalone node running on an r3.2xlarge (61GB RAM) can handle roughly 2 million metrics per minute for a given 6 hour window.











Once running and you have collected a handful of metrics, verify that your setup is correct by listing tags on the Atlas server:







    $ curl http://ATLAS/api/v1/tags



















<td class="content">After executing several requests against your service, you can gather some very basic information on the request latency of every request by pasting the following url in your browser: `[http://ATLAS/api/v1/graph?q=name,rest,:eq,:avg](http://atlas/api/v1/graph?q=name,rest,:eq,:avg)`











The Atlas wiki contains a [compilation of sample queries](https://github.com/Netflix/atlas/wiki/Single-Line) for various scenarios.





Make sure to check out the [alerting philosophy](https://github.com/Netflix/atlas/wiki/Alerting-Philosophy) and docs on using [double exponential smoothing](https://github.com/Netflix/atlas/wiki/DES) to generate dynamic alert thresholds.











# Spring Cloud Stream







This section goes into more detail about how you can work with Spring Cloud Stream. It covers topics such as creating and running stream applications.









## Introducing Spring Cloud Stream





Spring Cloud Stream is a framework for building message-driven microservice applications. Spring Cloud Stream builds upon Spring Boot to create standalone, production-grade Spring applications, and uses Spring Integration to provide connectivity to message brokers. It provides opinionated configuration of middleware from several vendors, introducing the concepts of persistent publish-subscribe semantics, consumer groups, and partitions.





You can add the `@EnableBinding` annotation to your application to get immediate connectivity to a message broker, and you can add `@StreamListener` to a method to cause it to receive events for stream processing. The following is a simple sink application which receives external messages.







    @SpringBootApplication
    public class StreamApplication {

      public static void main(String[] args) {
        SpringApplication.run(StreamApplication.class, args);
      }
    }

    @EnableBinding(Sink.class)
    public class TimerSource {

      ...

      @StreamListener(Sink.INPUT)
      public void processVote(Vote vote) {
          votingService.recordVote(vote);
      }
    }







The `@EnableBinding` annotation takes one or more interfaces as parameters (in this case, the parameter is a single `Sink` interface). An interface declares input and/or output channels. Spring Cloud Stream provides the interfaces `Source`, `Sink`, and `Processor`; you can also define your own interfaces.





The following is the definition of the `Source` interface:







    public interface Sink {
      String INPUT = "input";

      @Input(Sink.INPUT)
      SubscribableChannel input();
    }







The `@Input` annotation identifies an _input channel_, through which received messages enter the application; the `@Output` annotation identifies an _output channel_, through which published messages leave the application. The `@Input` and `@Output` annotations can take a channel name as a parameter; if a name is not provided, the name of the annotated method will be used.





Spring Cloud Stream will create an implementation of the interface for you. You can use this in the application by autowiring it, as in the following example of a test case.







    @RunWith(SpringJUnit4ClassRunner.class)
    @SpringApplicationConfiguration(classes = StreamApplication.class)
    @WebAppConfiguration
    @DirtiesContext
    public class StreamApplicationTests {

      @Autowired
      private Sink sink;

      @Test
      public void contextLoads() {
        assertNotNull(this.sink.input());
      }
    }











## Main Concepts





Spring Cloud Stream provides a number of abstractions and primitives that simplify the writing of message-driven microservice applications. This section gives an overview of the following:





*   Spring Cloud Streamâ€™s application model

*   The Binder abstraction

*   Persistent publish-subscribe support

*   Consumer group support

*   Partitioning support

*   A pluggable Binder API





### Application Model



A Spring Cloud Stream application consists of a middleware-neutral core. The application communicates with the outside world through input and output _channels_ injected into it by Spring Cloud Stream. Channels are connected to external brokers through middleware-specific Binder implementations.













#### Fat JAR



Spring Cloud Stream applications can be run in standalone mode from your IDE for testing. To run a Spring Cloud Stream application in production, you can create an executable (or "fat") JAR by using the standard Spring Boot tooling provided for Maven or Gradle.









### The Binder Abstraction



Spring Cloud Stream provides Binder implementations for [Kafka](https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-kafka), [Rabbit MQ](https://github.com/spring-cloud/spring-cloud-stream/tree/master/spring-cloud-stream-binders/spring-cloud-stream-binder-rabbit), [Redis](https://github.com/spring-cloud/spring-cloud-stream-binder-redis), and [Gemfire](https://github.com/spring-cloud/spring-cloud-stream-binder-gemfire). Spring Cloud Stream also includes a [TestSupportBinder](https://github.com/spring-cloud/spring-cloud-stream/blob/master/spring-cloud-stream-test-support/src/main/java/org/springframework/cloud/stream/test/binder/TestSupportBinder.java), which leaves a channel unmodified so that tests can interact with channels directly and reliably assert on what is received. You can use the extensible API to write your own Binder.





Spring Cloud Stream uses Spring Boot for configuration, and the Binder abstraction makes it possible for a Spring Cloud Stream application to be flexible in how it connects to middleware. For example, deployers can dynamically choose, at runtime, the destinations (e.g., the Kafka topics or RabbitMQ exchanges) to which channels connect. Such configuration can be provided through external configuration properties and in any form supported by Spring Boot (including application arguments, environment variables, and `application.yml` or `application.properties` files). In the sink example from the [Introducing Spring Cloud Stream](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_introducing_spring_cloud_stream) section, setting the application property `spring.cloud.stream.bindings.input.destination` to `raw-sensor-data` will cause it to read from the `raw-sensor-data` Kafka topic, or from a queue bound to the `raw-sensor-data` RabbitMQ exchange.





Spring Cloud Stream automatically detects and uses a binder found on the classpath. You can easily use different types of middleware with the same code: just include a different binder at build time. For more complex use cases, you can also package multiple binders with your application and have it choose the binder, and even whether to use different binders for different channels, at runtime.







### Persistent Publish-Subscribe Support



Communication between applications follows a publish-subscribe model, where data is broadcast through shared topics. This can be seen in the following figure, which shows a typical deployment for a set of interacting Spring Cloud Stream applications.













Data reported by sensors to an HTTP endpoint is sent to a common destination named `raw-sensor-data`. From the destination, it is independently processed by a microservice application that computes time-windowed averages and by another microservice application that ingests the raw data into HDFS. In order to process the data, both applications declare the topic as their input at runtime.





The publish-subscribe communication model reduces the complexity of both the producer and the consumer, and allows new applications to be added to the topology without disruption of the existing flow. For example, downstream from the average-calculating application, you can add an application that calculates the highest temperature values for display and monitoring. You can then add another application that interprets the same flow of averages for fault detection. Doing all communication through shared topics rather than point-to-point queues reduces coupling between microservices.





While the concept of publish-subscribe messaging is not new, Spring Cloud Stream takes the extra step of making it an opinionated choice for its application model. By using native middleware support, Spring Cloud Stream also simplifies use of the publish-subscribe model across different platforms.







### Consumer Groups



While the publish-subscribe model makes it easy to connect applications through shared topics, the ability to scale up by creating multiple instances of a given application is equally important. When doing this, different instances of an application are placed in a competing consumer relationship, where only one of the instances is expected to handle a given message.





Spring Cloud Stream models this behavior through the concept of a _consumer group_. (Spring Cloud Stream consumer groups are similar to and inspired by Kafka consumer groups.) Each consumer binding can use the `spring.cloud.stream.bindings.input.group` property to specify a group name. For the consumers shown in the following figure, this property would be set as `spring.cloud.stream.bindings.input.group=hdfsWrite` or `spring.cloud.stream.bindings.input.group=average`.













All groups which subscribe to a given destination receive a copy of published data, but only one member of each group receives a given message from that destination. By default, when a group is not specified, Spring Cloud Stream assigns the application to an anonymous and independent single-member consumer group that is in a publish-subscribe relationship with all other consumer groups.





#### Durability



Consistent with the opinionated application model of Spring Cloud Stream, consumer group subscriptions are _durable_. That is, a binder implementation ensures that group subscriptions are persistent, and once at least one subscription for a group has been created, the group will receive messages, even if they are sent while all applications in the group are stopped.





















Anonymous subscriptions are non-durable by nature. For some binder implementations (e.g., RabbitMQ), it is possible to have non-durable group subscriptions.















In general, it is preferable to always specify a consumer group when binding an application to a given destination. When scaling up a Spring Cloud Stream application, you must specify a consumer group for each of its input bindings. This prevents the applicationâ€™s instances from receiving duplicate messages (unless that behavior is desired, which is unusual).









### Partitioning Support



Spring Cloud Stream provides support for _partitioning_ data between multiple instances of a given application. In a partitioned scenario, the physical communication medium (e.g., the broker topic) is viewed as being structured into multiple partitions. One or more producer application instances send data to multiple consumer application instances and ensure that data identified by common characteristics are processed by the same consumer instance.





Spring Cloud Stream provides a common abstraction for implementing partitioned processing use cases in a uniform fashion. Partitioning can thus be used whether the broker itself is naturally partitioned (e.g., Kafka) or not (e.g., RabbitMQ).













Partitioning is a critical concept in stateful processing, where it is critiical, for either performance or consistency reasons, to ensure that all related data is processed together. For example, in the time-windowed average calculation example, it is important that all measurements from any given sensor are processed by the same application instance.





















To set up a partitioned processing scenario, you must configure both the data-producing and the data-consuming ends.





















## Programming Model





This section describes Spring Cloud Streamâ€™s programming model. Spring Cloud Stream provides a number of predefined annotations for declaring bound input and output channels as well as how to listen to channels.





### Declaring and Binding Channels



#### Triggering Binding Via `@EnableBinding`



You can turn a Spring application into a Spring Cloud Stream application by applying the `@EnableBinding` annotation to one of the applicationâ€™s configuration classes. The `@EnableBinding` annotation itself is meta-annotated with `@Configuration` and triggers the configuration of Spring Cloud Stream infrastructure:







    ...
    @Import(...)
    @Configuration
    @EnableIntegration
    public @interface EnableBinding {
        ...
        Class<?>[] value() default {};
    }







The `@EnableBinding` annotation can take as parameters one or more interface classes that contain methods which represent bindable components (typically message channels).





















In Spring Cloud Stream 1.0, the only supported bindable components are the Spring Messaging `MessageChannel` and its extensions `SubscribableChannel` and `PollableChannel`. Future versions should extend this support to other types of components, using the same mechanism. In this documentation, we will continue to refer to channels.

















#### `@Input` and `@Output`



A Spring Cloud Stream application can have an arbitrary number of input and output channels defined in an interface as `@Input` and `@Output` methods:







    public interface Barista {

        @Input
        SubscribableChannel orders();

        @Output
        MessageChannel hotDrinks();

        @Output
        MessageChannel coldDrinks();
    }







Using this interface as a parameter to `@EnableBinding` will trigger the creation of three bound channels named `orders`, `hotDrinks`, and `coldDrinks`, respectively.







    @EnableBinding(Barista.class)
    public class CafeConfiguration {

       ...
    }







##### Customizing Channel Names



Using the `@Input` and `@Output` annotations, you can specify a customized channel name for the channel, as shown in the following example:







    public interface Barista {
        ...
        @Input("inboundOrders")
        SubscribableChannel orders();
    }







In this example, the created bound channel will be named `inboundOrders`.







##### `Source`, `Sink`, and `Processor`



For easy addressing of the most common use cases, which involve either an input channel, an output channel, or both, Spring Cloud Stream provides three predefined interfaces out of the box.





`Source` can be used for an application which has a single outbound channel.







    public interface Source {

      String OUTPUT = "output";

      @Output(Source.OUTPUT)
      MessageChannel output();

    }







`Sink` can be used for an application which has a single inbound channel.







    public interface Sink {

      String INPUT = "input";

      @Input(Sink.INPUT)
      SubscribableChannel input();

    }







`Processor` can be used for an application which has both an inbound channel and an outbound channel.







    public interface Processor extends Source, Sink {
    }







Spring Cloud Stream provides no special handling for any of these interfaces; they are only provided out of the box.









#### Accessing Bound Channels



##### Injecting the Bound Interfaces



For each bound interface, Spring Cloud Stream will generate a bean that implements the interface. Invoking a `@Input`-annotated or `@Output`-annotated method of one of these beans will return the relevant bound channel.





The bean in the following example sends a message on the output channel when its `hello` method is invoked. It invokes `output()` on the injected `Source` bean to retrieve the target channel.







    @Component
    public class SendingBean {

        private Source source;

        @Autowired
        public SendingBean(Source source) {
            this.source = source;
        }

        public void sayHello(String name) {
             source.output().send(MessageBuilder.withPayload(body).build());
        }
    }









##### Injecting Channels Directly



Bound channels can be also injected directly:







    @Component
    public class SendingBean {

        private MessageChannel output;

        @Autowired
        public SendingBean(MessageChannel output) {
            this.output = output;
        }

        public void sayHello(String name) {
             output.send(MessageBuilder.withPayload(body).build());
        }
    }







If the name of the channel is customized on the declaring annotation, that name should be used instead of the method name. Given the following declaration:







    public interface CustomSource {
        ...
        @Output("customOutput")
        MessageChannel output();
    }







The channel will be injected as shown in the following example:







    @Component
    public class SendingBean {

        @Autowired
        private MessageChannel output;

        @Autowired @Qualifier("customOutput")
        public SendingBean(MessageChannel output) {
            this.output = output;
        }

        public void sayHello(String name) {
             customOutput.send(MessageBuilder.withPayload(body).build());
        }
    }











#### Producing and Consuming Messages



You can write a Spring Cloud Stream application using either Spring Integration annotations or Spring Cloud Streamâ€™s `@StreamListener` annotation. The `@StreamListener` annotation is modeled after other Spring Messaging annotations (such as `@MessageMapping`, `@JmsListener`, `@RabbitListener`, etc.) but adds content type management and type coercion features.





##### Native Spring Integration Support



Because Spring Cloud Stream is based on Spring Integration, Stream completely inherits Integrationâ€™s foundation and infrastructure as well as the component itself. For example, you can attach the output channel of a `Source` to a `MessageSource`:







    @EnableBinding(Source.class)
    public class TimerSource {

      @Value("${format}")
      private String format;

      @Bean
      @InboundChannelAdapter(value = Source.OUTPUT, poller = @Poller(fixedDelay = "${fixedDelay}", maxMessagesPerPoll = "1"))
      public MessageSource<String> timerMessageSource() {
        return () -> new GenericMessage<>(new SimpleDateFormat(format).format(new Date()));
      }
    }







Or you can use a processorâ€™s channels in a transformer:







    @EnableBinding(Processor.class)
    public class TransformProcessor {
      @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
      public Object transform(String message) {
        return message.toUpper();
      }
    }









##### Using @StreamListener for Automatic Content Type Handling



Complementary to its Spring Integration support, Spring Cloud Stream provides its own `@StreamListener` annotation, modeled after other Spring Messaging annotations (e.g. `@MessageMapping`, `@JmsListener`, `@RabbitListener`, etc.). The `@StreamListener` annotation provides a simpler model for handling inbound messages, especially when dealing with use cases that involve content type management and type coercion.





Spring Cloud Stream provides an extensible `MessageConverter` mechanism for handling data conversion by bound channels and for, in this case, dispatching to methods annotated with `@StreamListener`. The following is an example of an application which processes external `Vote` events:







    @EnableBinding(Sink.class)
    public class VoteHandler {

      @Autowired
      VotingService votingService;

      @StreamListener(Sink.INPUT)
      public void handle(Vote vote) {
        votingService.record(vote);
      }
    }







The distinction between `@StreamListener` and a Spring Integration `@ServiceActivator` is seen when considering an inbound `Message` that has a `String` payload and a `contentType` header of `application/json`. In the case of `@StreamListener`, the `MessageConverter` mechanism will use the `contentType` header to parse the `String` payload into a `Vote` object.





As with other Spring Messaging methods, method arguments can be annotated with `@Payload`, `@Headers` and `@Header`.





















For methods which return data, you must use the `@SendTo` annotation to specify the output binding destination for data returned by the method:







    @EnableBinding(Processor.class)
    public class TransformProcessor {

      @Autowired
      VotingService votingService;

      @StreamListener(Processor.INPUT)
      @SendTo(Processor.OUTPUT)
      public VoteResult handle(Vote vote) {
        return votingService.record(vote);
      }
    }

































In the case of RabbitMQ, content type headers can be set by external applications. Spring Cloud Stream supports them as part of an extended internal protocol used for any type of transport (including transports, such as Kafka, that do not normally support headers).



















#### Aggregation



Spring Cloud Stream provides support for aggregating multiple applications together, connecting their input and output channels directly and avoiding the additional cost of exchanging messages via a broker. As of version 1.0 of Spring Cloud Stream, aggregation is supported only for the following types of applications:





*   _sources_ - applications with a single output channel named `output`, typically having a single binding of the type `org.springframework.cloud.stream.messaging.Source`

*   _sinks_ - applications with a single input channel named `input`, typically having a single binding of the type `org.springframework.cloud.stream.messaging.Sink`

*   _processors_ - applications with a single input channel named `input` and a single output channel named `output`, typically having a single binding of the type `org.springframework.cloud.stream.messaging.Processor`.





They can be aggregated together by creating a sequence of interconnected applications, in which the output channel of an element in the sequence is connected to the input channel of the next element, if it exists. A sequence can start with either a _source_ or a _processor_, it can contain an arbitrary number of _processors_ and must end with either a _processor_ or a _sink_.





Depending on the nature of the starting and ending element, the sequence may have one or more bindable channels, as follows:





*   if the sequence starts with a source and ends with a sink, all communication between the applications is direct and no channels will be bound

*   if the sequence starts with a processor, then its input channel will become the `input` channel of the aggregate and will be bound accordingly

*   if the sequence ends with a processor, then its output channel will become the `output` channel of the aggregate and will be bound accordingly





Aggregation is performed using the `AggregateApplicationBuilder` utility class, as in the following example. Letâ€™s consider a project in which we have source, processor and a sink, which may be defined in the project, or may be contained in one of the projectâ€™s dependencies.







    @SpringBootApplication
    @EnableBinding(Sink.class)
    public class SinkApplication {

    	private static Logger logger = LoggerFactory.getLogger(SinkModuleDefinition.class);

    	@ServiceActivator(inputChannel=Sink.INPUT)
    	public void loggerSink(Object payload) {
    		logger.info("Received: " + payload);
    	}
    }









    @SpringBootApplication
    @EnableBinding(Processor.class)
    public class ProcessorApplication {

    	@Transformer
    	public String loggerSink(String payload) {
    		return payload.toUpperCase();
    	}
    }









    @SpringBootApplication
    @EnableBinding(Source.class)
    public class SourceApplication {

    	@Bean
    	@InboundChannelAdapter(value = Source.OUTPUT)
    	public String timerMessageSource() {
    		return new SimpleDateFormat().format(new Date());
    	}
    }







Each configuration can be used for running a separate component, but in this case they can be aggregated together as follows:







    @SpringBootApplication
    public class SampleAggregateApplication {

    	public static void main(String[] args) {
    		new AggregateApplicationBuilder()
    			.from(SourceApplication.class).args("--fixedDelay=5000")
    			.via(ProcessorApplication.class)
    			.to(SinkApplication.class).args("--debug=true").run(args);
    	}
    }







The starting component of the sequence is provided as argument to the `from()` method. The ending component of the sequence is provided as argument to the `to()` method. Intermediate processors are provided as argument to the `via()` method. Multiple processors of the same type can be chained together (e.g. for pipelining transformations with different configurations). For each component, the builder can provide runtime arguments for Spring Boot configuration.







#### RxJava support



Spring Cloud Stream provides support for RxJava-based processors through the `RxJavaProcessor` available in `spring-cloud-stream-rxjava`.







    public interface RxJavaProcessor<I, O> {
    	Observable<O> process(Observable<I> input);
    }







An implementation of `RxJavaProcessor` will receive `Observable` as an input that represents the flow of inbound message payloads. The `process` method is invoked once at startup for setting up the data flow.





You can enable the use of RxJava-based processors and use them in your processor application by using the `@EnableRxJavaProcessor` annotation. `@EnableRxJavaProcessor` is meta-annotated with `@EnableBinding(Processor.class)` and will create the `Processor` binding. Here is an example of an RxJava-based processor:







    @EnableRxJavaProcessor
    public class RxJavaTransformer {

    	private static Logger logger = LoggerFactory.getLogger(RxJavaTransformer.class);

    	@Bean
    	public RxJavaProcessor<String,String> processor() {
    		return inputStream -> inputStream.map(data -> {
    			logger.info("Got data = " + data);
    			return data;
    		})
    		.buffer(5)
    		.map(data -> String.valueOf(avg(data)));
    	}

    	private static Double avg(List<String> data) {
    		double sum = 0;
    		double count = 0;
    		for(String d : data) {
    			count++;
    			sum += Double.valueOf(d);
    		}
    		return sum/count;
    	}
    }























When implementing an RxJava processor, it is important to handle exceptions as part of your processing flow. Uncaught exceptions will be treated as errors by RxJava and will cause the `Observable` to complete, disrupting the flow.























## Binders





Spring Cloud Stream provides a Binder abstraction for use in connecting to physical destinations at the external middleware. This section provides information about the main concepts behind the Binder SPI, its main components, and implementation-specific details.





### Producers and Consumers











A _producer_ is any component that sends messages to a channel. The channel can be bound to an external message broker via a Binder implementation for that broker. When invoking the `bindProducer()` method, the first parameter is the name of the destination within the broker, the second parameter is the local channel instance to which the producer will send messages, and the third parameter contains properties (such as a partition key expression) to be used within the adapter that is created for that channel.





A _consumer_ is any component that receives messages from a channel. As with a producer, the consumerâ€™s channel can be bound to an external message broker. When invoking the `bindConsumer()` method, the first parameter is the destination name, and a second parameter provides the name of a logical group of consumers. Each group that is represented by consumer bindings for a given destination receives a copy of each message that a producer sends to that destination (i.e., publish-subscribe semantics). If there are multiple consumer instances bound using the same group name, then messages will be load-balanced across those consumer instances so that each message sent by a producer is consumed by only a single consumer instance within each group (i.e., queueing semantics).







### Binder SPI



The Binder SPI consists of a number of interfaces, out-of-the box utility classes and discovery strategies that provide a pluggable mechanism for connecting to external middleware.





The key point of the SPI is the `Binder` interface which is a strategy for connecting inputs and outputs to external middleware.







    public interface Binder<T, C extends ConsumerProperties, P extends ProducerProperties> {
    	Binding<T> bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);

    	Binding<T> bindProducer(String name, T outboundBindTarget, P producerProperties);
    }







The interface is parameterized, offering a number of extension points:





*   input and output bind targets - as of version 1.0, only `MessageChannel` is supported, but this is intended to be used as an extension point in the future;

*   extended consumer and producer properties - allowing specific Binder implementations to add supplemental properties which can be supported in a type-safe manner.





A typical binder implementation consists of the following





*   a class that implements the `Binder` interface;

*   a Spring `@Configuration` class that creates a bean of the type above along with the middleware connection infrastructure;

*   a `META-INF/spring.binders` file found on the classpath containing one or more binder definitions, e.g.







    kafka:\
    org.springframework.cloud.stream.binder.kafka.config.KafkaBinderConfiguration









### Binder Detection



Spring Cloud Stream relies on implementations of the Binder SPI to perform the task of connecting channels to message brokers. Each Binder implementation typically connects to one type of messaging system. Out of the box, Spring Cloud Stream provides binders for Kafka, RabbitMQ, and Redis.





#### Classpath Detection



By default, Spring Cloud Stream relies on Spring Bootâ€™s auto-configuration to configure the binding process. If a single Binder implementation is found on the classpath, Spring Cloud Stream will use it automatically. For example, a Spring Cloud Stream project that aims to bind only to RabbitMQ can simply add the following dependency:







    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
    </dependency>











### Multiple Binders on the Classpath



When multiple binders are present on the classpath, the application must indicate which binder is to be used for each channel binding. Each binder configuration contains a `META-INF/spring.binders`, which is a simple properties file:







    rabbit:\
    org.springframework.cloud.stream.binder.rabbit.config.RabbitServiceAutoConfiguration







Similar files exist for the other provided binder implementations (e.g., Kafka), and custom binder implementations are expected to provide them, as well. The key represents an identifying name for the binder implementation, whereas the value is a comma-separated list of configuration classes that each contain one and only one bean definition of type `org.springframework.cloud.stream.binder.Binder`.





Binder selection can either be performed globally, using the `spring.cloud.stream.defaultBinder` property (e.g., `spring.cloud.stream.defaultBinder=rabbit`) or individually, by configuring the binder on each channel binding. For instance, a processor application which reads from Kafka and writes to RabbitMQ can specify the following configuration:







<pre>spring.cloud.stream.bindings.input.binder=kafka
spring.cloud.stream.bindings.output.binder=rabbit</pre>









### Connecting to Multiple Systems



By default, binders share the applicationâ€™s Spring Boot auto-configuration, so that one instance of each binder found on the classpath will be created. If your application should connect to more than one broker of the same type, you can specify multiple binder configurations, each with different environment settings.





















Turning on explicit binder configuration will disable the default binder configuration process altogether. If you do this, all binders in use must be included in the configuration. Frameworks that intend to use Spring Cloud Stream transparently may create binder configurations that can be referenced by name, but will not affect the default binder configuration. In order to do so, a binder configuration may have its `defaultCandidate` flag set to false, e.g. `spring.cloud.stream.binders.<configurationName>.defaultCandidate=false`. This denotes a configuration that will exist independently of the default binder configuration process.















For example, this is the typical configuration for a processor application which connects to two RabbitMQ broker instances:







    spring:
      cloud:
        stream:
          bindings:
            input:
              destination: foo
              binder: rabbit1
            output:
              destination: bar
              binder: rabbit2
          binders:
            rabbit1:
              type: rabbit
              environment:
                spring:
                  rabbitmq:
                    host: <host1>
            rabbit2:
              type: rabbit
              environment:
                spring:
                  rabbitmq:
                    host: <host2>









### Binder configuration properties



The following properties are available when creating custom binder configurations. They must be prefixed with `spring.cloud.stream.binders.<configurationName>`.





<dl>

<dt class="hdlist1">type</dt>

<dd>

The binder type. It typically references one of the binders found on the classpath, in particular a key in a `META-INF/spring.binders` file.



By default, it has the same value as the configuration name.



</dd>

<dt class="hdlist1">inheritEnvironment</dt>

<dd>

Whether the configuration will inherit the environment of the application itself.



Default `true`.



</dd>

<dt class="hdlist1">environment</dt>

<dd>

Root for a set of properties that can be used to customize the environment of the binder. When this is configured, the context in which the binder is being created is not a child of the application context. This allows for complete separation between the binder components and the application components.



Default `empty`.



</dd>

<dt class="hdlist1">defaultCandidate</dt>

<dd>

Whether the binder configuration is a candidate for being considered a default binder, or can be used only when explicitly referenced. This allows adding binder configurations without interfering with the default processing.



Default `true`.



</dd>

</dl>







### Implementation strategies



This section details the binder implementation strategies for Kafka and Rabbit MQ, in what concerns mapping the Spring Cloud Stream concepts onto the middleware concepts.





#### Kafka Binder











The Kafka Binder implementation maps the destination to a Kafka topic. The consumer group maps directly to the same Kafka concept. Spring Cloud Stream does not use the high-level consumer, but implements a similar concept for the simple consumer.







#### RabbitMQ Binder











The RabbitMQ Binder implementation maps the destination to a `TopicExchange`. For each consumer group, a `Queue` will be bound to that `TopicExchange`. Each consumer instance that binds will trigger creation of a corresponding RabbitMQ `Consumer` instance for its groupâ€™s `Queue`.













## Configuration Options





Spring Cloud Stream supports general configuration options as well as configuration for bindings and binders. Some binders allow additional binding properties to support middleware-specific features.





Configuration options can be provided to Spring Cloud Stream applications via any mechanism supported by Spring Boot. This includes application arguments, environment variables, and YAML or .properties files.





### Spring Cloud Stream Properties



<dl>

<dt class="hdlist1">spring.cloud.stream.instanceCount</dt>

<dd>

The number of deployed instances of an application. Must be set for partitioning and if using Kafka.



Default: `1`.



</dd>

<dt class="hdlist1">spring.cloud.stream.instanceIndex</dt>

<dd>

The instance index of the application: a number from `0` to `instanceCount`-1. Used for partitioning and with Kafka. Automatically set in Cloud Foundry to match the applicationâ€™s instance index.

</dd>

<dt class="hdlist1">spring.cloud.stream.dynamicDestinations</dt>

<dd>

A list of destinations that can be bound dynamically (for example, in a dynamic routing scenario). If set, only listed destinations can be bound.



Default: empty (allowing any destination to be bound).



</dd>

<dt class="hdlist1">spring.cloud.stream.defaultBinder</dt>

<dd>

The default binder to use, if multiple binders are configured. See [Multiple Binders on the Classpath](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#multiple-binders).



Default: empty.



</dd>

<dt class="hdlist1">spring.cloud.stream.overrideCloudConnectors</dt>

<dd>

This property is only applicable when the `cloud` profile is active and Spring Cloud Connectors are provided with the application. If the property is false (the default), the binder will detect a suitable bound service (e.g. a RabbitMQ service bound in Cloud Foundry for the RabbitMQ binder) and will use it for creating connections (usually via Spring Cloud Connectors). When set to true, this property instructs binders to completely ignore the bound services and rely on Spring Boot properties (e.g. relying on the `spring.rabbitmq.*` properties provided in the environment for the RabbitMQ binder). The typical usage of this property is to be nested in a customized environment [when connecting to multiple systems](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#multiple-systems).



Default: false.



</dd>

</dl>







### Binding Properties



Binding properties are supplied using the format `spring.cloud.stream.bindings.<channelName>.<property>=<value>`. The `<channelName>` represents the name of the channel being configured (e.g., `output` for a `Source`).





In what follows, we indicate where we have omitted the `spring.cloud.stream.bindings.<channelName>.` prefix and focus just on the property name, with the understanding that the prefix will be included at runtime.





#### Properties for Use of Spring Cloud Stream



The following binding properties are available for both input and output bindings and must be prefixed with `spring.cloud.stream.bindings.<channelName>.`.





<dl>

<dt class="hdlist1">destination</dt>

<dd>

The target destination of a channel on the bound middleware (e.g., the RabbitMQ exchange or Kafka topic). If the channel is bound as a consumer, it could be bound to multiple destinations and the destination names can be specified as comma separated String values. If not set, the channel name is used instead.

</dd>

<dt class="hdlist1">group</dt>

<dd>

The consumer group of the channel. Applies only to inbound bindings. See [Consumer Groups](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#consumer-groups).



Default: null (indicating an anonymous consumer).



</dd>

<dt class="hdlist1">contentType</dt>

<dd>

The content type of the channel. //See [[content type management]](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#content type management).



Default: null (so that no type coercion is performed).



</dd>

<dt class="hdlist1">binder</dt>

<dd>

The binder used by this binding. See [Multiple Binders on the Classpath](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#multiple-binders) for details.



Default: null (the default binder will be used, if one exists).



</dd>

</dl>







#### Consumer properties



The following binding properties are available for input bindings only and must be prefixed with `spring.cloud.stream.bindings.<channelName>.consumer.`.





<dl>

<dt class="hdlist1">concurrency</dt>

<dd>

The concurrency of the inbound consumer.



Default: `1`.



</dd>

<dt class="hdlist1">partitioned</dt>

<dd>

Whether the consumer receives data from a partitioned producer.



Default: `false`.



</dd>

<dt class="hdlist1">headerMode</dt>

<dd>

When set to `raw`, disables header parsing on input. Effective only for messaging middleware that does not support message headers natively and requires header embedding. Useful when inbound data is coming from outside Spring Cloud Stream applications.



Default: `embeddedHeaders`.



</dd>

<dt class="hdlist1">maxAttempts</dt>

<dd>

The number of attempts of re-processing an inbound message.



Default: `3`.



</dd>

<dt class="hdlist1">backOffInitialInterval</dt>

<dd>

The backoff initial interval on retry.



Default: `1000`.



</dd>

<dt class="hdlist1">backOffMaxInterval</dt>

<dd>

The maximum backoff interval.



Default: `10000`.



</dd>

<dt class="hdlist1">backOffMultiplier</dt>

<dd>

The backoff multiplier.



Default: `2.0`.



</dd>

</dl>







#### Producer Properties



The following binding properties are available for output bindings only and must be prefixed with `spring.cloud.stream.bindings.<channelName>.producer.`.





<dl>

<dt class="hdlist1">partitionKeyExpression</dt>

<dd>

A SpEL expression that determines how to partition outbound data. If set, or if `partitionKeyExtractorClass` is set, outbound data on this channel will be partitioned, and `partitionCount` must be set to a value greater than 1 to be effective. The two options are mutually exclusive. See [Partitioning Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#partitioning).



Default: null.



</dd>

<dt class="hdlist1">partitionKeyExtractorClass</dt>

<dd>

A `PartitionKeyExtractorStrategy` implementation. If set, or if `partitionKeyExpression` is set, outbound data on this channel will be partitioned, and `partitionCount` must be set to a value greater than 1 to be effective. The two options are mutually exclusive. See [Partitioning Support](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#partitioning).



Default: null.



</dd>

<dt class="hdlist1">partitionSelectorClass</dt>

<dd>

A `PartitionSelectorStrategy` implementation. Mutually exclusive with `partitionSelectorExpression`. If neither is set, the partition will be selected as the `hashCode(key) % partitionCount`, where `key` is computed via either `partitionKeyExpression` or `partitionKeyExtractorClass`.



Default: null.



</dd>

<dt class="hdlist1">partitionSelectorExpression</dt>

<dd>

A SpEL expression for customizing partition selection. Mutually exclusive with `partitionSelectorClass`. If neither is set, the partition will be selected as the `hashCode(key) % partitionCount`, where `key` is computed via either `partitionKeyExpression` or `partitionKeyExtractorClass`.



Default: null.



</dd>

<dt class="hdlist1">partitionCount</dt>

<dd>

The number of target partitions for the data, if partitioning is enabled. Must be set to a value greater than 1 if the producer is partitioned. On Kafka, interpreted as a hint; the larger of this and the partition count of the target topic is used instead.



Default: `1`.



</dd>

<dt class="hdlist1">requiredGroups</dt>

<dd>

A comma-separated list of groups to which the producer must ensure message delivery even if they start after it has been created (e.g., by pre-creating durable queues in RabbitMQ).

</dd>

<dt class="hdlist1">headerMode</dt>

<dd>

When set to `raw`, disables header embedding on output. Effective only for messaging middleware that does not support message headers natively and requires header embedding. Useful when producing data for non-Spring Cloud Stream applications.



Default: `embeddedHeaders`.



</dd>

</dl>













## Binder-Specific Configuration





The following binder, consumer, and producer properties are specific to binder implementations.





### Rabbit-Specific Settings



#### RabbitMQ Binder Properties



By default, the RabbitMQ binder uses Spring Bootâ€™s `ConnectionFactory`, and it therefore supports all Spring Boot configuration options for RabbitMQ. (For reference, consult the [Spring Boot documentation](http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties).) RabbitMQ configuration options use the `spring.rabbitmq` prefix.





In addition to the Spring Boot options, the RabbitMQ binder supports the following properties:





<dl>

<dt class="hdlist1">spring.cloud.stream.rabbit.binder.adminAddresses</dt>

<dd>

A comma-separated list of RabbitMQ management plugin URLs. Only used when `nodes` contains more than one entry. Each entry in this list must have a corresponding entry in `spring.rabbitmq.addresses`.



Default: empty.



</dd>

<dt class="hdlist1">spring.cloud.stream.rabbit.binder.nodes</dt>

<dd>

A comma-separated list of RabbitMQ node names. When more than one entry, used to locate the server address where a queue is located. Each entry in this list must have a corresponding entry in `spring.rabbitmq.addresses`.



Default: empty.



</dd>

<dt class="hdlist1">spring.cloud.stream.rabbit.binder.compressionLevel</dt>

<dd>

Compression level for compressed bindings. See `java.util.zip.Deflater`.



Default: `1` (BEST_LEVEL).



</dd>

</dl>







#### RabbitMQ Consumer Properties



The following properties are available for Rabbit consumers only and must be prefixed with `spring.cloud.stream.rabbit.bindings.<channelName>.consumer.`.





<dl>

<dt class="hdlist1">acknowledgeMode</dt>

<dd>

The acknowledge mode.



Default: `AUTO`.



</dd>

<dt class="hdlist1">autoBindDlq</dt>

<dd>

Whether to automatically declare the DLQ and bind it to the binder DLX.



Default: `false`.



</dd>

<dt class="hdlist1">durableSubscription</dt>

<dd>

Whether subscription should be durable. Only effective if `group` is also set.



Default: `true`.



</dd>

<dt class="hdlist1">maxConcurrency</dt>

<dd>

Default: `1`.

</dd>

<dt class="hdlist1">prefetch</dt>

<dd>

Prefetch count.



Default: `1`.



</dd>

<dt class="hdlist1">prefix</dt>

<dd>

A prefix to be added to the name of the `destination` and queues.



Default: "".



</dd>

<dt class="hdlist1">recoveryInterval</dt>

<dd>

The interval between connection recovery attempts, in milliseconds.



Default: `5000`.



</dd>

<dt class="hdlist1">requeueRejected</dt>

<dd>

Whether delivery failures should be requeued.



Default: `true`.



</dd>

<dt class="hdlist1">requestHeaderPatterns</dt>

<dd>

The request headers to be transported.



Default: `[STANDARD_REQUEST_HEADERS,'*']`.



</dd>

<dt class="hdlist1">replyHeaderPatterns</dt>

<dd>

The reply headers to be transported.



Default: `[STANDARD_REPLY_HEADERS,'*']`.



</dd>

<dt class="hdlist1">republishToDlq</dt>

<dd>

By default, messages which fail after retries are exhausted are rejected. If a dead-letter queue (DLQ) is configured, RabbitMQ will route the failed message (unchanged) to the DLQ. If set to `true`, the bus will republish failed messages to the DLQ with additional headers, including the exception message and stack trace from the cause of the final failure.

</dd>

<dt class="hdlist1">transacted</dt>

<dd>

Whether to use transacted channels.



Default: `false`.



</dd>

<dt class="hdlist1">txSize</dt>

<dd>

The number of deliveries between acks.



Default: `1`.



</dd>

</dl>







#### Rabbit Producer Properties



The following properties are available for Rabbit producers only and must be prefixed with `spring.cloud.stream.rabbit.bindings.<channelName>.producer.`.





<dl>

<dt class="hdlist1">autoBindDlq</dt>

<dd>

Whether to automatically declare the DLQ and bind it to the binder DLX.



Default: `false`.



</dd>

<dt class="hdlist1">batchingEnabled</dt>

<dd>

Whether to enable message batching by producers.



Default: `false`.



</dd>

<dt class="hdlist1">batchSize</dt>

<dd>

The number of messages to buffer when batching is enabled.



Default: `100`.



</dd>

<dt class="hdlist1">batchBufferLimit</dt>

<dd>

Default: `10000`.

</dd>

<dt class="hdlist1">batchTimeout</dt>

<dd>

Default: `5000`.

</dd>

<dt class="hdlist1">compress</dt>

<dd>

Whether data should be compressed when sent.



Default: `false`.



</dd>

<dt class="hdlist1">deliveryMode</dt>

<dd>

Delivery mode.



Default: `PERSISTENT`.



</dd>

<dt class="hdlist1">prefix</dt>

<dd>

A prefix to be added to the name of the `destination` exchange.



Default: "".



</dd>

<dt class="hdlist1">requestHeaderPatterns</dt>

<dd>

The request headers to be transported.



Default: `[STANDARD_REQUEST_HEADERS,'*']`.



</dd>

<dt class="hdlist1">replyHeaderPatterns</dt>

<dd>

The reply headers to be transported.



Default: `[STANDARD_REPLY_HEADERS,'*']`.



</dd>

</dl>









### Kafka-Specific Settings



#### Kafka Binder Properties



<dl>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.brokers</dt>

<dd>

A list of brokers to which the Kafka binder will connect.



Default: `localhost`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.defaultBrokerPort</dt>

<dd>

`brokers` allows hosts specified with or without port information (e.g., `host1,host2:port2`). This sets the default port when no port is configured in the broker list.



Default: `9092`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.zkNodes</dt>

<dd>

A list of ZooKeeper nodes to which the Kafka binder can connect.



Default: `localhost`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.defaultZkPort</dt>

<dd>

`zkNodes` allows hosts specified with or without port information (e.g., `host1,host2:port2`). This sets the default port when no port is configured in the node list.



Default: `2181`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.headers</dt>

<dd>

The list of custom headers that will be transported by the binder.



Default: empty.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.offsetUpdateTimeWindow</dt>

<dd>

The frequency, in milliseconds, with which offsets are saved. Ignored if `0`.



Default: `10000`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.offsetUpdateCount</dt>

<dd>

The frequency, in number of updates, which which consumed offsets are persisted. Ignored if `0`. Mutually exclusive with `offsetUpdateTimeWindow`.



Default: `0`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.requiredAcks</dt>

<dd>

The number of required acks on the broker.



Default: `1`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.minPartitionCount</dt>

<dd>

Effective only if `autoCreateTopics` or `autoAddPartitions` is set. The global minimum number of partitions that the binder will configure on topics on which it produces/consumes data. It can be superseded by the `partitionCount` setting of the producer or by the value of `instanceCount` * `concurrency` settings of the producer (if either is larger).



Default: `1`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.replicationFactor</dt>

<dd>

The replication factor of auto-created topics if `autoCreateTopics` is active.



Default: `1`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.autoCreateTopics</dt>

<dd>

If set to `true`, the binder will create new topics automatically. If set to `false`, the binder will rely on the topics being already configured. In the latter case, if the topics do not exist, the binder will fail to start. Of note, this setting is independent of the `auto.topic.create.enable` setting of the broker and it does not influence it: if the server is set to auto-create topics, they may be created as part of the metadata retrieval request, with default broker settings.



Default: `true`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.autoAddPartitions</dt>

<dd>

If set to `true`, the binder will create add new partitions if required. If set to `false`, the binder will rely on the partition size of the topic being already configured. If the partition count of the target topic is smaller than the expected value, the binder will fail to start.



Default: `false`.



</dd>

<dt class="hdlist1">spring.cloud.stream.kafka.binder.socketBufferSize</dt>

<dd>

Size (in bytes) of the socket buffer to be used by the Kafka consumers.



Default: `2097152`.



</dd>

</dl>







#### Kafka Consumer Properties



The following properties are available for Kafka consumers only and must be prefixed with `spring.cloud.stream.kafka.bindings.<channelName>.consumer.`.





<dl>

<dt class="hdlist1">autoCommitOffset</dt>

<dd>

Whether to autocommit offsets when a message has been processed. If set to `false`, an `Acknowledgment` header will be available in the message headers for late acknowledgment.



Default: `true`.



</dd>

<dt class="hdlist1">autoCommitOnError</dt>

<dd>

Effective only if `autoCommitOffset` is set to `true`. If set to `false` it suppresses auto-commits for messages that result in errors, and will commit only for successful messages, allows a stream to automatically replay from the last successfully processed message, in case of persistent failures. If set to `true`, it will always auto-commit (if auto-commit is enabled). If not set (default), it effectively has the same value as `enableDlq`, auto-committing erroneous messages if they are sent to a DLQ, and not committing them otherwise.



Default: not set.



</dd>

<dt class="hdlist1">recoveryInterval</dt>

<dd>

The interval between connection recovery attempts, in milliseconds.



Default: `5000`.



</dd>

<dt class="hdlist1">resetOffsets</dt>

<dd>

Whether to reset offsets on the consumer to the value provided by `startOffset`.



Default: `false`.



</dd>

<dt class="hdlist1">startOffset</dt>

<dd>

The starting offset for new groups, or when `resetOffsets` is `true`. Allowed values: `earliest`, `latest`.



Default: null (equivalent to `earliest`).



</dd>

<dt class="hdlist1">enableDlq</dt>

<dd>

When set to true, it will send enable DLQ behavior for the consumer. Messages that result in errors will be forwarded to a topic named `error.<destination>.<group>`. This provides an alternative option to the more common Kafka replay scenario for the case when the number of errors is relatively small and replaying the entire original topic may be too cumbersome.



Default: `false`.



</dd>

</dl>







#### Kafka Producer Properties



The following properties are available for Kafka producers only and must be prefixed with `spring.cloud.stream.kafka.bindings.<channelName>.producer.`.





<dl>

<dt class="hdlist1">bufferSize</dt>

<dd>

Upper limit, in bytes, of how much data the Kafka producer will attempt to batch before sending.



Default: `16384`.



</dd>

<dt class="hdlist1">sync</dt>

<dd>

Whether the producer is synchronous.



Default: `false`.



</dd>

<dt class="hdlist1">batchTimeout</dt>

<dd>

How long the producer will wait before sending in order to allow more messages to accumulate in the same batch. (Normally the producer does not wait at all, and simply sends all the messages that accumulated while the previous send was in progress.) A non-zero value may increase throughput at the expense of latency.



Default: `0`.



</dd>

<dt class="hdlist1">maxRequestSize</dt>

<dd>

The maximum size of a message sending request.



Default: `1048576`.



</dd>

<dt class="hdlist1">configuration</dt>

<dd>

Map with a key/value pair containing generic Kafka producer properties.



Default: Empty map.



</dd>

</dl>













## Content Type and Transformation





To allow you to propagate information about the content type of produced messages, Spring Cloud Stream attaches, by default, a `contentType` header to outbound messages. For middleware that does not directly support headers, Spring Cloud Stream provides its own mechanism of automatically wrapping outbound messages in an envelope of its own. For middleware that does support headers, Spring Cloud Stream applications may receive messages with a given content type from non-Spring Cloud Stream applications.





Spring Cloud Stream can handle messages based on this information in two ways:





*   Through its `contentType` settings on inbound and outbound channels

*   Through its argument mapping performed for methods annotated with `@StreamListener`





Spring Cloud Stream allows you to declaratively configure type conversion for inputs and outputs using the `content-type` property of a binding. Note that general type conversion may also be accomplished easily by using a transformer inside your application. Currently, Spring Cloud Stream natively supports the following type conversions commonly used in streams:





*   **JSON** to/from **POJO**

*   **JSON** to/from [org.springframework.tuple.Tuple](https://github.com/spring-projects/spring-tuple/blob/master/spring-tuple/src/main/java/org/springframework/tuple/Tuple.java)

*   **Object** to/from **byte[]** : Either the raw bytes serialized for remote transport, bytes emitted by an application, or converted to bytes using Java serialization(requires the object to be Serializable)

*   **String** to/from **byte[]**

*   **Object** to **plain text** (invokes the objectâ€™s _toString()_ method)





Where _JSON_ represents either a byte array or String payload containing JSON. Currently, Objects may be converted from a JSON byte array or String. Converting to JSON always produces a String.





### MIME types



`content-type` values are parsed as media types, e.g., `application/json` or `text/plain;charset=UTF-8`. MIME types are especially useful for indicating how to convert to String or byte[] content. Spring Cloud Stream also uses MIME type format to represent Java types, using the general type `application/x-java-object` with a `type` parameter. For example, `application/x-java-object;type=java.util.Map` or `application/x-java-object;type=com.bar.Foo` can be set as the `content-type` property of an input binding. In addition, Spring Cloud Stream provides custom MIME types, notably, `application/x-spring-tuple` to specify a Tuple.







### MIME types and Java types



The type conversions Spring Cloud Stream provides out of the box are summarized in the following table:



<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 20%;"> <col style="width: 20%;"> <col style="width: 20%;"> <col style="width: 20%;"> <col style="width: 20%;"></colgroup>

<thead>



<th class="tableblock halign-left valign-top">Source Payload</th>

<th class="tableblock halign-left valign-top">Target Payload</th>

<th class="tableblock halign-left valign-top">content-type header</th>

<th class="tableblock halign-left valign-top">content-type</th>

<th class="tableblock halign-left valign-top">Comments</th>



</thead>







POJO





JSON String





ignored





application/json









Tuple





JSON String





ignored





application/json





JSON is tailored for Tuple









POJO





String (toString())





ignored





text/plain, java.lang.String









POJO





byte[] (java.io serialized)





ignored





application/x-java-serialized-object









JSON byte[] or String





POJO





application/json (or none)





application/x-java-object









byte[] or String





Serializable





application/x-java-serialized-object





application/x-java-object









JSON byte[] or String





Tuple





application/json (or none)





application/x-spring-tuple









byte[]





String





any





text/plain, java.lang.String





will apply any Charset specified in the content-type header









String





byte[]





any





application/octet-stream





will apply any Charset specified in the content-type header











Conversion applies to payloads that require type conversion. For example, if a module produces an XML string with outputType=application/json, the payload will not be converted from XML to JSON. This is because the payload at the moduleâ€™s output channel is already a String so no conversion will be applied at runtime.





While conversion is supported for both input and output channels, it is especially recommended to be used for the conversion of outbound messages. For the conversion of inbound messages, especially when the target is a POJO, the `@StreamListener` support will perform the conversion automatically.







### `@StreamListener` and Message Conversion



The `@StreamListener` annotation provides a convenient way for converting incoming messages without the need to specify the content type of an input channel. During the dispatching process to methods annotated with `@StreamListener`, a conversion will be applied automatically if the argument requires it.





For example, letâ€™s consider a message with the String content `{"greeting":"Hello, world"}` and a `content-type` header of `application/json` is received on the input channel. Let us consider the following application that receives it:







    public class GreetingMessage {

      String greeting;

      public String getGreeting() {
        return greeting;
      }

      public void setGreeting(String greeting) {
        this.greeting = greeting;
      }
    }

    @EnableBinding(Sink.class)
    @EnableAutoConfiguration
    public static class GreetingSink {

    		@StreamListener(Sink.INPUT)
    		public void receive(Greeting greeting) {
    			// handle Greeting
    		}
    	}







The argument of the method will be populated automatically with the POJO containing the unmarshalled form of the JSON String.











## Inter-Application Communication





### Connecting Multiple Application Instances



While Spring Cloud Stream makes it easy for individual Spring Boot applications to connect to messaging systems, the typical scenario for Spring Cloud Stream is the creation of multi-application pipelines, where microservice applications send data to each other. You can achieve this scenario by correlating the input and output destinations of adjacent applications.





Supposing that a design calls for the Time Source application to send data to the Log Sink application, you can use a common destination named `ticktock` for bindings within both applications.





Time Source will set the following property:







<pre>spring.cloud.stream.bindings.output.destination=ticktock</pre>







Log Sink will set the following property:







<pre>spring.cloud.stream.bindings.input.destination=ticktock</pre>









### Instance Index and Instance Count



When scaling up Spring Cloud Stream applications, each instance can receive information about how many other instances of the same application exist and what its own instance index is. Spring Cloud Stream does this through the `spring.cloud.stream.instanceCount` and `spring.cloud.stream.instanceIndex` properties. For example, if there are three instances of a HDFS sink application, all three instances will have `spring.cloud.stream.instanceCount` set to `3`, and the individual applications will have `spring.cloud.stream.instanceIndex` set to `0`, `1`, and `2`, respectively.





When Spring Cloud Stream applications are deployed via Spring Cloud Data Flow, these properties are configured automatically; when Spring Cloud Stream applications are launched independently, these properties must be set correctly. By default, `spring.cloud.stream.instanceCount` is `1`, and `spring.cloud.stream.instanceIndex` is `0`.





In a scaled-up scenario, correct configuration of these two properties is important for addressing partitioning behavior (see below) in general, and the two properties are always required by certain binders (e.g., the Kafka binder) in order to ensure that data are split correctly across multiple consumer instances.







### Partitioning



#### Configuring Output Bindings for Partitioning



An output binding is configured to send partitioned data by setting one and only one of its `partitionKeyExpression` or `partitionKeyExtractorClass` properties, as well as its `partitionCount` property. For example, the following is a valid and typical configuration:







<pre>spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id
spring.cloud.stream.bindings.output.producer.partitionCount=5</pre>







Based on the above example configuration, data will be sent to the target partition using the following logic.





A partition keyâ€™s value is calculated for each message sent to a partitioned output channel based on the `partitionKeyExpression`. The `partitionKeyExpression` is a SpEL expression which is evaluated against the outbound message for extracting the partitioning key.





















If a SpEL expression is not sufficient for your needs, you can instead calculate the partition key value by setting the property `partitionKeyExtractorClass` to a class which implements the `org.springframework.cloud.stream.binder.PartitionKeyExtractorStrategy` interface. While the SpEL expression should usually suffice, more complex cases may use the custom implementation strategy.















Once the message key is calculated, the partition selection process will determine the target partition as a value between `0` and `partitionCount - 1`. The default calculation, applicable in most scenarios, is based on the formula `key.hashCode() % partitionCount`. This can be customized on the binding, either by setting a SpEL expression to be evaluated against the key (via the `partitionSelectorExpression` property) or by setting a `org.springframework.cloud.stream.binder.PartitionSelectorStrategy` implementation (via the `partitionSelectorClass` property).





Additional properties can be configured for more advanced scenarios, as described in the following section.





















The Kafka binder will use the `partitionCount` setting as a hint to create a topic with the given partition count (in conjunction with the `minPartitionCount`, the maximum of the two being the value being used). Exercise caution when configuring both `minPartitionCount` for a binder and `partitionCount` for an application, as the larger value will be used. If a topic already exists with a smaller partition count and `autoAddPartitions` is disabled (the default), then the binder will fail to start. If a topic already exists with a smaller partition count and `autoAddPartitions` is enabled, new partitions will be added. If a topic already exists with a larger number of partitions than the maximum of (`minPartitionCount` and `partitionCount`), the existing partition count will be used.















##### Configuring Input Bindings for Partitioning



An input binding is configured to receive partitioned data by setting its `partitioned` property, as well as the `instanceIndex` and `instanceCount` properties on the application itself, as in the following example:







<pre>spring.cloud.stream.bindings.input.consumer.partitioned=true
spring.cloud.stream.instanceIndex=3
spring.cloud.stream.instanceCount=5</pre>







The `instanceCount` value represents the total number of application instances between which the data need to be partitioned, and the `instanceIndex` must be a unique value across the multiple instances, between `0` and `instanceCount - 1`. The instance index helps each application instance to identify the unique partition (or, in the case of Kafka, the partition set) from which it receives data. It is important to set both values correctly in order to ensure that all of the data is consumed and that the application instances receive mutually exclusive datasets.





While a scenario which using multiple instances for partitioned data processing may be complex to set up in a standalone case, Spring Cloud Dataflow can simplify the process significantly by populating both the input and output values correctly as well as relying on the runtime infrastructure to provide information about the instance index and instance count.















## Testing





Spring Cloud Stream provides support for testing your microservice applications without connecting to a messaging system. You can do that by using the `TestSupportBinder`. This is useful especially for unit testing your microservices.





The `TestSupportBinder` allows users to interact with the bound channels and inspect what messages are sent and received by the application





For outbound message channels, the `TestSupportBinder` registers a single subscriber and retains the messages emitted by the application in a `MessageCollector`. They can be retrieved during tests and have assertions made against them.





The user can also send messages to inbound message channels, so that the consumer application can consume the messages. The following example shows how to test both input and output channels on a processor.







    @RunWith(SpringJUnit4ClassRunner.class)
    @SpringApplicationConfiguration(classes = ExampleTest.MyProcessor.class)
    @IntegrationTest({"server.port=-1"})
    @DirtiesContext
    public class ExampleTest {

      @Autowired
      private Processor processor;

      @Autowired
      private BinderFactory<MessageChannel> binderFactory;

      @Autowired
      private MessageCollector messageCollector;

      @Test
      @SuppressWarnings("unchecked")
      public void testWiring() {
        Message<String> message = new GenericMessage<>("hello");
        processor.input().send(message);
        Message<String> received = (Message<String>) messageCollector.forChannel(processor.output()).poll();
        assertThat(received.getPayload(), equalTo("hello world"));
      }

      @SpringBootApplication
      @EnableBinding(Processor.class)
      public static class MyProcessor {

        @Autowired
        private Processor channels;

        @Transformer(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)
        public String transform(String in) {
          return in + " world";
        }
      }
    }







In the example above, we are creating an application that has an input and an output channel, bound through the `Processor` interface. The bound interface is injected into the test so we can have access to both channels. We are sending a message on the input channel and we are using the `MessageCollector` provided by Spring Cloud Streamâ€™s test support to capture the message has been sent to the output channel as a result. Once we have received the message, we can validate that the component functions correctly.









## Health Indicator





Spring Cloud Stream provides a health indicator for binders. It is registered under the name of `binders` and can be enabled or disabled by setting the `management.health.binders.enabled` property.









## Samples





For Spring Cloud Stream samples, please refer to the [spring-cloud-stream-samples](https://github.com/spring-cloud/spring-cloud-stream-samples) repository on GitHub.









## Getting Started





To get started with creating Spring Cloud Stream applications, visit the [Spring Initializr](https://start.spring.io/) and create a new Maven project named "GreetingSource". Select Spring Boot version 1.3.4 SNAPSHOT and search or tick the checkbox for Stream Kafka (we will be using Kafka for messaging).





Next, create a new class, `GreetingSource`, in the same package as the `GreetingSourceApplication` class. Give it the following code:







    import org.springframework.cloud.stream.annotation.EnableBinding;
    import org.springframework.cloud.stream.messaging.Source;
    import org.springframework.integration.annotation.InboundChannelAdapter;

    @EnableBinding(Source.class)
    public class GreetingSource {

        @InboundChannelAdapter(Source.OUTPUT)
        public String greet() {
            return "hello world " + System.currentTimeMillis();
        }
    }







The `@EnableBinding` annotation is what triggers the creation of Spring Integration infrastructure components. Specifically, it will create a Kafka connection factory, a Kafka outbound channel adapter, and the message channel defined inside the Source interface:







    public interface Source {

      String OUTPUT = "output";

      @Output(Source.OUTPUT)
      MessageChannel output();

    }







The auto-configuration also creates a default poller, so that the `greet()` method will be invoked once per second. The standard Spring Integration `@InboundChannelAdapter` annotation sends a message to the sourceâ€™s output channel, using the return value as the payload of the message.





To test-drive this setup, run a Kafka message broker. An easy way to do this is to use a Docker image:







    # On OS X
    $ docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=`docker-machine ip \`docker-machine active\`` --env ADVERTISED_PORT=9092 spotify/kafka

    # On Linux
    $ docker run -p 2181:2181 -p 9092:9092 --env ADVERTISED_HOST=localhost --env ADVERTISED_PORT=9092 spotify/kafka







Build the application:







<pre>./mvnw clean package</pre>







The consumer application is coded in a similar manner. Go back to Initializr and create another project, named LoggingSink. Then create a new class, `LoggingSink`, in the same package as the class `LoggingSinkApplication` and with the following code:







    import org.springframework.cloud.stream.annotation.EnableBinding;
    import org.springframework.cloud.stream.annotation.StreamListener;
    import org.springframework.cloud.stream.messaging.Sink;

    @EnableBinding(Sink.class)
    public class LoggingSink {

        @StreamListener(Sink.INPUT)
        public void log(String message) {
            System.out.println(message);
        }
    }







Build the application:







<pre>./mvnw clean package</pre>







To connect the GreetingSource application to the LoggingSink application, each application must share the same destination name. Starting up both applications as shown below, you will see the consumer application printing "hello world" and a timestamp to the console:







    cd GreetingSource
    java -jar target/GreetingSource-0.0.1-SNAPSHOT.jar --spring.cloud.stream.bindings.output.destination=mydest

    cd LoggingSink
    java -jar target/LoggingSink-0.0.1-SNAPSHOT.jar --server.port=8090 --spring.cloud.stream.bindings.input.destination=mydest







(The different server port prevents collisions of the HTTP port used to service the Spring Boot Actuator endpoints in the two applications.)





The output of the LoggingSink application will look something like the following:







    [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8090 (http)
    [           main] com.example.LoggingSinkApplication       : Started LoggingSinkApplication in 6.828 seconds (JVM running for 7.371)
    hello world 1458595076731
    hello world 1458595077732
    hello world 1458595078733
    hello world 1458595079734
    hello world 1458595080735









# Spring Cloud Bus









## Quick Start





Spring Cloud Bus works by adding Spring Boot autconfiguration if it detects itself on the classpath. All you need to do to enable the bus is to add `spring-cloud-starter-bus-amqp` or `spring-cloud-starter-bus-kafka` to your dependency management and Spring Cloud takes care of the rest. Make sure the broker (RabbitMQ or Kafka) is available and configured: running on localhost you shouldnâ€™t have to do anything, but if you are running remotely use Spring Cloud Connectors, or Spring Boot conventions to define the broker credentials, e.g. for Rabbit









<pre>spring:
  rabbitmq:
    host: mybroker.com
    port: 5672
    username: user
    password: secret</pre>







The bus currently supports sending messages to all nodes listening or all nodes for a particular service (as defined by Eureka). More selector criteria may be added in the future (ie. only service X nodes in data center Y, etcâ€¦â€‹). There are also some http endpoints under the `/bus/*` actuator namespace. There are currently two implemented. The first, `/bus/env`, sends key/value pairs to update each nodeâ€™s Spring Environment. The second, `/bus/refresh`, will reload each applicationâ€™s configuration, just as if they had all been pinged on their `/refresh` endpoint.

















<td class="content">The Bus starters cover Rabbit and Kafka, because those are the two most common implementations, but Spring Cloud Stream is quite flexible and binder will work combined with `spring-cloud-bus`.















## Addressing an Instance





The HTTP endpoints accept a "destination" parameter, e.g. "/bus/refresh?destination=customers:9000", where the destination is an `ApplicationContext` ID. If the ID is owned by an instance on the Bus then it will process the message and all other instances will ignore it. Spring Boot sets the ID for you in the `ContextIdApplicationContextInitializer` to a combination of the `spring.application.name`, active profiles and `server.port` by default.









## Addressing all instances of a service





The "destination" parameter is used in a Spring `PathMatcher` (with the path separator as a colon `:`) to determine if an instance will process the message. Using the example from above, "/bus/refresh?destination=customers:**" will target all instances of the "customers" service regardless of the profiles and ports set as the `ApplicationContext` ID.









## Application Context ID must be unique





The bus tries to eliminate processing an event twice, once from the original `ApplicationEvent` and once from the queue. To do this, it checks the sending application context id againts the current application context id. If multiple instances of a service have the same application context id, events will not be processed. Running on a local machine, each service will be on a different port and that will be part of the application context id. Cloud Foundry supplies an index to differentiate. To ensure that the application context id is the unique, set `spring.application.index` to something unique for each instance of a service. For example, in lattice, set `spring.application.index=${INSTANCE_INDEX}` in application.properties (or bootstrap.properties if using configserver).









## Customizing the Message Broker





Spring Cloud Bus uses [Spring Cloud Stream](https://cloud.spring.io/spring-cloud-stream) to broadcast the messages so to get messages to flow you only need to include the binder implementation of your choice in the classpath. There are convenient starters specifically for the bus with AMQP (RabbitMQ) and Kafka (`spring-cloud-starter-bus-[amqp,kafka]`). Generally speaking Spring Cloud Stream relies on Spring Boot autoconfiguration conventions for configuring middleware, so for instance the AMQP broker address can be changed with `spring.rabbitmq.*` configuration properties. Spring Cloud Bus has a handful of native configuration properties in `spring.cloud.bus.*` (e.g. `spring.cloud.bus.destination` is the name of the topic to use the the externall middleware). Normally the defaults will suffice.





To lean more about how to customize the message broker settings consult the Spring Cloud Stream documentation.









## Tracing Bus Events





Bus events (subclasses of `RemoteApplicationEvent`) can be traced by setting `spring.cloud.bus.trace.enabled=true`. If you do this then the Spring Boot `TraceRepository` (if it is present) will show each event sent and all the acks from each service instance. Example (from the `/trace` endpoint):







    {
      "timestamp": "2015-11-26T10:24:44.411+0000",
      "info": {
        "signal": "spring.cloud.bus.ack",
        "type": "RefreshRemoteApplicationEvent",
        "id": "c4d374b7-58ea-4928-a312-31984def293b",
        "origin": "stores:8081",
        "destination": "*:**"
      }
      },
      {
      "timestamp": "2015-11-26T10:24:41.864+0000",
      "info": {
        "signal": "spring.cloud.bus.sent",
        "type": "RefreshRemoteApplicationEvent",
        "id": "c4d374b7-58ea-4928-a312-31984def293b",
        "origin": "customers:9000",
        "destination": "*:**"
      }
      },
      {
      "timestamp": "2015-11-26T10:24:41.862+0000",
      "info": {
        "signal": "spring.cloud.bus.ack",
        "type": "RefreshRemoteApplicationEvent",
        "id": "c4d374b7-58ea-4928-a312-31984def293b",
        "origin": "customers:9000",
        "destination": "*:**"
      }
    }







This trace shows that a `RefreshRemoteApplicationEvent` was sent from `customers:9000`, broadcast to all services, and it was received (acked) by `customers:9000` and `stores:8081`.





To handle the ack signals yourself you could add an `@EventListener` for the `AckRemoteApplicationEvent` and `SentApplicationEvent` types to your app (and enable tracing). Or you could tap into the `TraceRepository` and mine the data from there.

















<td class="content">Any Bus application can trace acks, but sometimes it will be useful to do this in a central service that can do more complex queries on the data. Or forward it to a specialized tracing service.















## Broadcasting Your Own Events





The Bus can carry any event of type `RemoteApplicationEvent`, but the default transport is JSON and the deserializer needs to know which types are going to be used ahead of time. To register a new type it needs to be in a subpackage of `org.springframework.cloud.bus.event`. You can use `@JsonTypeName` on your custom class or rely on the default strategy which is to use the simple name of the class. Note that both the producer and the consumer will need access to the class definition.







# Spring Cloud Sleuth







Adrian Cole, Spencer Gibb, Marcin Grzejszczak, Dave Syer





**Brixton.BUILD-SNAPSHOT**





Spring Cloud Sleuth implements a distributed tracing solution for [Spring Cloud](http://cloud.spring.io/).









### Terminology



Spring Cloud Sleuth borrows [Dapperâ€™s](http://research.google.com/pubs/pub36356.html) terminology.





**Span:** The basic unit of work. For example, sending an RPC is a new span, as is sending a response to an RPC. Spanâ€™s are identified by a unique 64-bit ID for the span and another 64-bit ID for the trace the span is a part of. Spans also have other data, such as descriptions, timestamped events, key-value annotations (tags), the ID of the span that caused them, and process IDâ€™s (normally IP address).





Spans are started and stopped, and they keep track of their timing information. Once you create a span, you must stop it at some point in the future.

















<td class="content">The initial span that starts a trace is called a `root span`. The value of span id of that span is equal to trace id.











**Trace:** A set of spans forming a tree-like structure. For example, if you are running a distributed big-data store, a trace might be formed by a put request.





**Annotation:** is used to record existence of an event in time. Some of the core annotations used to define the start and stop of a request are:





*   **cs** - Client Sent - The client has made a request. This annotation depicts the start of the span.

*   **sr** - Server Received - The server side got the request and will start processing it. If one subtracts the cs timestamp from this timestamp one will receive the network latency.

*   **ss** - Server Sent - Annotated upon completion of request processing (when the response got sent back to the client). If one subtracts the sr timestamp from this timestamp one will receive the time needed by the server side to process the request.

*   **cr** - Client Received - Signifies the end of the span. The client has successfully received the response from the server side. If one subtracts the cs timestamp from this timestamp one will receive the whole time needed by the client to receive the response from the server.





Visualization of what **Span** and **Trace** will look in a system together with the Zipkin annotations:











Each color of a note signifies a span (7 spans - from **A** to **G**). If you have such information in the note:







    Trace Id = X
    Span Id = D
    Client Sent







That means that the current span has **Trace-Id** set to **X**, **Span-Id** set to **D**. It also has emitted **Client Sent** event.





This is how the visualization of the parent / child relationship of spans would look like:













### Purpose



In the following sections the example from the image above will be taken into consideration.





#### Distributed tracing with Zipkin



Altogether there are **7 spans** . If you go to traces in Zipkin you will see this number in the second trace:











However if you pick a particular trace then you will see **4 spans**:























<td class="content">When picking a particular trace you will see merged spans. That means that if there were 2 spans sent to Zipkin with Server Received and Server Sent / Client Received and Client Sent annotations then they will presented as a single span.











Why is there a difference between the 7 and 4 spans in this case?





*   2 spans come from `http:/start` span. It has the Server Received (SR) and Server Sent (SS) annotations.

*   2 spans come from the RPC call from `service1` to `service2` to the `http:/foo` endpoint. It has the Client Sent (CS) and Client Received (CR) annotations on `service1` side. It also has Server Received (SR) and Server Sent (SS) annotations on the `service2` side. Physically there are 2 spans but they form 1 logical span related to an RPC call.

*   2 spans come from the RPC call from `service2` to `service3` to the `http:/bar` endpoint. It has the Client Sent (CS) and Client Received (CR) annotations on `service2` side. It also has Server Received (SR) and Server Sent (SS) annotations on the `service3` side. Physically there are 2 spans but they form 1 logical span related to an RPC call.

*   2 spans come from the RPC call from `service2` to `service4` to the `http:/baz` endpoint. It has the Client Sent (CS) and Client Received (CR) annotations on `service2` side. It also has Server Received (SR) and Server Sent (SS) annotations on the `service4` side. Physically there are 2 spans but they form 1 logical span related to an RPC call.





So if we count the physical spans we have **1** from `http:/start`, **2** from `service1` calling `service2`, **2** form `service2` calling `service3` and **2** from `service2` calling `service4`. Altogether **7** spans.





Logically we see the information of **Total Spans: 4** because we have **1** span related to the incoming request to `service1` and **3** spans related to RPC calls.







#### Visualizing errors



Zipkin allows you to visualize errors in your trace. When an exception was thrown and wasnâ€™t caught then weâ€™re setting proper tags on the span which Zipkin can properly colorize. You could see in the list of traces one trace that was in red color. Thatâ€™s because there was an exception thrown.





If you click that trace then youâ€™ll see a similar picture











Then if you click on one of the spans youâ€™ll see the following











As you can see you can easily see the reason for an error and the whole stacktrace related to it.







#### Live examples











The dependency graph in Zipkin would look like this:





















#### Log correlation



When grepping the logs of those four applications by trace id equal to e.g. `2485ec27856c56f4` one would get the following:







    service1.log:2016-02-26 11:15:47.561  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Hello from service1\. Calling service2
    service2.log:2016-02-26 11:15:47.710  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Hello from service2\. Calling service3 and then service4
    service3.log:2016-02-26 11:15:47.895  INFO [service3,2485ec27856c56f4,1210be13194bfe5,true] 68060 --- [nio-8083-exec-1] i.s.c.sleuth.docs.service3.Application   : Hello from service3
    service2.log:2016-02-26 11:15:47.924  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service3 [Hello from service3]
    service4.log:2016-02-26 11:15:48.134  INFO [service4,2485ec27856c56f4,1b1845262ffba49d,true] 68061 --- [nio-8084-exec-1] i.s.c.sleuth.docs.service4.Application   : Hello from service4
    service2.log:2016-02-26 11:15:48.156  INFO [service2,2485ec27856c56f4,9aa10ee6fbde75fa,true] 68059 --- [nio-8082-exec-1] i.s.c.sleuth.docs.service2.Application   : Got response from service4 [Hello from service4]
    service1.log:2016-02-26 11:15:48.182  INFO [service1,2485ec27856c56f4,2485ec27856c56f4,true] 68058 --- [nio-8081-exec-1] i.s.c.sleuth.docs.service1.Application   : Got response from service2 [Hello from service2, response from service3 [Hello from service3] and from service4 [Hello from service4]]







If youâ€™re using a log aggregating tool like [Kibana](https://www.elastic.co/products/kibana), [Splunk](http://www.splunk.com/) etc. you can order the events that took place. An example of Kibana would look like this:











If you want to use [Logstash](https://www.elastic.co/guide/en/logstash/current/index.html) here is the Grok pattern for Logstash:







    filter {
           # pattern matching logback pattern
           grok {
                  match => { "message" => "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
           }
    }



















<td class="content">If you want to use Grok together with the logs from Cloud Foundry you have to use this pattern:













    filter {
           # pattern matching logback pattern
           grok {
                  match => { "message" => "(?m)OUT\s+%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:severity}\s+\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\]\s+%{DATA:pid}---\s+\[%{DATA:thread}\]\s+%{DATA:class}\s+:\s+%{GREEDYDATA:rest}" }
           }
    }







##### JSON Logback with Logstash



Often you do not want to store your logs in a text file but in a JSON file that Logstash can immediately pick. To do that you have to do the following (for readability weâ€™re passing the dependencies in the `groupId:artifactId:version` notation.





**Dependencies setup**





*   Ensure that Logback is on the classpath (`ch.qos.logback:logback-core`)

*   Add Logstash Logback encode - example for version `4.6` : `net.logstash.logback:logstash-logback-encoder:4.6`





**Logback setup**





Below you can find an example of a Logback configuration (file named [logback-spring.xml](https://github.com/spring-cloud-samples/sleuth-documentation-apps/blob/master/service1/src/main/resources/logback-spring.xml)) that:





*   logs information from the application in a JSON format to a `build/${spring.application.name}.json` file

*   has commented out two additional appenders - console and standard log file

*   has the same logging pattern as the one presented in the previous section

















<td class="content">If youâ€™re using a custom `logback-spring.xml` then you have to pass the `spring.application.name` in `bootstrap` instead of `application` property file. Otherwise your custom logback file wonâ€™t read the property properly.

















### Adding to the project



#### Only Sleuth (log correlation)



If you want to profit only from Spring Cloud Sleuth without the Zipkin integration just add the `spring-cloud-starter-sleuth` module to your project.









    <dependencyManagement> (1)
          <dependencies>
              <dependency>
                  <groupId>org.springframework.cloud</groupId>
                  <artifactId>spring-cloud-dependencies</artifactId>
                  <version>Brixton.RELEASE</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
    </dependencyManagement>

    <dependency> (2)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-starter-sleuth`









    dependencyManagement { (1)
        imports {
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
        }
    }

    dependencies { (2)
        compile "org.springframework.cloud:spring-cloud-starter-sleuth"
    }







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-starter-sleuth`







#### Sleuth with Zipkin via HTTP



If you want both Sleuth and Zipkin just add the `spring-cloud-starter-zipkin` dependency.









    <dependencyManagement> (1)
          <dependencies>
              <dependency>
                  <groupId>org.springframework.cloud</groupId>
                  <artifactId>spring-cloud-dependencies</artifactId>
                  <version>Brixton.RELEASE</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
    </dependencyManagement>

    <dependency> (2)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-zipkin</artifactId>
    </dependency>







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-starter-zipkin`









    dependencyManagement { (1)
        imports {
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
        }
    }

    dependencies { (2)
        compile "org.springframework.cloud:spring-cloud-starter-zipkin"
    }







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-starter-zipkin`







#### Sleuth with Zipkin via Spring Cloud Stream



If you want both Sleuth and Zipkin just add the `spring-cloud-sleuth-stream` dependency.









    <dependencyManagement> (1)
          <dependencies>
              <dependency>
                  <groupId>org.springframework.cloud</groupId>
                  <artifactId>spring-cloud-dependencies</artifactId>
                  <version>Brixton.RELEASE</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
    </dependencyManagement>

    <dependency> (2)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-stream</artifactId>
    </dependency>
    <dependency> (3)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>
    <!-- EXAMPLE FOR RABBIT BINDING -->
    <dependency> (4)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
    </dependency>







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-sleuth-stream`

3.  Add the dependency to `spring-cloud-starter-sleuth` - that way all dependant dependencies will be downloaded

4.  Add a binder (e.g. Rabbit binder) to tell Spring Cloud Stream what it should bind to









    dependencyManagement { (1)
        imports {
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
        }
    }

    dependencies {
        compile "org.springframework.cloud:spring-cloud-sleuth-stream" (2)
        compile "org.springframework.cloud:spring-cloud-starter-sleuth" (3)
        // Example for Rabbit binding
        compile "org.springframework.cloud:spring-cloud-stream-binder-rabbit" (4)
    }







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-sleuth-stream`

3.  Add the dependency to `spring-cloud-starter-sleuth` - that way all dependant dependencies will be downloaded

4.  Add a binder (e.g. Rabbit binder) to tell Spring Cloud Stream what it should bind to







#### Spring Cloud Sleuth Stream Zipkin Collector



If you want to start a Spring Cloud Sleuth Stream Zipkin collector just add the `spring-cloud-sleuth-zipkin-stream` dependency









    <dependencyManagement> (1)
          <dependencies>
              <dependency>
                  <groupId>org.springframework.cloud</groupId>
                  <artifactId>spring-cloud-dependencies</artifactId>
                  <version>Brixton.RELEASE</version>
                  <type>pom</type>
                  <scope>import</scope>
              </dependency>
          </dependencies>
    </dependencyManagement>

    <dependency> (2)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-zipkin-stream</artifactId>
    </dependency>
    <dependency> (3)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>
    <!-- EXAMPLE FOR RABBIT BINDING -->
    <dependency> (4)
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-stream-binder-rabbit</artifactId>
    </dependency>







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-sleuth-zipkin-stream`

3.  Add the dependency to `spring-cloud-starter-sleuth` - that way all dependant dependencies will be downloaded

4.  Add a binder (e.g. Rabbit binder) to tell Spring Cloud Stream what it should bind to









    dependencyManagement { (1)
        imports {
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:Brixton.RELEASE"
        }
    }

    dependencies {
        compile "org.springframework.cloud:spring-cloud-sleuth-zipkin-stream" (2)
        compile "org.springframework.cloud:spring-cloud-starter-sleuth" (3)
        // Example for Rabbit binding
        compile "org.springframework.cloud:spring-cloud-stream-binder-rabbit" (4)
    }







1.  In order not to pick versions by yourself itâ€™s much better if you add the dependency management via the Spring BOM

2.  Add the dependency to `spring-cloud-sleuth-zipkin-stream`

3.  Add the dependency to `spring-cloud-starter-sleuth` - that way all dependant dependencies will be downloaded

4.  Add a binder (e.g. Rabbit binder) to tell Spring Cloud Stream what it should bind to





and then just annotate your main class with `@EnableZipkinStreamServer` annotation:









## Additional resources





**Marcin Grzejszczak talking about Spring Cloud Sleuth and Zipkin**











[click here to see the video](https://www.youtube.com/watch?v=eQV71Mw1u1c)









## Features





*   Adds trace and span ids to the Slf4J MDC, so you can extract all the logs from a given trace or span in a log aggregator. Example logs:

    <div class="listingblock">

    <div class="content">

    <pre>2016-02-02 15:30:57.902  INFO [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
    2016-02-02 15:30:58.372 ERROR [bar,6bfd228dc00d216b,6bfd228dc00d216b,false] 23030 --- [nio-8081-exec-3] ...
    2016-02-02 15:31:01.936  INFO [bar,46ab0d418373cbc9,46ab0d418373cbc9,false] 23030 --- [nio-8081-exec-4] ...</pre>





    <div class="paragraph">

    notice the `[appname,traceId,spanId,exportable]` entries from the MDC:



    <div class="ulist">

    *   **spanId** - the id of a specific operation that took place

    *   **appname** - the name of the application that logged the span

    *   **traceId** - the id of the latency graph that contains the span

    *   **exportable** - whether the log should be exported to Zipkin or not. When would you like the span not to be exportable? In the case in which you want to wrap some operation in a Span and have it written to the logs only.



*   Provides an abstraction over common distributed tracing data models: traces, spans (forming a DAG), annotations, key-value annotations. Loosely based on HTrace, but Zipkin (Dapper) compatible.

*   Sleuth records timing information to aid in latency analysis. Using sleuth, you can pinpoint causes of latency in your applications. Sleuth is written to not log too much, and to not cause your production application to crash.

    <div class="ulist">

    *   propagates structural data about your call-graph in-band, and the rest out-of-band.

    *   includes opinionated instrumentation of layers such as HTTP

    *   includes sampling policy to manage volume

    *   can report to a Zipkin system for query and visualization



*   Instruments common ingress and egress points from Spring applications (servlet filter, async endpoints, rest template, scheduled actions, message channels, zuul filters, feign client).

*   Sleuth includes default logic to join a trace across http or messaging boundaries. For example, http propagation works via Zipkin-compatible request headers. This propagation logic is defined and customized via `SpanInjector` and `SpanExtractor` implementations.

*   Provides simple metrics of accepted / dropped spans.

*   If `spring-cloud-sleuth-zipkin` then the app will generate and collect Zipkin-compatible traces. By default it sends them via HTTP to a Zipkin server on localhost (port 9411). Configure the location of the service using `spring.zipkin.baseUrl`.

*   If `spring-cloud-sleuth-stream` then the app will generate and collect traces via [Spring Cloud Stream](https://github.com/spring-cloud/spring-cloud-stream). Your app automatically becomes a producer of tracer messages that are sent over your broker of choice (e.g. RabbitMQ, Apache Kafka, Redis).

















<td class="content">If using Zipkin or Stream, configure the percentage of spans exported using `spring.sleuth.sampler.percentage` (default 0.1, i.e. 10%). **Otherwise you might think that Sleuth is not working cause itâ€™s omitting some spans.**























<td class="content">the SLF4J MDC is always set and logback users will immediately see the trace and span ids in logs per the example above. Other logging systems have to configure their own formatter to get the same result. The default is `logging.pattern.level` set to `%clr(%5p) %clr([${spring.application.name:},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}]){yellow}` (this is a Spring Boot feature for logback users). **This means that if youâ€™re not using SLF4J this pattern WILL NOT be automatically applied**.















## Sampling





In distributed tracing the data volumes can be very high so sampling can be important (you usually donâ€™t need to export all spans to get a good picture of what is happening). Spring Cloud Sleuth has a `Sampler` strategy that you can implement to take control of the sampling algorithm. Samplers do not stop span (correlation) ids from being generated, but they do prevent the tags and events being attached and exported. By default you get a strategy that continues to trace if a span is already active, but new ones are always marked as non-exportable. If all your apps run with this sampler you will see traces in logs, but not in any remote store. For testing the default is often enough, and it probably is all you need if you are only using the logs (e.g. with an ELK aggregator). If you are exporting span data to Zipkin or Spring Cloud Stream, there is also an `AlwaysSampler` that exports everything and a `PercentageBasedSampler` that samples a fixed fraction of spans.

















<td class="content">the `PercentageBasedSampler` is the default if you are using `spring-cloud-sleuth-zipkin` or `spring-cloud-sleuth-stream`. You can configure the exports using `spring.sleuth.sampler.percentage`. The passed value needs to be a double from `0.0` to `1.0` so itâ€™s not a percentage. For backwards compatibility reasons weâ€™re not changing the property name.











A sampler can be installed just by creating a bean definition, e.g:







    @Bean
    public Sampler defaultSampler() {
        return new AlwaysSampler();
    }











## Instrumentation





Spring Cloud Sleuth instruments all your Spring application automatically, so you shouldnâ€™t have to do anything to activate it. The instrumentation is added using a variety of technologies according to the stack that is available, e.g. for a servlet web application we use a `Filter`, and for Spring Integration we use `ChannelInterceptors`.





You can customize the keys used in span tags. To limit the volume of span data, by default an HTTP request will be tagged only with a handful of metadata like the status code, host and URL. You can add request headers by configuring `spring.sleuth.keys.http.headers` (a list of header names).

















<td class="content">Remember that tags are only collected and exported if there is a `Sampler` that allows it (by default there is not, so there is no danger of accidentally collecting too much data without configuring something).























<td class="content">Currently the instrumentation in Spring Cloud Sleuth is eager - it means that weâ€™re actively trying to pass the tracing context between threads. Also timing events are captured even when sleuth isnâ€™t exporting data to a tracing system. This approach may change in the future towards being lazy on this matter.















## Span lifecycle





You can do the following operations on the Span by means of **org.springframework.cloud.sleuth.Tracer** interface:





*   [start](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#creating-and-closing-spans) - when you start a span its name is assigned and start timestamp is recorded.

*   [close](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#creating-and-closing-spans) - the span gets finished (the end time of the span is recorded) and if the span is **exportable** then it will be eligible for collection to Zipkin. The span is also removed from the current thread.

*   [continue](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#continuing-spans) - a new instance of span will be created whereas it will be a copy of the one that it continues.

*   [detach](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#continuing-spans) - the span doesnâ€™t get stopped or closed. It only gets removed from the current thread.

*   [create with explicit parent](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#creating-spans-with-explicit-parent) - you can create a new span and set an explicit parent to it

















<td class="content">Spring creates the instance of `Tracer` for you. In order to use it all you need is to just autowire it.











### Creating and closing spans



You can manually create spans by using the **Tracer** interface.







    // Start a span. If there was a span present in this thread it will become
    // the `newSpan`'s parent.
    Span newSpan = this.tracer.createSpan("calculateTax");
    try {
        // ...
        // You can tag a span
        this.tracer.addTag("taxValue", taxValue);
        // ...
        // You can log an event on a span
        newSpan.logEvent("taxCalculated");
    } finally {
        // Once done remember to close the span. This will allow collecting
        // the span to send it to Zipkin
        this.tracer.close(newSpan);
    }







In this example we could see how to create a new instance of span. Assuming that there already was a span present in this thread then it would become the parent of that span.

















<td class="content">Always clean after you create a span! Donâ€™t forget to close a span if you want to send it to Zipkin.













### Continuing spans



Sometimes you donâ€™t want to create a new span but you want to continue one. Example of such a situation might be (of course it all depends on the use-case):





*   **AOP** - If there was already a span created before an aspect was reached then you might not want to create a new span.

*   **Hystrix** - executing a Hystrix command is most likely a logical part of the current processing. Itâ€™s in fact only a technical implementation detail that you wouldnâ€™t necessarily want to reflect in tracing as a separate being.





The continued instance of span is equal to the one that it continues:







    Span continuedSpan = this.tracer.continueSpan(spanToContinue);
    assertThat(continuedSpan).isEqualTo(spanToContinue);







To continue a span you can use the **Tracer** interface.







    // let's assume that we're in a thread Y and we've received
    // the `initialSpan` from thread X
    Span continuedSpan = this.tracer.continueSpan(initialSpan);
    try {
        // ...
        // You can tag a span
        this.tracer.addTag("taxValue", taxValue);
        // ...
        // You can log an event on a span
        continuedSpan.logEvent("taxCalculated");
    } finally {
        // Once done remember to detach the span. That way you'll
        // safely remove it from the current thread without closing it
        this.tracer.detach(continuedSpan);
    }



















<td class="content">Always clean after you create a span! Donâ€™t forget to detach a span if some work was done started in one thread (e.g. thread X) and itâ€™s waiting for other threads (e.g. Y, Z) to finish. Then the spans in the threads Y, Z should be detached at the end of their work. When the results are collected the span in thread X should be closed.













### Creating spans with an explicit parent



There is a possibility that you want to start a new span and provide an explicit parent of that span. Letâ€™s assume that the parent of a span is in one thread and you want to start a new span in another thread. The `startSpan` method of the `Tracer` interface is the method you are looking for.







    // let's assume that we're in a thread Y and we've received
    // the `initialSpan` from thread X. `initialSpan` will be the parent
    // of the `newSpan`
    Span newSpan = this.tracer.createSpan("calculateCommission", initialSpan);
    try {
        // ...
        // You can tag a span
        this.tracer.addTag("commissionValue", commissionValue);
        // ...
        // You can log an event on a span
        newSpan.logEvent("commissionCalculated");
    } finally {
        // Once done remember to close the span. This will allow collecting
        // the span to send it to Zipkin. The tags and events set on the
        // newSpan will not be present on the parent
        this.tracer.close(newSpan);
    }



















<td class="content">After having created such a span remember to close it. Otherwise you will see a lot of warnings in your logs related to the fact that you have a span present in the current thread other than the one youâ€™re trying to close. Whatâ€™s worse your spans wonâ€™t get closed properly thus will not get collected to Zipkin.

















## Naming spans





Picking a span name is not a trivial task. Span name should depict an operation name. The name should be low cardinality (e.g. not include identifiers).





Since there is a lot of instrumentation going on some of the span names will be artificial like:





*   `controller-method-name` when received by a Controller with a method name `conrollerMethodName`

*   `async` for asynchronous operations done via wrapped `Callable` and `Runnable`.

*   `@Scheduled` annotated methods will return the simple name of the class.





Fortunately, for the asynchronous processing you can provide explicit naming.





### @SpanName annotation



You can do name the span explicitly via the `@SpanName` annotation.







    @SpanName("calculateTax")
    class TaxCountingRunnable implements Runnable {

        @Override public void run() {
            // perform logic
        }
    }







In this case, when processed in the following manner:







    Runnable runnable = new TraceRunnable(tracer, spanNamer, new TaxCountingRunnable());
    Future<?> future = executorService.submit(runnable);
    // ... some additional logic ...
    future.get();







The span will be named `calculateTax`.







### toString() method



Itâ€™s pretty rare to create separate classes for `Runnable` or `Callable`. Typically one creates an anonymous instance of those classes. You canâ€™t annotate such classes thus to override that, if there is no `@SpanName` annotation present, weâ€™re checking if the class has a custom implementation of the `toString()` method.





So executing such code:







    Runnable runnable = new TraceRunnable(tracer, spanNamer, new Runnable() {
        @Override public void run() {
            // perform logic
        }

        @Override public String toString() {
            return "calculateTax";
        }
    });
    Future<?> future = executorService.submit(runnable);
    // ... some additional logic ...
    future.get();







will lead in creating a span named `calculateTax`.











## Customizations





Thanks to the `SpanInjector` and `SpanExtractor` you can customize the way spans are created and propagated.





There are currently two built-in ways to pass tracing information between processes:





*   via Spring Integration

*   via HTTP





Span ids are extracted from Zipkin-compatible (B3) headers (either `Message` or HTTP headers), to start or join an existing trace. Trace information is injected into any outbound requests so the next hop can extract them.





### Spring Integration



For Spring Integration these are the beans responsible for creation of a Span from a `Message` and filling in the `MessageBuilder` with tracing information.







    @Bean
    public SpanExtractor<Message> messagingSpanExtractor() {
        ...
    }

    @Bean
    public SpanInjector<MessageBuilder> messagingSpanInjector() {
        ...
    }







You can override them by providing your own implementation and by adding a `@Primary` annotation to your bean definition.







### HTTP



For HTTP these are the beans responsible for creation of a Span from a `HttpServletRequest`.







    @Bean
    public SpanExtractor<HttpServletRequest> httpServletRequestSpanExtractor() {
        ...
    }







You can override them by providing your own implementation and by adding a `@Primary` annotation to your bean definition.







### Example



Letâ€™s assume that instead of the standard Zipkin compatible tracing HTTP header names you have





*   for trace id - `correlationId`

*   for span id - `mySpanId`





This is a an example of a `SpanExtractor`







    static class CustomHttpServletRequestSpanExtractor
            implements SpanExtractor<HttpServletRequest> {

        @Override
        public Span joinTrace(HttpServletRequest carrier) {
            long traceId = Span.hexToId(carrier.getHeader("correlationId"));
            long spanId = Span.hexToId(carrier.getHeader("mySpanId"));
            // extract all necessary headers
            Span.SpanBuilder builder = Span.builder().traceId(traceId).spanId(spanId);
            // build rest of the Span
            return builder.build();
        }
    }







And you could register it like this:







    @Bean
    @Primary
    SpanExtractor<HttpServletRequest> customHttpServletRequestSpanExtractor() {
        return new CustomHttpServletRequestSpanExtractor();
    }







Spring Cloud Sleuth does not add trace/span related headers to the Http Response for security reasons. If you need the headers then a custom `SpanInjector` that injects the headers into the Http Response and a Servlet filter which makes use of this can be added the following way:







    static class CustomHttpServletResponseSpanInjector
            implements SpanInjector<HttpServletResponse> {

        @Override
        public void inject(Span span, HttpServletResponse carrier) {
            carrier.addHeader(Span.TRACE_ID_NAME, span.traceIdString());
            carrier.addHeader(Span.SPAN_ID_NAME, Span.idToHex(span.getSpanId()));
        }
    }

    static class HttpResponseInjectingTraceFilter extends GenericFilterBean {

        private final Tracer tracer;
        private final SpanInjector<HttpServletResponse> spanInjector;

        public HttpResponseInjectingTraceFilter(Tracer tracer, SpanInjector<HttpServletResponse> spanInjector) {
            this.tracer = tracer;
            this.spanInjector = spanInjector;
        }

        @Override
        public void doFilter(ServletRequest request, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            Span currentSpan = this.tracer.getCurrentSpan();
            this.spanInjector.inject(currentSpan, response);
            filterChain.doFilter(request, response);
        }
    }







And you could register them like this:







    @Bean
    SpanInjector<HttpServletResponse> customHttpServletResponseSpanInjector() {
        return new CustomHttpServletResponseSpanInjector();
    }

    @Bean
    HttpResponseInjectingTraceFilter responseInjectingTraceFilter(Tracer tracer) {
        return new HttpResponseInjectingTraceFilter(tracer, customHttpServletResponseSpanInjector());
    }









### Custom SA tag in Zipkin



Sometimes you want to create a manual Span that will wrap a call to an external service which is not instrumented. What you can do is to create a span with the `peer.service` tag that will contain a value of the service that you want to call. Below you can see an example of a call to Redis that is wrapped in such a span.







    org.springframework.cloud.sleuth.Span newSpan = tracer.createSpan("redis");
    try {
        newSpan.tag("redis.op", "get");
        newSpan.tag("lc", "redis");
        newSpan.logEvent(org.springframework.cloud.sleuth.Span.CLIENT_SEND);
        // call redis service e.g
        // return (SomeObj) redisTemplate.opsForHash().get("MYHASH", someObjKey);
    } finally {
        newSpan.tag("peer.service", "redisService");
        newSpan.tag("peer.ipv4", "1.2.3.4");
        newSpan.tag("peer.port", "1234");
        newSpan.logEvent(org.springframework.cloud.sleuth.Span.CLIENT_RECV);
        tracer.close(newSpan);
    }



















<td class="content">Remember not to add both `peer.service` tag and the `SA` tag! You have to add only `peer.service`.













### Custom service name



By default Sleuth assumes that when you send a span to Zipkin, you want the spanâ€™s service name to be equal to `spring.application.name` value. Thatâ€™s not always the case though. There are situations in which you want to explicitly provide a different service name for all spans coming from your application. To achieve that itâ€™s enough to just pass the following property to your application to override that value (example for `foo` service name):







    spring.zipkin.service.name: foo













## Span Data as Messages





You can accumulate and send span data over [Spring Cloud Stream](http://cloud.spring.io/spring-cloud-stream) by including the `spring-cloud-sleuth-stream` jar as a dependency, and adding a Channel Binder implementation (e.g. `spring-cloud-starter-stream-rabbit` for RabbitMQ or `spring-cloud-starter-stream-kafka` for Kafka). This will automatically turn your app into a producer of messages with payload type `Spans`.





### Zipkin Consumer



There is a special convenience annotation for setting up a message consumer for the Span data and pushing it into a Zipkin `SpanStore`. This application







    @SpringBootApplication
    @EnableZipkinStreamServer
    public class Consumer {
    	public static void main(String[] args) {
    		SpringApplication.run(Consumer.class, args);
    	}
    }







will listen for the Span data on whatever transport you provide via a Spring Cloud Stream `Binder` (e.g. include `spring-cloud-starter-stream-rabbit` for RabbitMQ, and similar starters exist for Redis and Kafka). If you add the following UI dependency







    <groupId>io.zipkin.java</groupId>
    <artifactId>zipkin-autoconfigure-ui</artifactId>







Then youâ€™ll have your app a [Zipkin server](https://github.com/openzipkin/zipkin), which hosts the UI and api on port 9411.





The default `SpanStore` is in-memory (good for demos and getting started quickly). For a more robust solution you can add MySQL and `spring-boot-starter-jdbc` to your classpath and enable the JDBC `SpanStore` via configuration, e.g.:







    spring:
      rabbitmq:
        host: ${RABBIT_HOST:localhost}
      datasource:
        schema: classpath:/mysql.sql
        url: jdbc:mysql://${MYSQL_HOST:localhost}/test
        username: root
        password: root
    # Switch this on to create the schema on startup:
        initialize: true
        continueOnError: true
      sleuth:
        enabled: false
    zipkin:
      storage:
        type: mysql



















<td class="content">The `@EnableZipkinStreamServer` is also annotated with `@EnableZipkinServer` so the process will also expose the standard Zipkin server endpoints for collecting spans over HTTP, and for querying in the Zipkin Web UI.













### Custom Consumer



A custom consumer can also easily be implemented using `spring-cloud-sleuth-stream` and binding to the `SleuthSink`. Example:







    @EnableBinding(SleuthSink.class)
    @SpringBootApplication(exclude = SleuthStreamAutoConfiguration.class)
    @MessageEndpoint
    public class Consumer {

        @ServiceActivator(inputChannel = SleuthSink.INPUT)
        public void sink(Spans input) throws Exception {
            // ... process spans
        }
    }



















<td class="content">the sample consumer application above explicitly excludes `SleuthStreamAutoConfiguration` so it doesnâ€™t send messages to itself, but this is optional (you might actually want to trace requests into the consumer app).

















## Metrics





Currently Spring Cloud Sleuth registers very simple metrics related to spans. Itâ€™s using the [Spring Bootâ€™s metrics support](http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html#production-ready-recording-metrics) to calculate the number of accepted and dropped spans. Each time a span gets sent to Zipkin the number of accepted spans will increase. If thereâ€™s an error then the number of dropped spans will get increased.









## Integrations





### Runnable and Callable



If youâ€™re wrapping your logic in `Runnable` or `Callable` itâ€™s enough to wrap those classes in their Sleuth representative.





Example for `Runnable`:







    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            // do some work
        }

        @Override
        public String toString() {
            return "spanNameFromToStringMethod";
        }
    };
    // Manual `TraceRunnable` creation with explicit "calculateTax" Span name
    Runnable traceRunnable = new TraceRunnable(tracer, spanNamer, runnable, "calculateTax");
    // Wrapping `Runnable` with `Tracer`. The Span name will be taken either from the
    // `@SpanName` annotation or from `toString` method
    Runnable traceRunnableFromTracer = tracer.wrap(runnable);







Example for `Callable`:







    Callable<String> callable = new Callable<String>() {
        @Override
        public String call() throws Exception {
            return someLogic();
        }

        @Override
        public String toString() {
            return "spanNameFromToStringMethod";
        }
    };
    // Manual `TraceCallable` creation with explicit "calculateTax" Span name
    Callable<String> traceCallable = new TraceCallable<>(tracer, spanNamer, callable, "calculateTax");
    // Wrapping `Callable` with `Tracer`. The Span name will be taken either from the
    // `@SpanName` annotation or from `toString` method
    Callable<String> traceCallableFromTracer = tracer.wrap(callable);







That way you will ensure that a new Span is created and closed for each execution.







### Hystrix



#### Custom Concurrency Strategy



Weâ€™re registering a custom [`HystrixConcurrencyStrategy`](https://github.com/Netflix/Hystrix/wiki/Plugins#concurrencystrategy) that wraps all `Callable` instances into their Sleuth representative - the `TraceCallable`. The strategy either starts or continues a span depending on the fact whether tracing was already going on before the Hystrix command was called. To disable the custom Hystrix Concurrency Strategy set the `spring.sleuth.hystrix.strategy.enabled` to `false`.







#### Manual Command setting



Assuming that you have the following `HystrixCommand`:







    HystrixCommand<String> hystrixCommand = new HystrixCommand<String>(setter) {
        @Override
        protected String run() throws Exception {
            return someLogic();
        }
    };







In order to pass the tracing information you have to wrap the same logic in the Sleuth version of the `HystrixCommand` which is the `TraceCommand`:







    TraceCommand<String> traceCommand = new TraceCommand<String>(tracer, traceKeys, setter) {
        @Override
        public String doRun() throws Exception {
            return someLogic();
        }
    };











### RxJava



Weâ€™re registering a custom [`RxJavaSchedulersHook`](https://github.com/ReactiveX/RxJava/wiki/Plugins#rxjavaschedulershook) that wraps all `Action0` instances into their Sleuth representative - the `TraceAction`. The hook either starts or continues a span depending on the fact whether tracing was already going on before the Action was scheduled. To disable the custom RxJavaSchedulersHook set the `spring.sleuth.rxjava.schedulers.hook.enabled` to `false`.





You can define a list of regular expressions for thread names, for which you donâ€™t want a Span to be created. Just provide a comma separated list of regular expressions in the `spring.sleuth.rxjava.schedulers.ignoredthreads` property.







### HTTP integration



Features from this section can be disabled by providing the `spring.sleuth.web.enabled` property with value equal to `false`.





#### HTTP Filter



Via the `TraceFilter` all sampled incoming requests result in creation of a Span. That Spanâ€™s name is `http:` + the path to which the request was sent. E.g. if the request was sent to `/foo/bar` then the name will be `http:/foo/bar`. You can configure which URIs you would like to skip via the `spring.sleuth.web.skipPattern` property. If you have `ManagementServerProperties` on classpath then its value of `contextPath` gets appended to the provided skip pattern.







#### HandlerInterceptor



Since we want the span names to be precise weâ€™re using a `TraceHandlerInterceptor` that either wraps an existing `HandlerInterceptor` or is added directly to the list of existing `HandlerInterceptors`. The `TraceHandlerInterceptor` adds a special request attribute to the given `HttpServletRequest`. If the the `TraceFilter` doesnâ€™t see this attribute set it will create a "fallback" span which is an additional span created on the server side so that the trace is presented properly in the UI. Seeing that most likely signifies that there is a missing instrumentation. In that case please file an issue in Spring Cloud Sleuth.







#### Async Servlet support



If your controller returns a `Callable` or a `WebAsyncTask` Spring Cloud Sleuth will continue the existing span instead of creating a new one.









### HTTP client integration



#### Synchronous Rest Template



Weâ€™re injecting a `RestTemplate` interceptor that ensures that all the tracing information is passed to the requests. Each time a call is made a new Span is created. It gets closed upon receiving the response. In order to block the synchronous `RestTemplate` features just set `spring.sleuth.web.client.enabled` to `false`.

















<td class="content">You have to register `RestTemplate` as a bean so that the interceptors will get injected. If you create a `RestTemplate` instance with a `new` keyword then the instrumentation WILL NOT work.













#### Asynchronous Rest Template















<td class="content">A traced version of an `AsyncRestTemplate` bean is registered for you out of the box. If you have your own bean you have to wrap it in a `TraceAsyncRestTemplate` representation. The best solution is to only customize the `ClientHttpRequestFactory` and / or `AsyncClientHttpRequestFactory`. **If you have your own `AsyncRestTemplate` and you donâ€™t wrap it your calls WILL NOT GET TRACED**.











Custom instrumentation is set to create and close Spans upon sending and receiving requests. You can customize the `ClientHttpRequestFactory` and the `AsyncClientHttpRequestFactory` by registering your beans. Remember to use tracing compatible implementations (e.g. donâ€™t forget to wrap `ThreadPoolTaskScheduler` in a `TraceAsyncListenableTaskExecutor`). Example of custom request factories:







    @EnableAutoConfiguration
    @Configuration
    public static class TestConfiguration {

        @Bean
        ClientHttpRequestFactory mySyncClientFactory() {
            return new MySyncClientHttpRequestFactory();
        }

        @Bean
        AsyncClientHttpRequestFactory myAsyncClientFactory() {
            return new MyAsyncClientHttpRequestFactory();
        }
    }







To block the `AsyncRestTemplate` features set `spring.sleuth.web.async.client.enabled` to `false`. To disable creation of the default `TraceAsyncClientHttpRequestFactoryWrapper` set `spring.sleuth.web.async.client.factory.enabled` to `false`. If you donâ€™t want to create `AsyncRestClient` at all set `spring.sleuth.web.async.client.template.enabled` to `false`.









### Feign



By default Spring Cloud Sleuth provides integration with feign via the `TraceFeignClientAutoConfiguration`. You can disable it entirely by setting `spring.sleuth.feign.enabled` to false. If you do so then no Feign related instrumentation will take place.





Part of Feign instrumentation is done via a `FeignBeanPostProcessor`. You can disable it by providing the `spring.sleuth.feign.processor.enabled` equal to `false`. If you set it like this then Spring Cloud Sleuth will not instrument any of your custom Feign components. All the default instrumentation however will be still there.







### Asynchronous communication



#### @Async annotated methods



In Spring Cloud Sleuth weâ€™re instrumenting async related components so that the tracing information is passed between threads. You can disable this behaviour by setting the value of `spring.sleuth.async.enabled` to `false`.





If you annotate your method with `@Async` then weâ€™ll automatically create a new Span with the following characteristics:





*   the Span name will be the annotated method name

*   the Span will be tagged with that methodâ€™s class name and the method name too







#### @Scheduled annotated methods



In Spring Cloud Sleuth weâ€™re instrumenting scheduled method execution so that the tracing information is passed between threads. You can disable this behaviour by setting the value of `spring.sleuth.scheduled.enabled` to `false`.





If you annotate your method with `@Scheduled` then weâ€™ll automatically create a new Span with the following characteristics:





*   the Span name will be the annotated method name

*   the Span will be tagged with that methodâ€™s class name and the method name too





If you want to skip Span creation for some `@Scheduled` annotated classes you can set the `spring.sleuth.scheduled.skipPattern` with a regular expression that will match the fully qualified name of the `@Scheduled` annotated class.

















<td class="content">If you are using `spring-cloud-sleuth-stream` and `spring-cloud-netflix-hystrix-stream` together, Span will be created for each Hystrix metrics and sent to Zipkin. This may be annoying. You can prevent this by setting `spring.sleuth.scheduled.skipPattern=org.springframework.cloud.netflix.hystrix.stream.HystrixStreamTask`













#### Executor, ExecutorService and ScheduledExecutorService



Weâ€™re providing `LazyTraceExecutor`, `TraceableExecutorService` and `TraceableScheduledExecutorService`. Those implementations are creating Spans each time a new task is submitted, invoked or scheduled.





Here you can see an example of how to pass tracing information with `TraceableExecutorService` when working with `CompletableFuture`:







    CompletableFuture<Long> completableFuture = CompletableFuture.supplyAsync(() -> {
        // perform some logic
        return 1_000_000L;
    }, new TraceableExecutorService(executorService,
            // 'calculateTax' explicitly names the span - this param is optional
            tracer, traceKeys, spanNamer, "calculateTax"));











### Messaging



Spring Cloud Sleuth integrates with [Spring Integration](http://projects.spring.io/spring-integration/). It creates spans for publish and subscribe events. To disable Spring Integration instrumentation, set `spring.sleuth.integration.enabled` to false.





Spring Cloud Sleuth up till version 1.0.4 is sending invalid tracing headers when using messaging. Those headers are actually the same as the ones sent in HTTP (they contain a `-`) in its name. For the sake of backwards compatibility in 1.0.4 weâ€™ve started sending both valid and invalid headers. Please upgrade to 1.0.4 because in Spring Cloud Sleuth 1.1 we will remove the support for the deprecated headers.





Since 1.0.4 you can provide the `spring.sleuth.integration.patterns` pattern to explicitly provide the names of channels that you want to include for tracing. By default all channels are included.







### Zuul



Weâ€™re registering Zuul filters to propagate the tracing information (the request header is enriched with tracing data). To disable Zuul support set the `spring.sleuth.zuul.enabled` property to `false`.











## Running examples





You can find the running examples deployed in the [Pivotal Web Services](https://run.pivotal.io/). Check them out in the following links:





*   [Zipkin for apps presented in the samples to the top](https://docssleuth-zipkin-server.cfapps.io/)

*   [Zipkin for Brewery on PWS](https://docsbrewing-zipkin-web.cfapps.io/), its [Github Code](https://github.com/spring-cloud-samples/brewery)







# Spring Cloud Consul









## Install Consul





Please see the [installation documentation](https://www.consul.io/intro/getting-started/install.html) for instructions on how to install Consul.









## Consul Agent





A Consul Agent client must be available to all Spring Cloud Consul applications. By default, the Agent client is expected to be at `localhost:8500`. See the [Agent documentation](https://consul.io/docs/agent/basics.html) for specifics on how to start an Agent client and how to connect to a cluster of Consul Agent Servers. For development, after you have installed consul, you may start a Consul Agent using the following command:







<pre>./src/main/bash/local_run_consul.sh</pre>







This will start an agent in server mode on port 8500, with the ui available at [http://localhost:8500](http://localhost:8500/)









## Service Discovery with Consul





Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle. Consul provides Service Discovery services via an [HTTP API](https://www.consul.io/docs/agent/http.html) and [DNS](https://www.consul.io/docs/agent/dns.html). Spring Cloud Consul leverages the HTTP API for service registration and discovery. This does not prevent non-Spring Cloud applications from leveraging the DNS interface. Consul Agents servers are run in a [cluster](https://www.consul.io/docs/internals/architecture.html) that communicates via a [gossip protocol](https://www.consul.io/docs/internals/gossip.html) and uses the [Raft consensus protocol](https://www.consul.io/docs/internals/consensus.html).





### Registering with Consul



When a client registers with Consul, it provides meta-data about itself such as host and port, id, name and tags. An HTTP [Check](https://www.consul.io/docs/agent/checks.html) is created by default that Consul hits the `/health` endpoint every 10 seconds. If the health check fails, the service instance is marked as critical.





Example Consul client:







    @SpringBootApplication
    @EnableDiscoveryClient
    @RestController
    public class Application {

        @RequestMapping("/")
        public String home() {
            return "Hello world";
        }

        public static void main(String[] args) {
            new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

    }







(i.e. utterly normal Spring Boot app). If the Consul client is located somewhere other than `localhost:8500`, the configuration is required to locate the client. Example:









<pre>spring:
  cloud:
    consul:
      host: localhost
      port: 8500</pre>



















<td class="content">If you use [Spring Cloud Consul Config](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-consul-config), the above values will need to be placed in `bootstrap.yml` instead of `application.yml`.











The default service name, instance id and port, taken from the `Environment`, are `${spring.application.name}`, the Spring Context ID and `${server.port}` respectively.





`@EnableDiscoveryClient` make the app into both a Consul "service" (i.e. it registers itself) and a "client" (i.e. it can query Consul to locate other services).







### HTTP Health Check



The health check for a Consul instance defaults to "/health", which is the default locations of a useful endpoint in a Spring Boot Actuator application. You need to change these, even for an Actuator application if you use a non-default context path or servlet path (e.g. `server.servletPath=/foo`) or management endpoint path (e.g. `management.contextPath=/admin`). The interval that Consul uses to check the health endpoint may also be configured. "10s" and "1m" represent 10 seconds and 1 minute respectively. Example:









<pre>spring:
  cloud:
    consul:
      discovery:
        healthCheckPath: ${management.contextPath}/health
        healthCheckInterval: 15s</pre>







#### Metadata and Consul tags



Consul does not yet support metadata on services. Spring Cloudâ€™s `ServiceInstance` has a `Map<String, String> metadata` field. Spring Cloud Consul uses Consul tags to approximate metadata until Consul officially supports metadata. Tags with the form `key=value` will be split and used as a `Map` key and value respectively. Tags without the equal `=` sign, will be used as both the key and value.









<pre>spring:
  cloud:
    consul:
      discovery:
        tags: foo=bar, baz</pre>







The above configuration will result in a map with `fooâ†’bar` and `bazâ†’baz`.







#### Making the Consul Instance ID Unique



By default a consul instance is registered with an ID that is equal to its Spring Application Context ID. By default, the Spring Application Context ID is `${spring.application.name}:comma,separated,profiles:${server.port}`. For most cases, this will allow multiple instances of one service to run on one machine. If further uniqueness is required, Using Spring Cloud you can override this by providing a unique identifier in `spring.cloud.consul.discovery.instanceId`. For example:









<pre>spring:
  cloud:
    consul:
      discovery:
        instanceId: ${spring.application.name}:${spring.application.instance_id:${random.value}}</pre>







With this metadata, and multiple service instances deployed on localhost, the random value will kick in there to make the instance unique. In Cloudfoundry the `spring.application.instance_id` will be populated automatically in a Spring Boot Actuator application, so the random value will not be needed.









### Using the DiscoveryClient



Spring Cloud has support for [Feign](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign) (a REST client builder) and also [Spring `RestTemplate`](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon) using the logical service names instead of physical URLs.





You can also use the `org.springframework.cloud.client.discovery.DiscoveryClient` which provides a simple API for discovery clients that is not specific to Netflix, e.g.







<pre>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List<ServiceInstance> list = discoveryClient.getInstances("STORES");
    if (list != null && list.size() > 0 ) {
        return list.get(0).getUri();
    }
    return null;
}</pre>













## Distributed Configuration with Consul





Consul provides a [Key/Value Store](https://consul.io/docs/agent/http/kv.html) for storing configuration and other metadata. Spring Cloud Consul Config is an alternative to the [Config Server and Client](https://github.com/spring-cloud/spring-cloud-config). Configuration is loaded into the Spring Environment during the special "bootstrap" phase. Configuration is stored in the `/config` folder by default. Multiple `PropertySource` instances are created based on the applicationâ€™s name and the active profiles that mimicks the Spring Cloud Config order of resolving properties. For example, an application with the name "testApp" and with the "dev" profile will have the following property sources created:







<pre>config/testApp,dev/
config/testApp/
config/application,dev/
config/application/</pre>







The most specific property source is at the top, with the least specific at the bottom. Properties is the `config/application` folder are applicable to all applications using consul for configuration. Properties in the `config/testApp` folder are only available to the instances of the service named "testApp".





Configuration is currently read on startup of the application. Sending a HTTP POST to `/refresh` will cause the configuration to be reloaded. Watching the key value store (which Consul supports) is not currently possible, but will be a future addition to this project.





### How to activate



Including a dependency on `org.springframework.cloud:spring-cloud-consul-config` will enable auto-configuration that will setup Spring Cloud Consul Config.







### Customizing



Consul Config may be customized using the following properties:









<pre>spring:
  cloud:
    consul:
      config:
        enabled: true
        prefix: configuration
        defaultContext: apps
        profileSeparator: '::'</pre>







*   `enabled` setting this value to "false" disables Consul Config

*   `prefix` sets the base folder for configuration values

*   `defaultContext` sets the folder name used by all applications

*   `profileSeparator` sets the value of the separator used to separate the profile name in property sources with profiles











## YAML or Properties with Config





It may be more convenient to store a blob of properties in YAML or Properties format as opposed to individual key/value pairs. Set the `spring.cloud.consul.config.format` property to `YAML` or `PROPERTIES`. For example to use YAML:









<pre>spring:
  cloud:
    consul:
      config:
        format: YAML</pre>







YAML must be set in the appropriate `data` key in consul. Using the defaults above the keys would look like:







<pre>config/testApp,dev/data
config/testApp/data
config/application,dev/data
config/application/data</pre>







You could store a YAML document in any of the keys listed above.





You can change the data key using `spring.cloud.consul.config.data-key`.









## git2consul with Config





git2consul is a Consul community project that loads files from a git repository to individual keys into Consul. By default the names of the keys are names of the files. YAML and Properties files are supported with file extensions of `.yml` and `.properties` respectively. Set the `spring.cloud.consul.config.format` property to `FILES`. For example:









<pre>spring:
  cloud:
    consul:
      config:
        format: FILES</pre>







Given the following keys in `/config`, the `development` profile and an application name of `foo`:







<pre>.gitignore
application.yml
bar.properties
foo-development.properties
foo-production.yml
foo.properties
master.ref</pre>







the following property sources would be created:







<pre>config/foo-development.properties
config/foo.properties
config/application.yml</pre>







The value of each key needs to be a properly formatted YAML or Properties file.









## Fail Fast





It may be convenient in certain circumstances (like local development or certain test scenarios) to not fail if consul isnâ€™t available for configuration. Setting `spring.cloud.consul.config.failFast=false` in `bootstrap.yml` will cause the configuration module to log a warning rather than throw an exception. This will allow the application to continue startup normally.









## Consul Retry





If you expect that the consul agent may occasionally be unavailable when your app starts, you can ask it to keep trying after a failure. You need to add `spring-retry` and `spring-boot-starter-aop` to your classpath. The default behaviour is to retry 6 times with an initial backoff interval of 1000ms and an exponential multiplier of 1.1 for subsequent backoffs. You can configure these properties (and others) using `spring.cloud.consul.retry.*` configuration properties. This works with both Spring Cloud Consul Config and Discovery registration.

















<td class="content">To take full control of the retry add a `@Bean` of type `RetryOperationsInterceptor` with id "consulRetryInterceptor". Spring Retry has a `RetryInterceptorBuilder` that makes it easy to create one.















## Spring Cloud Bus with Consul





Coming in a later release.









## Circuit Breaker with Hystrix





Applications can use the Hystrix Circuit Breaker provided by the Spring Cloud Netflix project by including this starter in the projects pom.xml: `spring-cloud-starter-hystrix`. Hystrix doesnâ€™t depend on the Netflix Discovery Client. The `@EnableHystrix` annotation should be placed on a configuration class (usually the main class). Then methods can be annotated with `@HystrixCommand` to be protected by a circuit breaker. See [the documentation](http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients) for more details.









## Hystrix metrics aggregation with Turbine and Consul





Turbine (provided by the Spring Cloud Netflix project), aggregates multiple instances Hystrix metrics streams, so the dashboard can display an aggregate view. Turbine uses the `DiscoveryClient` interface to lookup relevant instances. To use Turbine with Spring Cloud Consul, configure the Turbine application in a manner similar to the following examples:









<pre><dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-netflix-turbine</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency></pre>







Notice that the Turbine dependency is not a starter. The turbine starter includes support for Netflix Eureka.









<pre>spring.application.name: turbine
applications: consulhystrixclient
turbine:
  aggregator:
    clusterConfig: ${applications}
  appConfig: ${applications}</pre>







The `clusterConfig` and `appConfig` sections must match, so itâ€™s useful to put the comma-separated list of service IDâ€™s into a separate configuration property.









<pre>@EnableTurbine
@EnableDiscoveryClient
@SpringBootApplication
public class Turbine {
    public static void main(String[] args) {
        SpringApplication.run(DemoturbinecommonsApplication.class, args);
    }
}</pre>









# Spring Cloud Zookeeper









## Install Zookeeper





Please see the [installation documentation](https://zookeeper.apache.org/doc/current/zookeeperStarted.html) for instructions on how to install Zookeeper.









## Service Discovery with Zookeeper





Service Discovery is one of the key tenets of a microservice based architecture. Trying to hand configure each client or some form of convention can be very difficult to do and can be very brittle. [Curator](https://curator.apache.org/)(A java library for Zookeeper) provides Service Discovery services via [Service Discovery Extension](https://curator.apache.org/curator-x-discovery/). Spring Cloud Zookeeper leverages this extension for service registration and discovery.





### How to activate



Including a dependency on `org.springframework.cloud:spring-cloud-starter-zookeeper-discovery` will enable auto-configuration that will setup Spring Cloud Zookeeper Discovery.







### Registering with Zookeeper



When a client registers with Zookeeper, it provides meta-data about itself such as host and port, id and name.





Example Zookeeper client:







    @SpringBootApplication
    @EnableDiscoveryClient
    @RestController
    public class Application {

        @RequestMapping("/")
        public String home() {
            return "Hello world";
        }

        public static void main(String[] args) {
            new SpringApplicationBuilder(Application.class).web(true).run(args);
        }

    }







(i.e. utterly normal Spring Boot app). If Zookeeper is located somewhere other than `localhost:2181`, the configuration is required to locate the server. Example:









<pre>spring:
  cloud:
    zookeeper:
      connect-string: localhost:2181</pre>



















<td class="content">If you use [Spring Cloud Zookeeper Config](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-zookeeper-config), the above values will need to be placed in `bootstrap.yml` instead of `application.yml`.











The default service name, instance id and port, taken from the `Environment`, are `${spring.application.name}`, the Spring Context ID and `${server.port}` respectively.





`@EnableDiscoveryClient` makes the app into both a Zookeeper "service" (i.e. it registers itself) and a "client" (i.e. it can query Zookeeper to locate other services).







### Using the DiscoveryClient



Spring Cloud has support for [Feign](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign) (a REST client builder) and also [Spring `RestTemplate`](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon) using the logical service names instead of physical URLs.





You can also use the `org.springframework.cloud.client.discovery.DiscoveryClient` which provides a simple API for discovery clients that is not specific to Netflix, e.g.







<pre>@Autowired
private DiscoveryClient discoveryClient;

public String serviceUrl() {
    List<ServiceInstance> list = discoveryClient.getInstances("STORES");
    if (list != null && list.size() > 0 ) {
        return list.get(0).getUri().toString();
    }
    return null;
}</pre>













## Zookeeper Dependencies





### Using the Zookeeper Dependencies



Spring Cloud Zookeeper gives you a possibility to provide dependencies of your application as properties. As dependencies you can understand other applications that are registered in Zookeeper and which you would like to call via [Feign](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-feign) (a REST client builder) and also [Spring `RestTemplate`](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc#spring-cloud-ribbon).





You can also benefit from the Zookeeper Dependency Watchers functionality that lets you control and monitor what is the state of your dependencies and decide what to do with that.







### How to activate Zookeeper Dependencies



*   Including a dependency on `org.springframework.cloud:spring-cloud-starter-zookeeper-discovery` will enable auto-configuration that will setup Spring Cloud Zookeeper Dependencies.

*   If you have to have the `spring.cloud.zookeeper.dependencies` section properly set up - check the subsequent section for more details then the feature is active

*   You can have the dependencies turned off even if youâ€™ve provided the dependencies in your properties. Just set the property `spring.cloud.zookeeper.dependency.enabled` to false (defaults to `true`).







### Setting up Zookeeper Dependencies



Letâ€™s take a closer look at an example of dependencies representation:









<pre>spring.application.name: yourServiceName
spring.cloud.zookeeper:
  dependencies:
    newsletter:
      path: /path/where/newsletter/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.newsletter.$version+json
      version: v1
      headers:
        header1:
            - value1
        header2:
            - value2
      required: false
      stubs: org.springframework:foo:stubs
    mailing:
      path: /path/where/mailing/has/registered/in/zookeeper
      loadBalancerType: ROUND_ROBIN
      contentTypeTemplate: application/vnd.mailing.$version+json
      version: v1
      required: true</pre>







Letâ€™s now go through each part of the dependency one by one. The root property name is `spring.cloud.zookeeper.dependencies`.





#### Aliases



Below the root property you have to represent each dependency has by an alias due to the constraints of Ribbon (the application id has to be placed in the URL thus you canâ€™t pass any complex path like /foo/bar/name). The alias will be the name that you will use instead of serviceId for `DiscoveryClient`, `Feign` or `RestTemplate`.





In the aforementioned examples the aliases are `newsletter` and `mailing`. Example of Feign usage with `newsletter` would be:







<pre>@FeignClient("newsletter")
public interface NewsletterService {
        @RequestMapping(method = RequestMethod.GET, value = "/newsletter")
        String getNewsletters();
}</pre>









#### Path



Represented by `path` yaml property.





Path is the path under which the dependency is registered under Zookeeper. Like presented before Ribbon operates on URLs thus this path is not compliant with its requirement. That is why Spring Cloud Zookeeper maps the alias to the proper path.







#### Load balancer type



Represented by `loadBalancerType` yaml property.





If you know what kind of load balancing strategy has to be applied when calling this particular dependency then you can provide it in the yaml file and it will be automatically applied. You can choose one of the following load balancing strategies





*   STICKY - once chosen the instance will always be called

*   RANDOM - picks an instance randomly

*   ROUND_ROBIN - iterates over instances over and over again







#### Content-Type template and version



Represented by `contentTypeTemplate` and `version` yaml property.





If you version your api via the `Content-Type` header then you donâ€™t want to add this header to each of your requests. Also if you want to call a new version of the API you donâ€™t want to roam around your code to bump up the API version. Thatâ€™s why you can provide a `contentTypeTemplate` with a special `$version` placeholder. That placeholder will be filled by the value of the `version` yaml property. Letâ€™s take a look at an example.





Having the following `contentTypeTemplate`:







<pre>application/vnd.newsletter.$version+json</pre>







and the following `version`:







<pre>v1</pre>







Will result in setting up of a `Content-Type` header for each request:







<pre>application/vnd.newsletter.v1+json</pre>









#### Default headers



Represented by `headers` map in yaml





Sometimes each call to a dependency requires setting up of some default headers. In order not to do that in code you can set them up in the yaml file. Having the following `headers` section:







<pre>headers:
    Accept:
        - text/html
        - application/xhtml+xml
    Cache-Control:
        - no-cache</pre>







Results in adding the `Accept` and `Cache-Control` headers with appropriate list of values in your HTTP request.







#### Obligatory dependencies



Represented by `required` property in yaml





If one of your dependencies is required to be up and running when your application is booting then itâ€™s enough to set up the `required: true` property in the yaml file.





If your application canâ€™t localize the required dependency during boot time it will throw an exception and the Spring Context will fail to set up. In other words your application wonâ€™t be able to start if the required dependency is not registered in Zookeeper.





You can read more about Spring Cloud Zookeeper Presence Checker in the following sections.







#### Stubs



You can provide a colon separated path to the JAR containing stubs of the dependency. Example







    stubs: org.springframework:foo:stubs







means that for a particular dependencies can be found under:





*   groupId: `org.springframework`

*   artifactId: `foo`

*   classifier: `stubs` - this is the default value





This is actually equal to







    stubs: org.springframework:foo







since `stubs` is the default classifier.









### Configuring Spring Cloud Zookeeper Dependencies



There is a bunch of properties that you can set to enable / disable parts of Zookeeper Dependencies functionalities.





*   `spring.cloud.zookeeper.dependencies` - if you donâ€™t set this property you wonâ€™t benefit from Zookeeper Dependencies

*   `spring.cloud.zookeeper.dependency.ribbon.enabled` (enabled by default) - Ribbon requires explicit global configuration or a particular one for a dependency. By turning on this property runtime load balancing strategy resolution is possible and you can profit from the `loadBalancerType` section of the Zookeeper Dependencies. The configuration that needs this property has an implementation of `LoadBalancerClient` that delegates to the `ILoadBalancer` presented in the next bullet

*   `spring.cloud.zookeeper.dependency.ribbon.loadbalancer` (enabled by default) - thanks to this property the custom `ILoadBalancer` knows that the part of the URI passed to Ribbon might actually be the alias that has to be resolved to a proper path in Zookeeper. Without this property you wonâ€™t be able to register applications under nested paths.

*   `spring.cloud.zookeeper.dependency.headers.enabled` (enabled by default) - this property registers such a `RibbonClient` that automatically will append appropriate headers and content types with version as presented in the Dependency configuration. Without this setting of those two parameters will not be operational.

*   `spring.cloud.zookeeper.dependency.resttemplate.enabled` (enabled by default) - when enabled will modify the request headers of `@LoadBalanced` annotated `RestTemplate` so that it passes headers and content type with version set in Dependency configuration. Wihtout this setting of those two parameters will not be operational.











## Spring Cloud Zookeeper Dependency Watcher





The Dependency Watcher mechanism allows you to register listeners to your dependencies. The functionality is in fact an implementation of the `Observator` pattern. When a dependency changes its state (UP or DOWN) then some custom logic can be applied.





### How to activate



Spring Cloud Zookeeper Dependencies functionality needs to be enabled to profit from Dependency Watcher mechanism.







### Registering a listener



In order to register a listener you have to implement an interface `org.springframework.cloud.zookeeper.discovery.watcher.DependencyWatcherListener` and register it as a bean. The interface gives you one method:







<pre>    void stateChanged(String dependencyName, DependencyState newState);</pre>







If you want to register a listener for a particular dependency then the `dependencyName` would be the discriminator for your concrete implementation. `newState` will provide you with information whether your dependency has changed to `CONNECTED` or `DISCONNECTED`.







### Presence Checker



Bound with Dependency Watcher is the functionality called Presence Checker. It allows you to provide custom behaviour upon booting of your application to react accordingly to the state of your dependencies.





The default implementation of the abstract `org.springframework.cloud.zookeeper.discovery.watcher.presence.DependencyPresenceOnStartupVerifier` class is the `org.springframework.cloud.zookeeper.discovery.watcher.presence.DefaultDependencyPresenceOnStartupVerifier` which works in the following way.





*   If the dependency is marked us `required` and itâ€™s not in Zookeeper then upon booting your application will throw an exception and shutdown

*   If dependency is not `required` the `org.springframework.cloud.zookeeper.discovery.watcher.presence.LogMissingDependencyChecker` will log that application is missing at `WARN` level





The functionality can be overriden since the `DefaultDependencyPresenceOnStartupVerifier` is registered only when there is no bean of `DependencyPresenceOnStartupVerifier`.











## Distributed Configuration with Zookeeper





Zookeeper provides a [hierarchical namespace](https://zookeeper.apache.org/doc/current/zookeeperOver.html#sc_dataModelNameSpace) that allows clients to store arbitrary data, such as configuration data. Spring Cloud Zookeeper Config is an alternative to the [Config Server and Client](https://github.com/spring-cloud/spring-cloud-config). Configuration is loaded into the Spring Environment during the special "bootstrap" phase. Configuration is stored in the `/config` namespace by default. Multiple `PropertySource` instances are created based on the applicationâ€™s name and the active profiles that mimicks the Spring Cloud Config order of resolving properties. For example, an application with the name "testApp" and with the "dev" profile will have the following property sources created:







<pre>config/testApp,dev
config/testApp
config/application,dev
config/application</pre>







The most specific property source is at the top, with the least specific at the bottom. Properties is the `config/application` namespace are applicable to all applications using zookeeper for configuration. Properties in the `config/testApp` namespace are only available to the instances of the service named "testApp".





Configuration is currently read on startup of the application. Sending a HTTP POST to `/refresh` will cause the configuration to be reloaded. Watching the configuration namespace (which Zookeeper supports) is not currently implemented, but will be a future addition to this project.





### How to activate



Including a dependency on `org.springframework.cloud:spring-cloud-starter-zookeeper-config` will enable auto-configuration that will setup Spring Cloud Zookeeper Config.







### Customizing



Zookeeper Config may be customized using the following properties:









<pre>spring:
  cloud:
    zookeeper:
      config:
        enabled: true
        root: configuration
        defaultContext: apps
        profileSeparator: '::'</pre>







*   `enabled` setting this value to "false" disables Zookeeper Config

*   `root` sets the base namespace for configuration values

*   `defaultContext` sets the name used by all applications

*   `profileSeparator` sets the value of the separator used to separate the profile name in property sources with profiles









# Spring Boot Cloud CLI









## Installation





To install, make sure you have [Spring Boot CLI](https://github.com/spring-projects/spring-boot) (1.4.1 or better):







<pre>$ spring version
Spring CLI v1.4.1.RELEASE</pre>







E.g. for SDKMan users







    $ sdk install springboot 1.4.1.RELEASE
    $ sdk use springboot 1.4.1.RELEASE







and install the Spring Cloud plugin







    $ mvn install
    $ spring install org.springframework.cloud:spring-cloud-cli:1.2.3.BUILD-SNAPSHOT



















<td class="content">**Prerequisites:** to use the encryption and decryption features you need the full-strength JCE installed in your JVM (itâ€™s not there by default). You can download the "Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files" from Oracle, and follow instructions for installation (essentially replace the 2 policy files in the JRE lib/security directory with the ones that you downloaded).















## Running Spring Cloud Services in Development





The Launcher CLI can be used to run common services like Eureka, Config Server etc. from the command line. To list the available services you can do `spring cloud --list`, and to launch a default set of services just `spring cloud`. To choose the services to deploy, just list them on the command line, e.g.







<pre>$ spring cloud eureka configserver h2 kafka zipkin</pre>







Summary of supported deployables:



<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"> <col style="width: 25%;"></colgroup>

<thead>



<th class="tableblock halign-left valign-top">Service</th>

<th class="tableblock halign-left valign-top">Name</th>

<th class="tableblock halign-left valign-top">Address</th>

<th class="tableblock halign-left valign-top">Description</th>



</thead>







eureka





Eureka Server





[http://localhost:8761](http://localhost:8761/)





Eureka server for service registration and discovery. All the other services show up in its catalog by default.









configserver





Config Server





[http://localhost:8888](http://localhost:8888/)





Spring Cloud Config Server running in the "native" profile and serving configuration from the local directory ./launcher









h2





H2 Database





[http://localhost:9095](http://localhost:9095/) (console), jdbc:h2:tcp://localhost:9096/{data}





Relation database service. Use a file path for `{data}` (e.g. `./target/test`) when you connect. Remember that you can add `;MODE=MYSQL` or `;MODE=POSTGRESQL` to connect with compatibility to other server types.









kafka





Kafka Broker





[http://localhost:9091](http://localhost:9091/) (actuator endpoints), localhost:9092









hystrixdashboard





Hystrix Dashboard





[http://localhost:7979](http://localhost:7979/)





Any Spring Cloud app that declares Hystrix circuit breakers publishes metrics on `/hystrix.stream`. Type that address into the dashboard to visualize all the metrics,









dataflow





Dataflow Server





[http://localhost:9393](http://localhost:9393/)





Spring Cloud Dataflow server with UI at /admin-ui. Connect the Dataflow shell to target at root path.









zipkin





Zipkin Server





[http://localhost:9411](http://localhost:9411/)





Zipkin Server with UI for visualizing traces. Stores span data in memory and accepts them via HTTP POST of JSON data.











Each of these apps can be configured using a local YAML file with the same name (in the current working directory or a subdirectory called "config" or in `~/.spring-cloud`). E.g. in `configserver.yml` you might want to do something like this to locate a local git repository for the backend:









    spring:
      profiles:
        active: git
      cloud:
        config:
          server:
            git:
              uri: file://${user.home}/dev/demo/config-repo







### Adding Additional Applications



Additional applications can be added to `./config/cloud.yml` (not `./config.yml` because that would replace the defaults), e.g. with









    spring:
      cloud:
        launcher:
          deployables:
            source:
              coordinates: maven://com.example:source:0.0.1-SNAPSHOT
              port: 7000
            sink:
              coordinates: maven://com.example:sink:0.0.1-SNAPSHOT
              port: 7001







when you list the apps:







    $ spring cloud --list
    source sink configserver dataflow eureka h2 hystrixdashboard kafka zipkin







(notice the additional apps at the start of the list).











## Writing Groovy Scripts and Running Applications





Spring Cloud CLI has support for most of the Spring Cloud declarative features, such as the `@Enable*` class of annotations. For example, here is a fully functional Eureka server









    @EnableEurekaServer
    class Eureka {}







which you can run from the command line like this







<pre>$ spring run app.groovy</pre>







To include additional dependencies, often it suffices just to add the appropriate feature-enabling annotation, e.g. `@EnableConfigServer`, `@EnableOAuth2Sso` or `@EnableEurekaClient`. To manually include a dependency you can use a `@Grab` with the special "Spring Boot" short style artifact co-ordinates, i.e. with just the artifact ID (no need for group or version information), e.g. to set up a client app to listen on AMQP for management events from the Spring CLoud Bus:









    @Grab('spring-cloud-starter-bus-amqp')
    @RestController
    class Service {
      @RequestMapping('/')
      def home() { [message: 'Hello'] }
    }











## Encryption and Decryption





The Spring Cloud CLI comes with an "encrypt" and a "decrypt" command. Both accept arguments in the same form with a key specified as a mandatory "--key", e.g.







<pre>$ spring encrypt mysecret --key foo
682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
$ spring decrypt --key foo 682bc583f4641835fa2db009355293665d2647dade3375c0ee201de2a49f7bda
mysecret</pre>







To use a key in a file (e.g. an RSA public key for encyption) prepend the key value with "@" and provide the file path, e.g.







<pre>$ spring encrypt mysecret --key @${HOME}/.ssh/id_rsa.pub
AQAjPgt3eFZQXwt8tsHAVv/QHiY5sI2dRcR+...</pre>









# Spring Cloud Security









## Quickstart





### OAuth2 Single Sign On



Hereâ€™s a Spring Cloud "Hello World" app with HTTP Basic authentication and a single user account:









    @Grab('spring-boot-starter-security')
    @Controller
    class Application {

      @RequestMapping('/')
      String home() {
        'Hello World'
      }

    }







You can run it with `spring run app.groovy` and watch the logs for the password (username is "user"). So far this is just the default for a Spring Boot app.





Hereâ€™s a Spring Cloud app with OAuth2 SSO:









    @Controller
    @EnableOAuth2Sso
    class Application {

      @RequestMapping('/')
      String home() {
        'Hello World'
      }

    }







Spot the difference? This app will actually behave exactly the same as the previous one, because it doesnâ€™t know itâ€™s OAuth2 credentals yet.





You can register an app in github quite easily, so try that if you want a production app on your own domain. If you are happy to test on localhost:8080, then set up these properties in your application configuration:









    spring:
      oauth2:
        client:
          clientId: bd1c0a783ccdd1c9b9e4
          clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1
          accessTokenUri: https://github.com/login/oauth/access_token
          userAuthorizationUri: https://github.com/login/oauth/authorize
          clientAuthenticationScheme: form
        resource:
          userInfoUri: https://api.github.com/user
          preferTokenInfo: false







run the app above and it will redirect to github for authorization. If you are already signed into github you wonâ€™t even notice that it has authenticated. These credentials will only work if your app is running on port 8080.





To limit the scope that the client asks for when it obtains an access token you can set `spring.oauth2.client.scope` (comma separated or an array in YAML). By default the scope is empty and it is up to to Authorization Server to decide what the defaults should be, usually depending on the settings in the client registration that it holds.

















<td class="content">The examples above are all Groovy scripts. If you want to write the same code in Java (or Groovy) you need to add Spring Security OAuth2 to the classpath (e.g. see the [sample here](https://github.com/spring-cloud-samples/sso)).













### OAuth2 Protected Resource



You want to protect an API resource with an OAuth2 token? Hereâ€™s a simple example (paired with the client above):









    @Grab('spring-cloud-starter-security')
    @RestController
    @EnableResourceServer
    class Application {

      @RequestMapping('/')
      def home() {
        [message: 'Hello World']
      }

    }







and









    spring:
      oauth2:
        resource:
          userInfoUri: https://api.github.com/user
          preferTokenInfo: false













## More Detail





### Single Sign On















<td class="content">All of the OAuth2 SSO and resource server features moved to Spring Boot in version 1.3\. You can find documentation in the [Spring Boot user guide](http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/).













### Token Relay



A Token Relay is where an OAuth2 consumer acts as a Client and forwards the incoming token to outgoing resource requests. The consumer can be a pure Client (like an SSO application) or a Resource Server.





#### Client Token Relay



If your app is a user facing OAuth2 client (i.e. has declared `@EnableOAuth2Sso` or `@EnableOAuth2Client`) then it has an `OAuth2ClientContext` in request scope from Spring Boot. You can create your own `OAuth2RestTemplate` from this context and an autowired `OAuth2ProtectedResourceDetails`, and then the context will always forward the access token downstream, also refreshing the access token automatically if it expires. (These are features of Spring Security and Spring Boot.)

















<td class="content">Spring Boot (1.4.1) does not create an `OAuth2ProtectedResourceDetails` automatically if you are using `client_credentials` tokens. In that case you need to create your own `ClientCredentialsResourceDetails` and configure it with `@ConfigurationProperties("security.oauth2.client")`.













#### Client Token Relay in Zuul Proxy



If your app also has a [Spring Cloud Zuul](http://cloud.spring.io/spring-cloud.html#netflix-zuul-reverse-proxy) embedded reverse proxy (using `@EnableZuulProxy`) then you can ask it to forward OAuth2 access tokens downstream to the services it is proxying. Thus the SSO app above can be enhanced simply like this:









    @Controller
    @EnableOAuth2Sso
    @EnableZuulProxy
    class Application {

    }







and it will (in addition to logging the user in and grabbing a token) pass the authentication token downstream to the `/proxy/*` services. If those services are implemented with `@EnableResourceServer` then they will get a valid token in the correct header.





How does it work? The `@EnableOAuth2Sso` annotation pulls in `spring-cloud-starter-security` (which you could do manually in a traditional app), and that in turn triggers some autoconfiguration for a `ZuulFilter`, which itself is activated because Zuul is on the classpath (via `@EnableZuulProxy`). The [filter](https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/OAuth2TokenRelayFilter.java) just extracts an access token from the currently authenticated user, and puts it in a request header for the downstream requests.







#### Resource Server Token Relay



If your app has `@EnableResourceServer` you might want to relay the incoming token downstream to other services. If you use a `RestTemplate` to contact the downstream services then this is just a matter of how to create the template with the right context.





If your service uses `UserInfoTokenServices` to authenticate incoming tokens (i.e. it is using the `security.oauth2.user-info-uri` configuration), then you can simply create an `OAuth2RestTemplate` using an autowired `OAuth2ClientContext` (it will be populated by the authentication process before it hits the backend code). Equivalently (with Spring Boot 1.4), you could inject a `UserInfoRestTemplateFactory` and grab its `OAuth2RestTemplate` in your configuration. For example:









    @Bean
    public OAuth2RestTemplate restTemplate(UserInfoRestTemplateFactory factory) {
        return factory.getUserInfoRestTemplate();
    }







This rest template will then have the same `OAuth2ClientContext` (request-scoped) that is used by the authentication filter, so you can use it to send requests with the same access token.





If your app is not using `UserInfoTokenServices` but is still a client (i.e. it declares `@EnableOAuth2Client` or `@EnableOAuth2Sso`), then with Spring Security Cloud any `OAuth2RestOperations` that the user creates from an `@Autowired` `@OAuth2Context` will also forward tokens. This feature is implemented by default as an MVC handler interceptor, so it only works in Spring MVC. If you are not using MVC you could use a custom filter or AOP interceptor wrapping an `AccessTokenContextRelay` to provide the same feature.





Hereâ€™s a basic example showing the use of an autowired rest template created elsewhere ("foo.com" is a Resource Server accepting the same tokens as the surrounding app):









    @Autowired
    private OAuth2RestOperations restTemplate;

    @RequestMapping("/relay")
    public String relay() {
        ResponseEntity<String> response =
          restTemplate.getForEntity("https://foo.com/bar", String.class);
        return "Success! (" + response.getBody() + ")";
    }







If you donâ€™t want to forward tokens (and that is a valid choice, since you might want to act as yourself, rather than the client that sent you the token), then you only need to create your own `OAuth2Context` instead of autowiring the default one.





Feign clients will also pick up an interceptor that uses the `OAuth2ClientContext` if it is available, so they should also do a token relay anywhere where a `RestTemplate` would.













## Configuring Authentication Downstream of a Zuul Proxy





You can control the authorization behaviour downstream of an `@EnableZuulProxy` through the `proxy.auth.*` settings. Example:









    proxy:
      auth:
        routes:
          customers: oauth2
          stores: passthru
          recommendations: none







In this example the "customers" service gets an OAuth2 token relay, the "stores" service gets a passthrough (the authorization header is just passed downstream), and the "recommendations" service has its authorization header removed. The default behaviour is to do a token relay if there is a token available, and passthru otherwise.





See [ProxyAuthenticationProperties](https://github.com/spring-cloud/spring-cloud-security/tree/master/src/main/java/org/springframework/cloud/security/oauth2/proxy/ProxyAuthenticationProperties) for full details.







# Spring Cloud for Cloud Foundry







Spring Cloud for Cloudfoundry makes it easy to run [Spring Cloud](https://github.com/spring-cloud) apps in [Cloud Foundry](https://github.com/cloudfoundry) (the Platform as a Service). Cloud Foundry has the notion of a "service", which is middlware that you "bind" to an app, essentially providing it with an environment variable containing credentials (e.g. the location and username to use for the service).





The `spring-cloud-cloudfoundry-web` project provides basic support for some enhanced features of webapps in Cloud Foundry: binding automatically to single-sign-on services and optionally enabling sticky routing for discovery.





The `spring-cloud-cloudfoundry-discovery` project provides an implementation of Spring Cloud Commons `DiscoveryClient` so you can `@EnableDiscoveryClient` and provide your credentials as `spring.cloud.cloudfoundry.discovery.[email,password]` and then you can use the `DiscoveryClient` directly or via a `LoadBalancerClient` (also `*.url` if you are not connecting to [Pivotal Web Services](https://run.pivotal.io/)).





The first time you use it the discovery client might be slow owing to the fact that it has to get an access token from Cloud Foundry.









## Discovery





Hereâ€™s a Spring Cloud app with Cloud Foundry discovery:









    @Grab('org.springframework.cloud:spring-cloud-cloudfoundry')
    @RestController
    @EnableDiscoveryClient
    class Application {

      @Autowired
      DiscoveryClient client

      @RequestMapping('/')
      String home() {
        'Hello from ' + client.getLocalServiceInstance()
      }

    }







If you run it without any service bindings:







<pre>$ spring jar app.jar app.groovy
$ cf push -p app.jar</pre>







It will show its app name in the home page.





The `DiscoveryClient` can lists all the apps in a space, according to the credentials it is authenticated with, where the space defaults to the one the client is running in (if any). If neither org nor space are configured, they default per the userâ€™s profile in Cloud Foundry.









## Single Sign On

















<td class="content">All of the OAuth2 SSO and resource server features moved to Spring Boot in version 1.3\. You can find documentation in the [Spring Boot user guide](http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/).











This project provides automatic binding from CloudFoundry service credentials to the Spring Boot features. If you have a CloudFoundry service called "sso", for instance, with credentials containing "client_id", "client_secret" and "auth_domain", it will bind automatically to the Spring OAuth2 client that you enable with `@EnableOAuth2Sso` (from Spring Boot). The name of the service can be parameterized using `spring.oauth2.sso.serviceId`.







# Spring Cloud Cluster









## Leader Election





Leader election allows application to work together with other applications to coordinate a cluster leadership via a third party system. Currently we provide integrations with `zookeeper`, `hazelcast` and `etcd`.





From user perspective election is working via interfaces `org.springframework.cloud.cluster.leader.Candidate` and `org.springframework.cloud.cluster.leader.Context`. `Candidate` contains access to leadershipâ€™s `role` and `id` and also have methods `onGranted` and `onRevoked`. These callback methods are useful if default `Candidate` implementation is changed.





Leader election is auto-configured if `spring-cloud-cluster-autoconfigure` and either `spring-cloud-cluster-hazelcast`, `spring-cloud-cluster-zookeeper` or `spring-cloud-cluster-etcd` jars are found from a classpath. In case where both jars are found leader election is created using both systems. See sections [Zookeeper](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-cluster-leaderelection-zookeeper), [Hazelcast](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-cluster-leaderelection-hazelcast) and [Etcd](http://cloud.spring.io/spring-cloud-static/spring-cloud.html#spring-cloud-cluster-leaderelection-etcd) for more information about a created beans.





Default `Candidate` created from auto-configuration is `org.springframework.cloud.cluster.leader.DefaultCandidate` which currently only logs granted and revoked events.





If thereâ€™s a need for disable all leader related auto-configuration, a `spring.cloud.cluster.leader.enabled` can be set to false which then allows to do manual configuration even if the jars an on a classpath. Properties `spring.cloud.cluster.leader.id` and `spring.cloud.cluster.leader.role` can be used to set default identifier and role.





If you are interested to simple get notification of granted and revoked events one option is to attach event listener into spring application context. Events `OnGrantedEvent` and `OnRevokedEvent` are sent as spring event objects.





Simply create your own event listener class:







    class MyEventListener implements ApplicationListener<AbstractLeaderEvent> {

      @Override
      public void onApplicationEvent(AbstractLeaderEvent event) {
        // do something with OnGrantedEvent or OnRevokedEvent
      }
    }







and then create it as a bean.







    @Configuration
    static class Config {
      @Bean
      public MyEventListener myEventListener() {
        return new MyEventListener();
      }
    }







For simply log events you can also use a utility class `LoggingListener` which allows easy configuration.







    import org.springframework.cloud.cluster.leader.event.LoggingListener;

    @Configuration
    static class Config {
      @Bean
      public LoggingListener loggingListener() {
        return new LoggingListener("info");
      }
    }







### Zookeeper



`Candidate` implementation for zookeeper is created with a bean name `zookeeperLeaderCandidate` which can be used to override the one created during auto-configuration.





Zookeeper based election can be explicitly disabled using property `spring.cloud.cluster.zookeeper.leader.enabled`.





Other properties `spring.cloud.cluster.zookeeper.namespace` and `spring.cloud.cluster.zookeeper.connect` can be used to set the zookeeper base namespace path and connect string.







### Hazelcast



`Candidate` implementation for hazelcast is created with a bean name `hazelcastLeaderCandidate` which can be used to override the one created during auto-configuration.





Hazelcast based election can be explicitly disabled using property `spring.cloud.cluster.hazelcast.leader.enabled`. If you want to provide xml based configuration for Hazelcast instance use property `spring.cloud.cluster.hazelcast.config-location` to tell location of a Hazelcast xml configuration file. `config-location` is a normal spring `Resource`.







### Etcd



`Candidate` implementation for etcd is created with a bean name `etcdLeaderCandidate` which can be used to override the one created during auto-configuration.





Etcd based election can be explicitly disabled using property `spring.cloud.cluster.etcd.leader.enabled`.





Multiple etcd cluster uris can be specified using property `spring.cloud.cluster.etcd.connect`









# Appendix: Compendium of Configuration Properties





<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 33%;"> <col style="width: 33%;"> <col style="width: 33%;"></colgroup>
<thead>




<th class="tableblock halign-left valign-top">Name</th>

<th class="tableblock halign-left valign-top">Default</th>

<th class="tableblock halign-left valign-top">Description</th>



</thead>







encrypt.fail-on-error





true





Flag to say that a process should fail if there is an encryption or decryption error.









encrypt.key





A symmetric key. As a stronger alternative consider using a keystore.









encrypt.key-store.alias





Alias for a key in the store.









encrypt.key-store.location





Location of the key store file, e.g. classpath:/keystore.jks.









encrypt.key-store.password





Password that locks the keystore.









encrypt.key-store.secret





Secret protecting the key (defaults to the same as the password).









encrypt.rsa.algorithm





The RSA algorithm to use (DEFAULT or OEAP). Once it is set do not change it (or existing ciphers will not a decryptable).









encrypt.rsa.salt





deadbeef





Salt for the random secret used to encrypt cipher text. Once it is set do not change it (or existing ciphers will not a decryptable).









encrypt.rsa.strong





false





Flag to indicate that "strong" AES encryption should be used internally. If true then the GCM algorithm is applied to the AES encrypted bytes. Default is false (in which case "standard" CBC is used instead). Once it is set do not change it (or existing ciphers will not a decryptable).









endpoints.bus.enabled









endpoints.bus.id









endpoints.bus.sensitive









endpoints.consul.enabled









endpoints.consul.id









endpoints.consul.sensitive









endpoints.features.enabled









endpoints.features.id









endpoints.features.sensitive









endpoints.pause.enabled









endpoints.pause.id









endpoints.pause.sensitive









endpoints.refresh.enabled









endpoints.refresh.id









endpoints.refresh.sensitive









endpoints.restart.enabled









endpoints.restart.id









endpoints.restart.pause-endpoint.enabled









endpoints.restart.pause-endpoint.id









endpoints.restart.pause-endpoint.sensitive









endpoints.restart.resume-endpoint.enabled









endpoints.restart.resume-endpoint.id









endpoints.restart.resume-endpoint.sensitive









endpoints.restart.sensitive









endpoints.restart.timeout





0









endpoints.resume.enabled









endpoints.resume.id









endpoints.resume.sensitive









eureka.client.allow-redirects





false





Indicates whether server can redirect a client request to a backup server/cluster. If set to false, the server will handle the request directly, If set to true, it may send HTTP redirect to the client, with a new server location.









eureka.client.availability-zones





Gets the list of availability zones (used in AWS data centers) for the region in which this instance resides.

The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSeconds.









eureka.client.backup-registry-impl





Gets the name of the implementation which implements BackupRegistry to fetch the registry information as a fall back option for only the first time when the eureka client starts.

This may be needed for applications which needs additional resiliency for registry information without which it cannot operate.









eureka.client.cache-refresh-executor-exponential-back-off-bound





10





Cache refresh executor exponential back off related property. It is a maximum multiplier value for retry delay, in case where a sequence of timeouts occurred.









eureka.client.cache-refresh-executor-thread-pool-size





2





The thread pool size for the cacheRefreshExecutor to initialise with









eureka.client.client-data-accept





EurekaAccept name for client data accept









eureka.client.decoder-name





This is a transient config and once the latest codecs are stable, can be removed (as there will only be one)









eureka.client.disable-delta





false





Indicates whether the eureka client should disable fetching of delta and should rather resort to getting the full registry information.

Note that the delta fetches can reduce the traffic tremendously, because the rate of change with the eureka server is normally much lower than the rate of fetches.

The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSeconds









eureka.client.dollar-replacement





_-





Get a replacement string for Dollar sign <code>$</code> during serializing/deserializing information in eureka server.









eureka.client.enabled





true





Flag to indicate that the Eureka client is enabled.









eureka.client.encoder-name





This is a transient config and once the latest codecs are stable, can be removed (as there will only be one)









eureka.client.escape-char-replacement





__





Get a replacement string for underscore sign <code>_</code> during serializing/deserializing information in eureka server.









eureka.client.eureka-connection-idle-timeout-seconds





30





Indicates how much time (in seconds) that the HTTP connections to eureka server can stay idle before it can be closed.

In the AWS environment, it is recommended that the values is 30 seconds or less, since the firewall cleans up the connection information after a few mins leaving the connection hanging in limbo









eureka.client.eureka-server-connect-timeout-seconds





5





Indicates how long to wait (in seconds) before a connection to eureka server needs to timeout. Note that the connections in the client are pooled by org.apache.http.client.HttpClient and this setting affects the actual connection creation and also the wait time to get the connection from the pool.









eureka.client.eureka-server-dnsname





Gets the DNS name to be queried to get the list of eureka servers.This information is not required if the contract returns the service urls by implementing serviceUrls.

The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically.

The changes are effective at runtime.









eureka.client.eureka-server-port





Gets the port to be used to construct the service url to contact eureka server when the list of eureka servers come from the DNS.This information is not required if the contract returns the service urls eurekaServerServiceUrls(String).

The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically.

The changes are effective at runtime.









eureka.client.eureka-server-read-timeout-seconds





8





Indicates how long to wait (in seconds) before a read from eureka server needs to timeout.









eureka.client.eureka-server-total-connections





200





Gets the total number of connections that is allowed from eureka client to all eureka servers.









eureka.client.eureka-server-total-connections-per-host





50





Gets the total number of connections that is allowed from eureka client to a eureka server host.









eureka.client.eureka-server-urlcontext





Gets the URL context to be used to construct the service url to contact eureka server when the list of eureka servers come from the DNS. This information is not required if the contract returns the service urls from eurekaServerServiceUrls.

The DNS mechanism is used when useDnsForFetchingServiceUrls is set to true and the eureka client expects the DNS to configured a certain way so that it can fetch changing eureka servers dynamically. The changes are effective at runtime.









eureka.client.eureka-service-url-poll-interval-seconds





0





Indicates how often(in seconds) to poll for changes to eureka server information. Eureka servers could be added or removed and this setting controls how soon the eureka clients should know about it.









eureka.client.fetch-registry





true





Indicates whether this client should fetch eureka registry information from eureka server.









eureka.client.fetch-remote-regions-registry





Comma separated list of regions for which the eureka registry information will be fetched. It is mandatory to define the availability zones for each of these regions as returned by availabilityZones. Failing to do so, will result in failure of discovery client startup.









eureka.client.filter-only-up-instances





true





Indicates whether to get the applications after filtering the applications for instances with only InstanceStatus UP states.









eureka.client.g-zip-content





true





Indicates whether the content fetched from eureka server has to be compressed whenever it is supported by the server. The registry information from the eureka server is compressed for optimum network traffic.









eureka.client.heartbeat-executor-exponential-back-off-bound





10





Heartbeat executor exponential back off related property. It is a maximum multiplier value for retry delay, in case where a sequence of timeouts occurred.









eureka.client.heartbeat-executor-thread-pool-size





2





The thread pool size for the heartbeatExecutor to initialise with









eureka.client.initial-instance-info-replication-interval-seconds





40





Indicates how long initially (in seconds) to replicate instance info to the eureka server









eureka.client.instance-info-replication-interval-seconds





30





Indicates how often(in seconds) to replicate instance changes to be replicated to the eureka server.









eureka.client.log-delta-diff





false





Indicates whether to log differences between the eureka server and the eureka client in terms of registry information.

Eureka client tries to retrieve only delta changes from eureka server to minimize network traffic. After receiving the deltas, eureka client reconciles the information from the server to verify it has not missed out some information. Reconciliation failures could happen when the client has had network issues communicating to server.If the reconciliation fails, eureka client gets the full registry information.

While getting the full registry information, the eureka client can log the differences between the client and the server and this setting controls that.

The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSecondsr









eureka.client.on-demand-update-status-change





true





If set to true, local status updates via ApplicationInfoManager will trigger on-demand (but rate limited) register/updates to remote eureka servers









eureka.client.prefer-same-zone-eureka





true





Indicates whether or not this instance should try to use the eureka server in the same zone for latency and/or other reason.

Ideally eureka clients are configured to talk to servers in the same zone

The changes are effective at runtime at the next registry fetch cycle as specified by registryFetchIntervalSeconds









eureka.client.property-resolver









eureka.client.proxy-host





Gets the proxy host to eureka server if any.









eureka.client.proxy-password





Gets the proxy password if any.









eureka.client.proxy-port





Gets the proxy port to eureka server if any.









eureka.client.proxy-user-name





Gets the proxy user name if any.









eureka.client.region





us-east-1





Gets the region (used in AWS datacenters) where this instance resides.









eureka.client.register-with-eureka





true





Indicates whether or not this instance should register its information with eureka server for discovery by others.

In some cases, you do not want your instances to be discovered whereas you just want do discover other instances.









eureka.client.registry-fetch-interval-seconds





30





Indicates how often(in seconds) to fetch the registry information from the eureka server.









eureka.client.registry-refresh-single-vip-address





Indicates whether the client is only interested in the registry information for a single VIP.









eureka.client.service-url





Map of availability zone to list of fully qualified URLs to communicate with eureka server. Each value can be a single URL or a comma separated list of alternative locations.

Typically the eureka server URLs carry protocol,host,port,context and version information if any. Example: [http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/](http://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/)

The changes are effective at runtime at the next service url refresh cycle as specified by eurekaServiceUrlPollIntervalSeconds.









eureka.client.transport









eureka.client.use-dns-for-fetching-service-urls





false





Indicates whether the eureka client should use the DNS mechanism to fetch a list of eureka servers to talk to. When the DNS name is updated to have additional servers, that information is used immediately after the eureka client polls for that information as specified in eurekaServiceUrlPollIntervalSeconds.

Alternatively, the service urls can be returned serviceUrls, but the users should implement their own mechanism to return the updated list in case of changes.

The changes are effective at runtime.









eureka.dashboard.enabled





true





Flag to enable the Eureka dashboard. Default true.









eureka.dashboard.path





/





The path to the Eureka dashboard (relative to the servlet path). Defaults to "/".









eureka.instance.a-sgname





Gets the AWS autoscaling group name associated with this instance. This information is specifically used in an AWS environment to automatically put an instance out of service after the instance is launched and it has been disabled for traffic..









eureka.instance.app-group-name





Get the name of the application group to be registered with eureka.









eureka.instance.appname





unknown





Get the name of the application to be registered with eureka.









eureka.instance.data-center-info





Returns the data center this instance is deployed. This information is used to get some AWS specific instance information if the instance is deployed in AWS.









eureka.instance.default-address-resolution-order





[]









eureka.instance.health-check-url





Gets the absolute health check page URL for this instance. The users can provide the healthCheckUrlPath if the health check page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence.

<p> It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage. The full URL should follow the format [http://${eureka.hostname}:7001/](http://%24%7Beureka.hostname%7D:7001/) where the value ${eureka.hostname} is replaced at runtime.









eureka.instance.health-check-url-path





/health





Gets the relative health check URL path for this instance. The health check page URL is then constructed out of the hostname and the type of communication - secure or unsecure as specified in securePort and nonSecurePort.

It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage.









eureka.instance.home-page-url





Gets the absolute home page URL for this instance. The users can provide the homePageUrlPath if the home page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence.

It is normally used for informational purposes for other services to use it as a landing page. The full URL should follow the format [http://${eureka.hostname}:7001/](http://%24%7Beureka.hostname%7D:7001/) where the value ${eureka.hostname} is replaced at runtime.









eureka.instance.home-page-url-path





/





Gets the relative home page URL Path for this instance. The home page URL is then constructed out of the hostName and the type of communication - secure or unsecure.

It is normally used for informational purposes for other services to use it as a landing page.









eureka.instance.host-info









eureka.instance.hostname





The hostname if it can be determined at configuration time (otherwise it will be guessed from OS primitives).









eureka.instance.inet-utils









eureka.instance.initial-status





Initial status to register with rmeote Eureka server.









eureka.instance.instance-enabled-onit





false





Indicates whether the instance should be enabled for taking traffic as soon as it is registered with eureka. Sometimes the application might need to do some pre-processing before it is ready to take traffic.









eureka.instance.instance-id





Get the unique Id (within the scope of the appName) of this instance to be registered with eureka.









eureka.instance.ip-address





Get the IPAdress of the instance. This information is for academic purposes only as the communication from other instances primarily happen using the information supplied in {@link #getHostName(boolean)}.









eureka.instance.lease-expiration-duration-in-seconds





90





Indicates the time in seconds that the eureka server waits since it received the last heartbeat before it can remove this instance from its view and there by disallowing traffic to this instance.

Setting this value too long could mean that the traffic could be routed to the instance even though the instance is not alive. Setting this value too small could mean, the instance may be taken out of traffic because of temporary network glitches.This value to be set to atleast higher than the value specified in leaseRenewalIntervalInSeconds.









eureka.instance.lease-renewal-interval-in-seconds





30





Indicates how often (in seconds) the eureka client needs to send heartbeats to eureka server to indicate that it is still alive. If the heartbeats are not received for the period specified in leaseExpirationDurationInSeconds, eureka server will remove the instance from its view, there by disallowing traffic to this instance.

Note that the instance could still not take traffic if it implements HealthCheckCallback and then decides to make itself unavailable.









eureka.instance.metadata-map





Gets the metadata name/value pairs associated with this instance. This information is sent to eureka server and can be used by other instances.









eureka.instance.namespace





eureka





Get the namespace used to find properties. Ignored in Spring Cloud.









eureka.instance.non-secure-port





80





Get the non-secure port on which the instance should receive traffic.









eureka.instance.non-secure-port-enabled





true





Indicates whether the non-secure port should be enabled for traffic or not.









eureka.instance.prefer-ip-address





false





Flag to say that, when guessing a hostname, the IP address of the server should be used in prference to the hostname reported by the OS.









eureka.instance.secure-health-check-url





Gets the absolute secure health check page URL for this instance. The users can provide the secureHealthCheckUrl if the health check page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence.

<p> It is normally used for making educated decisions based on the health of the instance - for example, it can be used to determine whether to proceed deployments to an entire farm or stop the deployments without causing further damage. The full URL should follow the format [http://${eureka.hostname}:7001/](http://%24%7Beureka.hostname%7D:7001/) where the value ${eureka.hostname} is replaced at runtime.









eureka.instance.secure-port





443





Get the Secure port on which the instance should receive traffic.









eureka.instance.secure-port-enabled





false





Indicates whether the secure port should be enabled for traffic or not.









eureka.instance.secure-virtual-host-name





Gets the secure virtual host name defined for this instance.

This is typically the way other instance would find this instance by using the secure virtual host name.Think of this as similar to the fully qualified domain name, that the users of your services will need to find this instance.









eureka.instance.status-page-url





Gets the absolute status page URL path for this instance. The users can provide the statusPageUrlPath if the status page resides in the same instance talking to eureka, else in the cases where the instance is a proxy for some other server, users can provide the full URL. If the full URL is provided it takes precedence.

It is normally used for informational purposes for other services to find about the status of this instance. Users can provide a simple HTML indicating what is the current status of the instance.









eureka.instance.status-page-url-path





/info





Gets the relative status page URL path for this instance. The status page URL is then constructed out of the hostName and the type of communication - secure or unsecure as specified in securePort and nonSecurePort.

It is normally used for informational purposes for other services to find about the status of this instance. Users can provide a simple HTML indicating what is the current status of the instance.









eureka.instance.virtual-host-name





Gets the virtual host name defined for this instance.

This is typically the way other instance would find this instance by using the virtual host name.Think of this as similar to the fully qualified domain name, that the users of your services will need to find this instance.









eureka.server.a-sgcache-expiry-timeout-ms





0









eureka.server.a-sgquery-timeout-ms





300









eureka.server.a-sgupdate-interval-ms





0









eureka.server.a-wsaccess-id









eureka.server.a-wssecret-key









eureka.server.batch-replication





false









eureka.server.binding-strategy









eureka.server.delta-retention-timer-interval-in-ms





0









eureka.server.disable-delta





false









eureka.server.disable-delta-for-remote-regions





false









eureka.server.disable-transparent-fallback-to-other-region





false









eureka.server.e-ipbind-rebind-retries





3









eureka.server.e-ipbinding-retry-interval-ms





0









eureka.server.e-ipbinding-retry-interval-ms-when-unbound





0









eureka.server.enable-replicated-request-compression





false









eureka.server.enable-self-preservation





true









eureka.server.eviction-interval-timer-in-ms





0









eureka.server.g-zip-content-from-remote-region





true









eureka.server.json-codec-name









eureka.server.list-auto-scaling-groups-role-name





ListAutoScalingGroups









eureka.server.log-identity-headers





true









eureka.server.max-elements-in-peer-replication-pool





10000









eureka.server.max-elements-in-status-replication-pool





10000









eureka.server.max-idle-thread-age-in-minutes-for-peer-replication





15









eureka.server.max-idle-thread-in-minutes-age-for-status-replication





10









eureka.server.max-threads-for-peer-replication





20









eureka.server.max-threads-for-status-replication





1









eureka.server.max-time-for-replication





30000









eureka.server.min-threads-for-peer-replication





5









eureka.server.min-threads-for-status-replication





1









eureka.server.number-of-replication-retries





5









eureka.server.peer-eureka-nodes-update-interval-ms





0









eureka.server.peer-eureka-status-refresh-time-interval-ms





0









eureka.server.peer-node-connect-timeout-ms





200









eureka.server.peer-node-connection-idle-timeout-seconds





30









eureka.server.peer-node-read-timeout-ms





200









eureka.server.peer-node-total-connections





1000









eureka.server.peer-node-total-connections-per-host





500









eureka.server.prime-aws-replica-connections





true









eureka.server.property-resolver









eureka.server.rate-limiter-burst-size





10









eureka.server.rate-limiter-enabled





false









eureka.server.rate-limiter-full-fetch-average-rate





100









eureka.server.rate-limiter-privileged-clients









eureka.server.rate-limiter-registry-fetch-average-rate





500









eureka.server.rate-limiter-throttle-standard-clients





false









eureka.server.registry-sync-retries





0









eureka.server.registry-sync-retry-wait-ms





0









eureka.server.remote-region-app-whitelist









eureka.server.remote-region-connect-timeout-ms





1000









eureka.server.remote-region-connection-idle-timeout-seconds





30









eureka.server.remote-region-fetch-thread-pool-size





20









eureka.server.remote-region-read-timeout-ms





1000









eureka.server.remote-region-registry-fetch-interval





30









eureka.server.remote-region-total-connections





1000









eureka.server.remote-region-total-connections-per-host





500









eureka.server.remote-region-trust-store









eureka.server.remote-region-trust-store-password





changeit









eureka.server.remote-region-urls









eureka.server.remote-region-urls-with-name









eureka.server.renewal-percent-threshold





0.85









eureka.server.renewal-threshold-update-interval-ms





0









eureka.server.response-cache-auto-expiration-in-seconds





180









eureka.server.response-cache-update-interval-ms





0









eureka.server.retention-time-in-msin-delta-queue





0









eureka.server.route53-bind-rebind-retries





3









eureka.server.route53-binding-retry-interval-ms





0









eureka.server.route53-domain-ttl





30









eureka.server.sync-when-timestamp-differs





true









eureka.server.use-read-only-response-cache





true









eureka.server.wait-time-in-ms-when-sync-empty





0









eureka.server.xml-codec-name









feign.compression.request.mime-types





[text/xml, application/xml, application/json]





The list of supported mime types.









feign.compression.request.min-request-size





2048





The minimum threshold content size.









health.config.enabled





false





Flag to indicate that the config server health indicator should be installed.









health.hystrix.enabled





false





Flag to inidicate that the hystrix health indicator should be installed.









netflix.atlas.batch-size





10000









netflix.atlas.enabled





true









netflix.atlas.uri









proxy.auth.load-balanced





false









proxy.auth.routes





Authentication strategy per route.









spring.cloud.bus.ack.destination-service





Service that wants to listen to acks. By default null (meaning all services).









spring.cloud.bus.ack.enabled





true





Flag to switch off acks (default on).









spring.cloud.bus.destination





springCloudBus





Name of Spring Cloud Stream destination for messages.









spring.cloud.bus.enabled





true





Flag to indicate that the bus is enabled.









spring.cloud.bus.env.enabled





true





Flag to switch off environment change events (default on).









spring.cloud.bus.refresh.enabled





true





Flag to switch off refresh events (default on).









spring.cloud.bus.trace.enabled





false





Flag to switch on tracing of acks (default off).









spring.cloud.cloudfoundry.discovery.email





Email address of user to authenticate.









spring.cloud.cloudfoundry.discovery.enabled





true





Flag to indicate that discovery is enabled.









spring.cloud.cloudfoundry.discovery.password





Password for user to authenticate and obtain token.









spring.cloud.cloudfoundry.discovery.url





[https://api.run.pivotal.io](https://api.run.pivotal.io/)





URL of Cloud Foundry API (Cloud Controller).









spring.cloud.config.allow-override





true





Flag to indicate that {@link #isSystemPropertiesOverride() systemPropertiesOverride} can be used. Set to false to prevent users from changing the default accidentally. Default true.









spring.cloud.config.discovery.enabled





false





Flag to indicate that config server discovery is enabled (config server URL will be looked up via discovery).









spring.cloud.config.discovery.service-id





CONFIGSERVER





Service id to locate config server.









spring.cloud.config.enabled





true





Flag to say that remote configuration is enabled. Default true;









spring.cloud.config.fail-fast





false





Flag to indicate that failure to connect to the server is fatal (default false).









spring.cloud.config.label





The label name to use to pull remote configuration properties. The default is set on the server (generally "master" for a git based server).









spring.cloud.config.name





Name of application used to fetch remote properties.









spring.cloud.config.override-none





false





Flag to indicate that when {@link #setAllowOverride(boolean) allowOverride} is true, external properties should take lowest priority, and not override any existing property sources (including local config files). Default false.









spring.cloud.config.override-system-properties





true





Flag to indicate that the external properties should override system properties. Default true.









spring.cloud.config.password





The password to use (HTTP Basic) when contacting the remote server.









spring.cloud.config.profile





default





The default profile to use when fetching remote configuration (comma-separated). Default is "default".









spring.cloud.config.retry.initial-interval





1000





Initial retry interval in milliseconds.









spring.cloud.config.retry.max-attempts





6





Maximum number of attempts.









spring.cloud.config.retry.max-interval





2000





Maximum interval for backoff.









spring.cloud.config.retry.multiplier





1.1





Multiplier for next interval.









spring.cloud.config.uri





[http://localhost:8888](http://localhost:8888/)





The URI of the remote server (default [http://localhost:8888](http://localhost:8888/)).









spring.cloud.config.username





The username to use (HTTP Basic) when contacting the remote server.









spring.cloud.consul.config.acl-token









spring.cloud.consul.config.data-key





data





If format is Format.PROPERTIES or Format.YAML then the following field is used as key to look up consul for configuration.









spring.cloud.consul.config.default-context





application









spring.cloud.consul.config.enabled





true









spring.cloud.consul.config.fail-fast





true





Throw exceptions during config lookup if true, otherwise, log warnings.









spring.cloud.consul.config.format









spring.cloud.consul.config.prefix





config









spring.cloud.consul.config.profile-separator





,









spring.cloud.consul.config.watch.delay





10









spring.cloud.consul.config.watch.enabled





true









spring.cloud.consul.config.watch.wait-time





2









spring.cloud.consul.discovery.acl-token









spring.cloud.consul.discovery.catalog-services-watch-delay





10









spring.cloud.consul.discovery.catalog-services-watch-timeout





2









spring.cloud.consul.discovery.enabled





true





Is service discovery enabled?









spring.cloud.consul.discovery.health-check-interval





10s





How often to perform the health check (e.g. 10s)









spring.cloud.consul.discovery.health-check-path





/health





Alternate server path to invoke for health checking









spring.cloud.consul.discovery.health-check-timeout





Timeout for health check (e.g. 10s)









spring.cloud.consul.discovery.health-check-url





Custom health check url to override default









spring.cloud.consul.discovery.heartbeat.enabled





false









spring.cloud.consul.discovery.heartbeat.heartbeat-interval









spring.cloud.consul.discovery.heartbeat.interval-ratio









spring.cloud.consul.discovery.heartbeat.ttl-unit





s









spring.cloud.consul.discovery.heartbeat.ttl-value





30









spring.cloud.consul.discovery.host-info









spring.cloud.consul.discovery.hostname





Hostname to use when accessing server









spring.cloud.consul.discovery.instance-id





Unique service instance id









spring.cloud.consul.discovery.ip-address





IP address to use when accessing service (must also set preferIpAddress to use)









spring.cloud.consul.discovery.lifecycle.enabled





true









spring.cloud.consul.discovery.management-suffix





management





Suffix to use when registering management service









spring.cloud.consul.discovery.management-tags





Tags to use when registering management service









spring.cloud.consul.discovery.port





Port to register the service under (defaults to listening port)









spring.cloud.consul.discovery.prefer-agent-address





false





Source of how we will determine the address to use









spring.cloud.consul.discovery.prefer-ip-address





false





Use ip address rather than hostname during registration









spring.cloud.consul.discovery.query-passing





false





Add the 'passing` parameter to /v1/health/service/serviceName. This pushes health check passing to the server.









spring.cloud.consul.discovery.register





true





Register as a service in consul.









spring.cloud.consul.discovery.register-health-check





true





Register health check in consul. Useful during development of a service.









spring.cloud.consul.discovery.scheme





http





Whether to register an http or https service









spring.cloud.consul.discovery.server-list-query-tags





Map of serviceIdâ€™s â†’ tag to query for in server list. This allows filtering services by a single tag.









spring.cloud.consul.discovery.service-name





Service name









spring.cloud.consul.discovery.tags





Tags to use when registering service









spring.cloud.consul.enabled





true





Is spring cloud consul enabled









spring.cloud.consul.host





localhost





Consul agent hostname. Defaults to 'localhost'.









spring.cloud.consul.port





8500





Consul agent port. Defaults to '8500'.









spring.cloud.consul.retry.initial-interval





1000





Initial retry interval in milliseconds.









spring.cloud.consul.retry.max-attempts





6





Maximum number of attempts.









spring.cloud.consul.retry.max-interval





2000





Maximum interval for backoff.









spring.cloud.consul.retry.multiplier





1.1





Multiplier for next interval.









spring.cloud.hypermedia.refresh.fixed-delay





5000









spring.cloud.hypermedia.refresh.initial-delay





10000









spring.cloud.inetutils.default-hostname





localhost





The default hostname. Used in case of errors.









spring.cloud.inetutils.default-ip-address





127.0.0.1





The default ipaddress. Used in case of errors.









spring.cloud.inetutils.ignored-interfaces





List of Java regex expressions for network interfaces that will be ignored.









spring.cloud.inetutils.timeout-seconds





1





Timeout in seconds for calculating hostname.









spring.cloud.stream.binders









spring.cloud.stream.bindings









spring.cloud.stream.consumer-defaults









spring.cloud.stream.default-binder









spring.cloud.stream.dynamic-destinations





[]









spring.cloud.stream.ignore-unknown-properties





true









spring.cloud.stream.instance-count





1









spring.cloud.stream.instance-index





0









spring.cloud.stream.producer-defaults









spring.cloud.stream.rabbit.binder.addresses





[]









spring.cloud.stream.rabbit.binder.admin-adresses





[]









spring.cloud.stream.rabbit.binder.compression-level





0









spring.cloud.stream.rabbit.binder.nodes





[]









spring.cloud.stream.rabbit.binder.password









spring.cloud.stream.rabbit.binder.ssl-properties-location









spring.cloud.stream.rabbit.binder.use-ssl





false









spring.cloud.stream.rabbit.binder.username









spring.cloud.stream.rabbit.binder.vhost









spring.cloud.stream.rabbit.bindings









spring.cloud.zookeeper.default-health-endpoint





Default health endpoint that will be checked to verify that a dependency is alive









spring.cloud.zookeeper.dependencies





Mapping of alias to ZookeeperDependency. From Ribbon perspective the alias is actually serviceID since Ribbon canâ€™t accept nested structures in serviceID









spring.cloud.zookeeper.dependency-configurations









spring.cloud.zookeeper.dependency-names









spring.cloud.zookeeper.discovery.enabled





true









spring.cloud.zookeeper.discovery.instance-host









spring.cloud.zookeeper.discovery.metadata





Gets the metadata name/value pairs associated with this instance. This information is sent to zookeeper and can be used by other instances.









spring.cloud.zookeeper.discovery.root





/services









spring.cloud.zookeeper.discovery.uri-spec





{scheme}://{address}:{port}









spring.cloud.zookeeper.prefix





Common prefix that will be applied to all Zookeeper dependencies' paths









spring.integration.poller.fixed-delay





1000





Fixed delay for default poller.









spring.integration.poller.max-messages-per-poll





1





Maximum messages per poll for the default poller.









spring.sleuth.keys.async.class-name-key





class





Simple name of the class with a method annotated with {@code @Async} from which the asynchronous process started

@see org.springframework.scheduling.annotation.Async









spring.sleuth.keys.async.method-name-key





method





Name of the method annotated with {@code @Async}

@see org.springframework.scheduling.annotation.Async









spring.sleuth.keys.async.prefix





Prefix for header names if they are added as tags.









spring.sleuth.keys.async.thread-name-key





thread





Name of the thread that executed the async method

@see org.springframework.scheduling.annotation.Async









spring.sleuth.keys.http.headers





Additional headers that should be added as tags if they exist. If the header value is multi-valued, the tag value will be a comma-separated, single-quoted list.









spring.sleuth.keys.http.host





http.host





The domain portion of the URL or host header. Example: "mybucket.s3.amazonaws.com". Used to filter by host as opposed to ip address.









spring.sleuth.keys.http.method





http.method





The HTTP method, or verb, such as "GET" or "POST". Used to filter against an http route.









spring.sleuth.keys.http.path





http.path





The absolute http path, without any query parameters. Example: "/objects/abcd-ff". Used to filter against an http route, portably with zipkin v1\. In zipkin v1, only equals filters are supported. Dropping query parameters makes the number of distinct URIs less. For example, one can query for the same resource, regardless of signing parameters encoded in the query line. This does not reduce cardinality to a HTTP single route. For example, it is common to express a route as an http URI template like "/resource/{resource_id}". In systems where only equals queries are available, searching for {@code http.uri=/resource} wonâ€™t match if the actual request was "/resource/abcd-ff". Historical note: This was commonly expressed as "http.uri" in zipkin, eventhough it was most often just a path.









spring.sleuth.keys.http.prefix





http.





Prefix for header names if they are added as tags.









spring.sleuth.keys.http.request-size





http.request.size





The size of the non-empty HTTP request body, in bytes. Ex. "16384"

<p>Large uploads can exceed limits or contribute directly to latency.









spring.sleuth.keys.http.response-size





http.response.size





The size of the non-empty HTTP response body, in bytes. Ex. "16384"

<p>Large downloads can exceed limits or contribute directly to latency.









spring.sleuth.keys.http.status-code





http.status_code





The HTTP response code, when not in 2xx range. Ex. "503" Used to filter for error status. 2xx range are not logged as success codes are less interesting for latency troubleshooting. Omitting saves at least 20 bytes per span.









spring.sleuth.keys.http.url





http.url





The entire URL, including the scheme, host and query parameters if available. Ex. "https://mybucket.s3.amazonaws.com/objects/abcd-ff?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Algorithm=AWS4-HMAC-SHA256â€¦â€‹" Combined with {@link #method}, you can understand the fully-qualified request line. This is optional as it may include private data or be of considerable length.









spring.sleuth.keys.hystrix.command-group





commandGroup





Name of the command group. Hystrix uses the command group key to group together commands such as for reporting, alerting, dashboards, or team/library ownership.

@see com.netflix.hystrix.HystrixCommandGroupKey









spring.sleuth.keys.hystrix.command-key





commandKey





Name of the command key. Describes the name for the given command. A key to represent a {@link com.netflix.hystrix.HystrixCommand} for monitoring, circuit-breakers, metrics publishing, caching and other such uses.

@see com.netflix.hystrix.HystrixCommandKey









spring.sleuth.keys.hystrix.prefix





Prefix for header names if they are added as tags.









spring.sleuth.keys.hystrix.thread-pool-key





threadPoolKey





Name of the thread pool key. The thread-pool key represents a {@link com.netflix.hystrix.HystrixThreadPool} for monitoring, metrics publishing, caching, and other such uses. A {@link com.netflix.hystrix.HystrixCommand} is associated with a single {@link com.netflix.hystrix.HystrixThreadPool} as retrieved by the {@link com.netflix.hystrix.HystrixThreadPoolKey} injected into it, or it defaults to one created using the {@link com.netflix.hystrix.HystrixCommandGroupKey} it is created with.

@see com.netflix.hystrix.HystrixThreadPoolKey









spring.sleuth.keys.message.headers





Additional headers that should be added as tags if they exist. If the header value is not a String it will be converted to a String using its toString() method.









spring.sleuth.keys.message.payload.size





message/payload-size





An estimate of the size of the payload if available.









spring.sleuth.keys.message.payload.type





message/payload-type





The type of the payload.









spring.sleuth.keys.message.prefix





message/





Prefix for header names if they are added as tags.









spring.sleuth.metric.span.accepted-name





counter.span.accepted









spring.sleuth.metric.span.dropped-name





counter.span.dropped









spring.sleuth.sampler.percentage





0.1





Percentage of requests that should be sampled. E.g. 1.0 - 100% requests should be sampled. The precision is whole-numbers only (i.e. thereâ€™s no support for 0.1% of the traces).









zuul.add-proxy-headers





true









zuul.host.max-per-route-connections





20









zuul.host.max-total-connections





200









zuul.ignore-local-service






true








zuul.ignored-headers









zuul.ignored-patterns









zuul.ignored-services









zuul.prefix









zuul.remove-semicolon-content





true









zuul.retryable









zuul.routes









zuul.security_headers









zuul.servlet-path





/zuul









zuul.strip-prefix





true









zuul.trace-request-body





true
